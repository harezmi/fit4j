<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fit4j Wiki - Orion Wiki</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>

:root {
  --dw-bg: #020617;
  --dw-bg-elevated: #020617;
  --dw-bg-main: #020617;
  --dw-sidebar-bg: #020617;
  --dw-border-subtle: #1f2937;
  --dw-border-strong: #334155;
  --dw-accent: #8b5cf6;
  --dw-accent-soft: rgba(139,92,246,0.18);
  --dw-text: #e5e7eb;
  --dw-text-muted: #9ca3af;
  --dw-radius-md: 12px;
  --dw-radius-lg: 16px;
  --dw-radius-xl: 20px;
  --dw-shadow-soft: 0 22px 45px rgba(15,23,42,0.85);
  --dw-font-sans: system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
  --dw-font-mono: ui-monospace,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 16px 16px 24px 16px;
  background: radial-gradient(circle at top left, #020617 0, #0f172a 55%, #020617 100%);
  color: var(--dw-text);
  font-family: var(--dw-font-sans);
  -webkit-font-smoothing: antialiased;
}

/* Custom Scrollbar - Webkit */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: rgba(15, 23, 42, 0.6);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #6366f1 0%, #8b5cf6 100%);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, #818cf8 0%, #a78bfa 100%);
}

::-webkit-scrollbar-corner {
  background: transparent;
}

/* Firefox Scrollbar */
* {
  scrollbar-width: thin;
  scrollbar-color: #6366f1 rgba(15, 23, 42, 0.6);
}

.dw-root {
  max-width: 100%;
  margin: 0 auto;
}

.dw-layout {
  display: grid;
  grid-template-columns: 260px minmax(0, 1fr);
  gap: 12px;
}

/* Sidebar */

.dw-sidebar {
  background: linear-gradient(145deg, #020617, #0f172a);
  border-radius: var(--dw-radius-xl);
  border: 1px solid rgba(30,64,175,0.45);
  box-shadow: var(--dw-shadow-soft);
  padding: 12px 10px 12px 10px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: calc(100vh - 32px);
  overflow-y: auto;
}

.dw-sidebar-header {
  padding: 10px 10px 12px 10px;
  border-radius: var(--dw-radius-lg);
  background: radial-gradient(circle at top left, rgba(148,163,184,0.16), transparent 55%), rgba(15,23,42,0.96);
  border: 1px solid rgba(148,163,184,0.4);
}

.dw-brand-row {
  display: flex;
  align-items: center;
  gap: 10px;
}

.dw-logo-icon {
  width: 32px;
  height: 32px;
  border-radius: 12px;
  background: radial-gradient(circle at 30% 20%, #e5e7eb 0, #c4b5fd 22%, #8b5cf6 55%, #4c1d95 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 20px rgba(15,23,42,0.8);
}

.dw-logo-letter {
  font-size: 18px;
  font-weight: 700;
  color: #f9fafb;
}

.dw-brand-text {
  display: flex;
  flex-direction: column;
}

.dw-brand-title {
  font-size: 15px;
  font-weight: 600;
  color: #f9fafb;
}

.dw-brand-subtitle {
  font-size: 11px;
  color: var(--dw-text-muted);
}

.dw-sidebar-repo {
  margin-top: 8px;
  font-size: 11px;
  color: var(--dw-text-muted);
  opacity: 0.9;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Pages */

.dw-sidebar-pages {
  padding: 10px 10px 12px 10px;
  border-radius: var(--dw-radius-lg);
  background: rgba(15,23,42,0.98);
  border: 1px solid rgba(55,65,81,0.9);
  flex: 1;
  display: flex;
  flex-direction: column;
}

.dw-pages-title {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--dw-text-muted);
  margin-bottom: 8px;
}

.dw-pages-list {
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-height: calc(100vh - 210px);
  overflow-y: auto;
  padding-right: 4px;
}

.dw-nav-item {
  width: 100%;
  border-radius: 999px;
  border: none;
  padding: 7px 10px;
  background: transparent;
  color: #e5e7eb;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  text-align: left;
  cursor: pointer;
  transition: all 0.15s ease-out;
}

.dw-nav-item:hover {
  background: rgba(148,163,184,0.18);
  transform: translateX(1px);
}

.dw-nav-item:active {
  transform: translateX(0);
}

.dw-nav-item-active {
  background: linear-gradient(135deg, #a855f7, #ec4899);
  color: #f9fafb;
  box-shadow: 0 0 0 1px rgba(15,23,42,0.9);
}

.dw-nav-item-active .dw-nav-dot {
  box-shadow: 0 0 0 2px rgba(15,23,42,0.85);
}

.dw-nav-dot {
  width: 9px;
  height: 9px;
  border-radius: 999px;
  flex-shrink: 0;
}

.dw-dot-green {
  background: #22c55e;
}

.dw-dot-orange {
  background: #f97316;
}

.dw-dot-blue {
  background: #38bdf8;
}

.dw-nav-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Main */

.dw-main {
  background: radial-gradient(circle at top left, rgba(148,163,184,0.08), transparent 55%), rgba(15,23,42,0.98);
  border-radius: var(--dw-radius-xl);
  border: 1px solid rgba(30,64,175,0.5);
  box-shadow: var(--dw-shadow-soft);
  padding: 16px 20px 20px 20px;
  max-height: calc(100vh - 32px);
  overflow-y: auto;
}

/* Section görünürlüğü */

.dw-section {
  display: none;
}

.dw-section.dw-section-active {
  display: block;
}

.dw-section-inner {
  padding-bottom: 4px;
}

/* Mermaid wrapper */

.dw-mermaid-wrapper {
  margin: 14px 0 18px 0;
  padding: 14px 16px;
  border-radius: 16px;
  background: #020617;
  border: 1px solid #1f2937;
  box-shadow: 0 14px 40px rgba(15,23,42,0.9);
  overflow: auto;
}

/* Typography */

.dw-main h1,
.dw-main h2,
.dw-main h3,
.dw-main h4 {
  color: #f9fafb;
}

.dw-main h1 {
  font-size: 24px;
  margin-top: 0;
  margin-bottom: 12px;
}

.dw-main h2 {
  font-size: 18px;
  margin-top: 20px;
  margin-bottom: 8px;
}

.dw-main h3 {
  font-size: 15px;
  margin-top: 16px;
  margin-bottom: 6px;
}

.dw-main p {
  font-size: 13px;
  line-height: 1.6;
  margin: 4px 0 8px 0;
  color: var(--dw-text);
}

.dw-main ul,
.dw-main ol {
  padding-left: 20px;
  margin: 6px 0 10px 0;
}

.dw-main li {
  font-size: 13px;
  line-height: 1.6;
  margin-bottom: 4px;
}

/* Code blocks */

.dw-main pre {
  background: #020617;
  border-radius: 10px;
  border: 1px solid #1f2937;
  padding: 10px 12px;
  overflow-x: auto;
  margin: 10px 0 14px 0;
}

.dw-main code {
  font-family: var(--dw-font-mono);
  font-size: 12px;
}

.dw-main p code,
.dw-main li code {
  padding: 2px 4px;
  border-radius: 4px;
  background: rgba(15,23,42,0.95);
  border: 1px solid rgba(55,65,81,0.9);
}

/* Tables */

.dw-main table {
  width: 100%;
  border-collapse: collapse;
  margin: 10px 0 16px 0;
  font-size: 12px;
}

.dw-main th,
.dw-main td {
  border: 1px solid rgba(55,65,81,0.8);
  padding: 6px 8px;
}

.dw-main th {
  background: rgba(15,23,42,0.95);
  font-weight: 600;
}

/* Links */

.dw-main a {
  color: #38bdf8;
  text-decoration: none;
}

.dw-main a:hover {
  text-decoration: underline;
}

/* HR */

.dw-main hr {
  border: none;
  border-top: 1px dashed rgba(55,65,81,0.9);
  margin: 16px 0;
}

/* Responsive */

@media (max-width: 900px) {
  body {
    padding: 16px;
  }

  .dw-layout {
    grid-template-columns: minmax(0, 1fr);
  }

  .dw-sidebar {
    order: 0;
  }

  .dw-main {
    order: 1;
    max-height: none;
  }
}

  </style>
  <script src="https://unpkg.com/mermaid@10/dist/mermaid.min.js"></script>
</head>
<body>

<div class="dw-root">
  <div class="dw-layout">
    
<aside class="dw-sidebar">
  <div class="dw-sidebar-header">
    <div class="dw-brand-row">
      <div class="dw-logo-icon">
        <span class="dw-logo-letter">O</span>
      </div>
      <div class="dw-brand-text">
        <div class="dw-brand-title">Fit4j Wiki</div>
        <div class="dw-brand-subtitle">powered by ai</div>
      </div>
    </div>
    <div class="dw-sidebar-repo" title="harezmi_fit4j">harezmi</div>
  </div>
  <div class="dw-sidebar-pages">
    <div class="dw-pages-title">Pages</div>
    <div class="dw-pages-list">
      
<button class="dw-nav-item" data-target="section-project-overview" onclick="showSection('section-project-overview')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Project Overview</span>
</button>


<button class="dw-nav-item" data-target="section-business-domain" onclick="showSection('section-business-domain')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Business Domain & Problem Space</span>
</button>


<button class="dw-nav-item" data-target="section-glossary-and-domain-terms" onclick="showSection('section-glossary-and-domain-terms')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Glossary & Domain Terms</span>
</button>


<button class="dw-nav-item" data-target="section-high-level-architecture" onclick="showSection('section-high-level-architecture')">
  <span class="dw-nav-dot dw-dot-orange"></span>
  <span class="dw-nav-label">High-Level Architecture</span>
</button>


<button class="dw-nav-item" data-target="section-technology-stack" onclick="showSection('section-technology-stack')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Technology Stack & Dependencies</span>
</button>


<button class="dw-nav-item" data-target="section-core-architecture" onclick="showSection('section-core-architecture')">
  <span class="dw-nav-dot dw-dot-orange"></span>
  <span class="dw-nav-label">Core Architecture & Design Principles</span>
</button>


<button class="dw-nav-item" data-target="section-spring-test-context-integration" onclick="showSection('section-spring-test-context-integration')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Spring Test Context & Extension Integration</span>
</button>


<button class="dw-nav-item" data-target="section-database-and-entity-model" onclick="showSection('section-database-and-entity-model')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Database & Entity Model</span>
</button>


<button class="dw-nav-item" data-target="section-indexing-and-performance" onclick="showSection('section-indexing-and-performance')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Indexing, Data Initialization & Performance</span>
</button>


<button class="dw-nav-item" data-target="section-data-lifecycle-and-cleanup" onclick="showSection('section-data-lifecycle-and-cleanup')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Data Lifecycle & Cleanup Strategy</span>
</button>


<button class="dw-nav-item" data-target="section-critical-execution-flows" onclick="showSection('section-critical-execution-flows')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Critical Execution Flows</span>
</button>


<button class="dw-nav-item" data-target="section-http-testing-workflows" onclick="showSection('section-http-testing-workflows')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">HTTP Testing Workflows</span>
</button>


<button class="dw-nav-item" data-target="section-grpc-testing-workflows" onclick="showSection('section-grpc-testing-workflows')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">gRPC Testing Workflows</span>
</button>


<button class="dw-nav-item" data-target="section-kafka-messaging-workflows" onclick="showSection('section-kafka-messaging-workflows')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Kafka Messaging Workflows</span>
</button>


<button class="dw-nav-item" data-target="section-testcontainers-and-embedded-services" onclick="showSection('section-testcontainers-and-embedded-services')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Testcontainers & Embedded Services Integration</span>
</button>


<button class="dw-nav-item" data-target="section-external-integrations-and-data-flow" onclick="showSection('section-external-integrations-and-data-flow')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">External Integrations & Data Flow</span>
</button>


<button class="dw-nav-item" data-target="section-configuration-and-property-management" onclick="showSection('section-configuration-and-property-management')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Configuration & Property Management</span>
</button>


<button class="dw-nav-item" data-target="section-getting-started-and-local-setup" onclick="showSection('section-getting-started-and-local-setup')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Getting Started & Local Setup</span>
</button>


<button class="dw-nav-item" data-target="section-coding-standards-and-conventions" onclick="showSection('section-coding-standards-and-conventions')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Coding Standards & Contribution Conventions</span>
</button>


<button class="dw-nav-item" data-target="section-api-reference-and-annotations" onclick="showSection('section-api-reference-and-annotations')">
  <span class="dw-nav-dot dw-dot-blue"></span>
  <span class="dw-nav-label">Public API Reference & Core Annotations</span>
</button>


<button class="dw-nav-item" data-target="section-mocking-and-fixture-definition" onclick="showSection('section-mocking-and-fixture-definition')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Mocking & Declarative Fixture Definition</span>
</button>


<button class="dw-nav-item" data-target="section-testing-strategy-and-quality" onclick="showSection('section-testing-strategy-and-quality')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Testing Strategy & Quality Gates</span>
</button>


<button class="dw-nav-item" data-target="section-build-release-and-publishing" onclick="showSection('section-build-release-and-publishing')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Build, Release & Publishing</span>
</button>


<button class="dw-nav-item" data-target="section-error-handling-logging-and-observability" onclick="showSection('section-error-handling-logging-and-observability')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Error Handling, Logging & Observability</span>
</button>


<button class="dw-nav-item" data-target="section-licensing-and-third-party-dependencies" onclick="showSection('section-licensing-and-third-party-dependencies')">
  <span class="dw-nav-dot dw-dot-green"></span>
  <span class="dw-nav-label">Licensing & Third-Party Dependencies</span>
</button>

    </div>
  </div>
</aside>

    <main class="dw-main">
      
<section id="section-project-overview" class="dw-section">
  <div class="dw-section-inner">
    <h1>Project Overview</h1>
<p>Fit4J (Functional Integration Testing for Java) is a Spring Boot testing library that standardizes and simplifies integration and fixture‑driven testing for JVM applications. It combines Spring Boot testing, fixtures, Testcontainers, and embedded infrastructure (Kafka, databases, Redis, etc.) into a coherent, annotation‑driven model.</p>
<p>This page explains what Fit4J is, why it exists, and how it helps you write concise, robust integration tests over HTTP, gRPC, Kafka, databases, and other external services.</p>
<hr />
<h2>What Fit4J Is</h2>
<p>Fit4J is:</p>
<ul>
<li>A <strong>test library</strong> for Spring‑based JVM applications (Kotlin and Java).</li>
<li>A <strong>Spring Boot test extension</strong> that builds on <code>@SpringBootTest</code> and JUnit 5.</li>
<li>A <strong>fixture engine</strong> driven by YAML files for data and environment setup.</li>
<li>A <strong>declarative integration testing layer</strong> over:</li>
<li>HTTP/REST and gRPC</li>
<li>Kafka (embedded and via Testcontainers)</li>
<li>Relational databases (MySQL, PostgreSQL, H2, etc.)</li>
<li>Redis and Elasticsearch via Testcontainers</li>
</ul>
<p>Core entry point: the <code>@FIT</code> annotation in<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/FIT.kt#L1-L20"><code>src/main/kotlin/org/fit4j/annotation/FIT.kt:1-20</code></a>.</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/annotation/FIT.kt:1-20
package org.fit4j.annotation

import org.fit4j.context.Fit4JTestExtension
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource
import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@IT
@TestPropertySource(properties = [&quot;fit4j.testClass.isFunctionalIntegrationTest=true&quot;])
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(Fit4JTestExtension::class)
annotation class FIT(
    val fixtureFilePath: String = &quot;&quot;,
    val webEnvironment: SpringBootTest.WebEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
</code></pre>
<p>An <code>@FIT</code> test is essentially a specialized <code>@SpringBootTest</code> with:</p>
<ul>
<li>A dedicated JUnit 5 extension: <code>Fit4JTestExtension</code> (activates Fit4J features).</li>
<li>A functional‑integration‑test flag via <code>fit4j.testClass.isFunctionalIntegrationTest=true</code>.</li>
<li>Configurable web environment (default: random port).</li>
<li>Fixture loading from a YAML file (default: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> on classpath).</li>
</ul>
<hr />
<h2>Why Fit4J Exists</h2>
<p>In most Spring Boot projects, integration tests are:</p>
<ul>
<li><strong>Boilerplate‑heavy</strong>: repeated configuration of <code>@SpringBootTest</code>, profiles, test data, and mock wiring.</li>
<li><strong>Infrastructure‑specific</strong>: each team rolls its own patterns for Kafka, databases, Redis, Testcontainers, etc.</li>
<li><strong>Fragile</strong>: manual lifecycle management of containers, embedded infrastructure, and database cleanup.</li>
</ul>
<p>Fit4J introduces a <strong>consistent, reusable pattern</strong>:</p>
<ul>
<li>One primary annotation (<code>@FIT</code>) to mark tests as functional integration tests.</li>
<li>Declarative configuration of Testcontainers and fixtures.</li>
<li>Standard patterns for Kafka, databases, HTTP/gRPC, Redis, Elasticsearch, etc.</li>
<li>A shared examples module so new teams can copy working recipes instead of reinventing test setups.</li>
</ul>
<p>The net effect: <strong>faster test authoring</strong>, <strong>less configuration drift</strong>, and <strong>better reproducibility</strong> across services.</p>
<hr />
<h2>High‑Level Architecture</h2>
<p>At a high level, Fit4J sits <strong>on top of</strong> Spring Boot Test and JUnit 5:</p>
<ul>
<li>JUnit 5 executes the test class.</li>
<li><code>@FIT</code> wires in <code>Fit4JTestExtension</code> to customize the Spring test context.</li>
<li>Fit4J:</li>
<li>Loads fixtures.</li>
<li>Configures Spring Boot test environment (web, profiles, overrides).</li>
<li>Optionally spins up containers (databases, Kafka, Redis, Elasticsearch) via Testcontainers.</li>
<li>Optionally configures embedded Kafka via Spring Kafka Test.</li>
</ul>
<p>Conceptually:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["JUnit 5 runs FIT test"] --> step2["@FIT and Fit4J extension"]
 step2 --> step3["Spring Boot test context"]
 step3 --> step4["Fixture loading and infra setup"]
</div></div>
<hr />
<h2>Core Concepts</h2>
<h3>1. @FIT – The Integration Test Entry Point</h3>
<p><code>@FIT</code> is the central annotation for Fit4J tests.</p>
<p>Example usage from<br />
<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt#L1-L18"><code>fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt:1-18</code></a>:</p>
<pre><code class="language-kotlin">// See fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt:1-18
package org.fit4j.examples.basic

import org.fit4j.annotation.FIT
import org.fit4j.helper.JsonHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired

@FIT
class SampleFIT {

    @Autowired
    private lateinit var helper: JsonHelper

    @Test
    fun `example test`() {
        Assertions.assertNotNull(helper)
    }
}
</code></pre>
<p>Key behavior (described in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>):</p>
<ul>
<li><code>@FIT</code> test classes are <strong><code>@SpringBootTest</code> classes with added capabilities</strong>.</li>
<li>Automatically:</li>
<li>Activates <code>test</code> profile in your service.</li>
<li>Enables Spring bean overriding (useful for mocks/stubs per test).</li>
<li>Parameters:</li>
<li><code>fixtureFilePath</code> – override default fixture YAML path.</li>
<li><code>webEnvironment</code> – override web mode (e.g. <code>MOCK</code>, <code>DEFINED_PORT</code>).</li>
</ul>
<p>Example showing fixture configuration from <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<pre><code class="language-kotlin">// See README.md (Create a Test Class example)
import org.fit4j.annotation.FIT
import org.fit4j.annotation.FixtureForFIT
import org.junit.jupiter.api.Test

@FIT
class SampleFIT {

    @Test
    fun `test something`() {
    }
}

@FIT(fixtureFilePath = &quot;classpath:custom-fixtures.yml&quot;)
class SampleFITWithMethodLevelFixtures {

    @Test
    @FixtureForFIT(&quot;fixture-group-1&quot;)
    fun `test with custom fixtures`() {
        // Uses fixtures from &quot;fixture-group-1&quot; in custom-fixtures.yml
    }
}
</code></pre>
<p>In most setups, <code>FixtureForFIT</code> drives which fixture group is applied before a given test method.</p>
<hr />
<h3>2. Fixtures – Declarative Test Setup</h3>
<p>Fit4J promotes <strong>fixture‑driven tests</strong>: instead of imperative setup code in each test method, you:</p>
<ul>
<li>Describe initial state, external responses, and expectations in YAML fixture files.</li>
<li>Bind specific fixture groups to tests using <code>@FixtureForFIT</code>.</li>
</ul>
<p>Defaults:</p>
<ul>
<li>Default fixture file: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> on the classpath.</li>
<li>Override via <code>@FIT(fixtureFilePath = "classpath:my-fixtures.yml")</code>.</li>
</ul>
<p>Typical uses:</p>
<ul>
<li>Seed database tables.</li>
<li>Seed or stub HTTP/gRPC responses for downstream services (using mocks in other modules).</li>
<li>Configure Kafka messages to be produced or expected.</li>
</ul>
<p>For detailed fixture format and semantics, see the <strong>Fixtures / Glossary</strong> section of the broader documentation.</p>
<hr />
<h3>3. Testcontainers Integration – Real Infrastructure in Tests</h3>
<p>Fit4J integrates deeply with <a href="https://www.testcontainers.org/">Testcontainers</a>, enabling tests to run against real databases, Kafka, Redis, Elasticsearch, etc., via <strong>declarative YAML</strong>, not manual container wiring.</p>
<h4>3.1 Basic Activation</h4>
<p>To enable Testcontainers for a Fit4J test, you:</p>
<ol>
<li>Add the JUnit 5 <code>@Testcontainers</code> annotation (from <code>org.testcontainers.junit.jupiter.Testcontainers</code>).</li>
<li>Add <code>@FIT</code> to make it a Fit4J test.</li>
</ol>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<pre><code class="language-kotlin">// See README.md (How to Work with TestContainers?)
import org.testcontainers.junit.jupiter.Testcontainers
import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Test

@Testcontainers
@FIT
class SampleFIT {

  @Test
  fun `test something`() {

  }
}
</code></pre>
<p>In more advanced cases, Fit4J provides its own <code>org.fit4j.testcontainers.Testcontainers</code> annotation
for declarative selection of container definitions (see examples below).</p>
<h4>3.2 Declarative Container Definitions</h4>
<p>You define container configurations in a YAML file, e.g. <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>
placed in <code>src/test/resources</code> of your service.</p>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<pre><code class="language-yaml"># See README.md (fit4j-test-containers.yml example)
- container: org.testcontainers.containers.MySQLContainer
  name: mySQLContainerDefinition
  image: mysql:5.7.33
  exposedPorts:
    - 3306
  username: root
  password: ********
  databaseName: v1
  initScript: scripts/v1_init.sql
  env:
    - TZ: &quot;America/Los_Angeles&quot;
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
</code></pre>
<p>Notes:</p>
<ul>
<li><code>password</code> is shown masked here; you must not commit real credentials.</li>
<li><code>initScript</code> points to an SQL script in your test resources.</li>
<li><code>env</code> and <code>urlParam</code> configure container environment variables and JDBC URL parameters.</li>
</ul>
<p>Fit4J uses a <code>TestContainersDefinitionProvider</code> to load these definitions:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainersDefinitionProviderFIT.kt:1-20
package org.fit4j.testcontainers

import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.ApplicationContext
import org.testcontainers.containers.MySQLContainer

@FIT
class TestContainersDefinitionProviderFIT  {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `it should load given sample testcontainers yaml file`() {
        val provider = TestContainersDefinitionProvider(
            applicationContext,
            &quot;classpath:fit4j-test-containers-sample.yml&quot;
        )
        val containers  = provider.getTestContainerDefinitions()
        Assertions.assertEquals(6, containers.size)
    }
}
</code></pre>
<p>This demonstrates how Fit4J turns YAML into <code>TestContainerDefinition</code> objects,
which in turn create and manage Testcontainers instances.</p>
<h4>3.3 Selective Registration and Inheritance</h4>
<p>Fit4J allows <strong>selective container registration</strong> via its own <code>@Testcontainers</code> annotation
in the <code>org.fit4j.testcontainers</code> package.</p>
<p>Example from<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/TestContainersWithSelectiveRegistrationFIT.kt#L1-L23"><code>src/test/kotlin/org/fit4j/testcontainers/TestContainersWithSelectiveRegistrationFIT.kt:1-23</code></a>:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainersWithSelectiveRegistrationFIT.kt:1-23
package org.fit4j.testcontainers

import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.ConfigurableApplicationContext
import org.springframework.context.event.EventListener
import org.springframework.test.context.event.AfterTestClassEvent

@FIT
@Testcontainers(definitions = [&quot;redisContainerDefinition&quot;])
class TestContainersWithSelectiveRegistrationFIT {
    @Autowired(required = false)
    private var testContainerDefinitions: List&lt;TestContainerDefinition&gt;? = null

    @TestConfiguration
    class TestConfig {
        @EventListener
        fun afterTestClass(event: AfterTestClassEvent) {
            // custom logic around test container lifecycle
        }
    }

    @Test
    fun `test something with redis`() {
        Assertions.assertNotNull(testContainerDefinitions)
    }
}
</code></pre>
<ul>
<li><code>definitions = ["redisContainerDefinition"]</code> selects <strong>only</strong> the specified container definition(s) from the YAML.</li>
<li>You can integrate with the Spring context lifecycle using <code>@EventListener</code> on <code>AfterTestClassEvent</code>.</li>
</ul>
<p>Another example with MySQL from<br />
<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-mysql/src/test/kotlin/org/fit4j/examples/mysql/MysqlExampleFIT.kt#L1-L24"><code>fit4j-examples/example-mysql/src/test/kotlin/org/fit4j/examples/mysql/MysqlExampleFIT.kt:1-24</code></a>:</p>
<pre><code class="language-kotlin">// See fit4j-examples/example-mysql/src/test/kotlin/org/fit4j/examples/mysql/MysqlExampleFIT.kt:1-24
package org.fit4j.examples.mysql

import org.fit4j.annotation.FIT
import org.fit4j.dbcleanup.DatabaseTestSupportForMysql
import org.fit4j.testcontainers.Testcontainers
import org.hamcrest.MatcherAssert
import org.hamcrest.Matchers
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.transaction.PlatformTransactionManager
import javax.sql.DataSource

@Testcontainers(definitions = [&quot;mySQLContainerDefinition&quot;])
@FIT
class MysqlExampleFIT {
    @Autowired
    private lateinit var jdbcTemplate: JdbcTemplate

    @TestConfiguration
    class TestConfig {
        // bean definitions for DatabaseTestSupportForMysql, etc.
    }

    @Test
    fun `data is accessible`() {
        MatcherAssert.assertThat(jdbcTemplate.queryForList(&quot;select 1&quot;).size, Matchers.greaterThan(0))
    }
}
</code></pre>
<p>This pattern is typical for <strong>real database integration tests</strong>:
Testcontainers spins up the DB, Fit4J wires a <code>JdbcTemplate</code> and DB cleanup support.</p>
<hr />
<h3>4. Database Test Support</h3>
<p>Fit4J provides helper classes for <strong>automatic database cleanup and preparation</strong>.</p>
<p>Examples:</p>
<ul>
<li><code>org.fit4j.dbcleanup.DatabaseTestSupport</code></li>
<li><code>org.fit4j.dbcleanup.DatabaseTestSupportForH2</code></li>
<li><code>org.fit4j.dbcleanup.DatabaseTestSupportForMysql</code></li>
<li><code>org.fit4j.dbcleanup.DatabaseTestSupportForPostgreSQL</code></li>
</ul>
<p>They are tested in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt#L1-L20"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt:1-20</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L1-L20"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:1-20</code></a></li>
</ul>
<p>These suites show how a typical test combines:</p>
<ul>
<li><code>@FIT</code></li>
<li>Testcontainers‑backed databases</li>
<li><code>JdbcTemplate</code> to query the DB</li>
</ul>
<p>By combining Testcontainers and DatabaseTestSupport, Fit4J simplifies a common pattern:</p>
<ol>
<li>Start a real DB container.</li>
<li>Apply schema and seed data (optionally via fixtures and init scripts).</li>
<li>Run tests.</li>
<li>Clean up or reset between tests in a predictable way.</li>
</ol>
<hr />
<h3>5. Kafka Support</h3>
<p>Fit4J supports Kafka testing in two ways:</p>
<ol>
<li><strong>Embedded Kafka</strong> via Spring Kafka Test.</li>
<li><strong>Kafka via Testcontainers</strong>.</li>
</ol>
<h4>5.1 Embedded Kafka</h4>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<pre><code class="language-kotlin">// See README.md (Embedded Kafka example)
import org.fit4j.kafka.EnableEmbeddedKafka
import org.fit4j.annotation.FIT

@EnableEmbeddedKafka
@FIT
class SampleFIT {
    // Your test code
}
</code></pre>
<p>Key points:</p>
<ul>
<li><code>@EnableEmbeddedKafka</code> is a Fit4J annotation that configures a Spring Kafka <strong>embedded broker</strong> for your FIT tests.</li>
<li>When using the raw <code>@EmbeddedKafka</code> from Spring Kafka Test, the Spring docs recommend <code>@DirtiesContext</code> to avoid race conditions on JVM shutdown. A sample from<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt#L1-L24"><code>src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-24</code></a>:</li>
</ul>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-24
package org.fit4j.sample

import org.fit4j.annotation.FIT
import org.fit4j.mock.MockServiceCallTracker
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.kafka.test.context.EmbeddedKafka
import org.springframework.test.annotation.DirtiesContext

@FIT
@EmbeddedKafka(partitions = 1)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class YetAnotherSampleFIT {

    @Autowired
    private lateinit var mockServiceCallTracker: MockServiceCallTracker

    @Test
    fun `test something`() {
        Assertions.assertNotNull(mockServiceCallTracker)
    }
}
</code></pre>
<p>Fit4J’s own <code>@EnableEmbeddedKafka</code> aims to standardize that pattern.</p>
<h4>5.2 Kafka via Testcontainers</h4>
<p>Fit4J also demonstrates Kafka through Testcontainers in the examples project:</p>
<ul>
<li><code>fit4j-examples/example-kafka-testcontainers/</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L12"><code>fit4j-examples/README.md:1-12</code></a>).</li>
</ul>
<p>The pattern is similar to the DB examples:</p>
<ul>
<li>Define a Kafka container in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>.</li>
<li>Annotate FIT tests with <code>@org.fit4j.testcontainers.Testcontainers(definitions = ["kafkaDefinition"])</code>.</li>
<li>Use Spring Kafka clients pointing at the dynamically provided host/port.</li>
</ul>
<p>For end‑to‑end details, see the <strong>External Integrations</strong> section of the documentation.</p>
<hr />
<h3>6. Redis &amp; Elasticsearch Support</h3>
<p>Fit4J test examples cover additional infrastructure:</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L12"><code>fit4j-examples/README.md:1-12</code></a>:</p>
<ul>
<li><code>example-redis/</code> – Redis tests using Testcontainers.</li>
<li><code>example-elasticsearch/</code> – Elasticsearch tests using Testcontainers.</li>
</ul>
<p>A Redis example from<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt#L1-L24"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt:1-24</code></a>:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt:1-24
package org.fit4j.testcontainers

import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.ConfigurableApplicationContext
import org.springframework.context.event.EventListener
import org.springframework.test.context.event.AfterTestClassEvent

@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;redisContainerDefinition&quot;])
@FIT
class RedisDataPopulatorFIT {
    @Value(&quot;\${fit4j.redisContainerDefinition.host}&quot;)
    private lateinit var redisHost: String

    @Value(&quot;\${fit4j.redisContainerDefinition.port}&quot;)
    private lateinit var redisPort: Integer

    @TestConfiguration
    class TestConfig {
        @EventListener
        fun afterTestClass(event: AfterTestClassEvent) {
            // Custom teardown logic
        }
    }

    @Test
    fun `redis properties are available`() {
        Assertions.assertNotNull(redisHost)
        Assertions.assertNotNull(redisPort)
    }
}
</code></pre>
<p>Note how container host/port are exposed as Spring properties:</p>
<ul>
<li><code>fit4j.redisContainerDefinition.host</code></li>
<li><code>fit4j.redisContainerDefinition.port</code></li>
</ul>
<p>The exact mapping between YAML definitions and Spring properties is handled by Fit4J’s Testcontainers integration.</p>
<hr />
<h3>7. HTTP and gRPC Testing</h3>
<p>Fit4J’s examples module demonstrates HTTP and gRPC usage:</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L12"><code>fit4j-examples/README.md:1-12</code></a>:</p>
<ul>
<li><code>example-rest/</code> – HTTP/REST FITs.</li>
<li><code>example-grpc/</code> – gRPC FITs.</li>
</ul>
<p>While code snippets are not included in the provided context, the high‑level pattern is:</p>
<ul>
<li><code>@FIT</code> test class with <code>webEnvironment = RANDOM_PORT</code> (default).</li>
<li>HTTP: use <code>TestRestTemplate</code>, WebTestClient, or RestAssured pointing at the test server port.</li>
<li>gRPC: use a test gRPC client pointing at the configured port (provided via fixtures or properties).</li>
</ul>
<p>Fixture files in these examples typically:</p>
<ul>
<li>Define requests and expected responses.</li>
<li>Stub external dependencies or define expected behavior for mocks.</li>
</ul>
<p>See the <strong>HTTP/REST</strong> and <strong>gRPC</strong> sections in the examples project for concrete code.</p>
<hr />
<h2>Getting Fit4J into Your Project</h2>
<h3>1. Add the Dependency</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<p><strong>Gradle (Kotlin DSL):</strong></p>
<pre><code class="language-kotlin">// See README.md (Add the Library Dependency)
dependencies {
    testImplementation(&quot;org.fit4j:fit4j:1.0.0-SNAPSHOT&quot;)
}
</code></pre>
<p><strong>Gradle (Groovy DSL):</strong></p>
<pre><code class="language-groovy">dependencies {
    testImplementation &quot;org.fit4j:fit4j:1.0.0-SNAPSHOT&quot;
}
</code></pre>
<p>If you need snapshots, configure the Sonatype snapshots repository.</p>
<p><strong>Gradle:</strong></p>
<pre><code class="language-kotlin">// See README.md (From Maven Central / snapshots)
repositories {
    mavenCentral()
    maven {
        url = uri(&quot;https://s01.oss.sonatype.org/content/repositories/snapshots/&quot;)
    }
}
</code></pre>
<p><strong>Maven:</strong></p>
<pre><code class="language-xml">&lt;!-- See README.md (Maven snapshots repo) --&gt;
&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;ossrh-snapshots&lt;/id&gt;
        &lt;url&gt;https://s01.oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h3>2. Local Development</h3>
<p>For local development of Fit4J itself, use:</p>
<pre><code class="language-bash"># See README.md (From Maven Local)
cd /path/to/fit4j
./gradlew publishToMavenLocal
</code></pre>
<p>Then depend on <code>org.fit4j:fit4j</code> in your service without extra repository config.</p>
<hr />
<h2>Typical Developer Workflow</h2>
<ol>
<li><strong>Add Fit4J dependency</strong> to your Spring Boot project (<code>testImplementation</code>).</li>
<li><strong>Write your first FIT test</strong>:</li>
</ol>
<p>```kotlin
   // src/test/kotlin/com/example/ExampleFIT.kt
   import org.fit4j.annotation.FIT
   import org.junit.jupiter.api.Test</p>
<p>@FIT
   class ExampleFIT {</p>
<pre><code>   @Test
   fun `service wiring is ok`() {
       // call HTTP, Kafka, DB, etc.
   }
</code></pre>
<p>}
   ```</p>
<ol>
<li><strong>Add fixtures</strong> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> (or a custom path via <code>fixtureFilePath</code>).</li>
<li><strong>Add Testcontainers configuration</strong> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> if you need real infrastructure.</li>
<li>
<p><strong>Use examples</strong> from <code>fit4j-examples/</code>:</p>
</li>
<li>
<p><code>example-rest/</code> for HTTP.</p>
</li>
<li><code>example-grpc/</code> for gRPC.</li>
<li><code>example-kafka/</code> and <code>example-kafka-testcontainers/</code> for Kafka.</li>
<li>
<p><code>example-mysql/</code>, <code>example-redis/</code>, <code>example-elasticsearch/</code> for databases and stores.</p>
</li>
<li>
<p><strong>Iterate</strong>: refine fixtures, add container definitions, and wire mocks or stubs as necessary.</p>
</li>
</ol>
<hr />
<h2>Configuration &amp; Properties Overview</h2>
<p>While detailed configuration is covered in the Configuration Guide, key properties that appear in the examples include:</p>
<ul>
<li>
<p><code>fit4j.testClass.isFunctionalIntegrationTest</code><br />
  Set by <code>@FIT</code> via <code>@TestPropertySource</code> in <a href="https://github.com/harezmi/fit4j/blob/main/FIT.kt"><code>FIT.kt</code></a>. Used by Fit4J to detect FIT tests.</p>
</li>
<li>
<p>Container‑derived properties, e.g. in <a href="https://github.com/harezmi/fit4j/blob/main/RedisDataPopulatorFIT.kt#L12-L18"><code>RedisDataPopulatorFIT.kt:12-18</code></a>:</p>
</li>
</ul>
<p>```kotlin
  @Value("\${fit4j.redisContainerDefinition.host}")
  private lateinit var redisHost: String</p>
<p>@Value("\${fit4j.redisContainerDefinition.port}")
  private lateinit var redisPort: Integer
  ```</p>
<p>These are dynamically injected from the Testcontainers configuration and runtime container metadata.</p>
<p>All credentials in configuration or YAML should be masked or provided via secure mechanisms (env vars, secret managers). The examples in this documentation use <code>********</code> placeholders.</p>
<hr />
<h2>Where to Go Next</h2>
<p>For readers who now understand the high‑level purpose and architecture of Fit4J, the next recommended sections are:</p>
<ul>
<li><strong>Fixtures &amp; Data Model</strong> – for the YAML structure and fixture semantics.</li>
<li><strong>External Integrations &amp; Data Flow</strong> – for detailed Kafka, HTTP, gRPC, Redis, and Elasticsearch flows.</li>
<li><strong>Core Architecture</strong> – for how <code>Fit4JTestExtension</code>, Testcontainers integration, and DB helpers are implemented.</li>
<li><strong>Examples Project Guide</strong> – for step‑by‑step walkthroughs of each example under <code>fit4j-examples/</code>.</li>
</ul>
  </div>
</section>


<section id="section-business-domain" class="dw-section">
  <div class="dw-section-inner">
    <h1>Business Domain &amp; Problem Space</h1>
<p>This project (Fit4J) operates in the domain of <strong>functional integration testing</strong> for Spring Boot–based, distributed systems. It focuses on making integration/system tests realistic and repeatable by orchestrating real infrastructure (databases, Kafka, Redis, Elasticsearch, DynamoDB) and deterministic mocks for external dependencies (REST, gRPC, other microservices).</p>
<p>This page explains <strong>what problem space Fit4J targets</strong>, <strong>why these problems exist in modern microservice architectures</strong>, and <strong>how the core concepts (FIT, @IT, embedded infra, Testcontainers, mocking) map to that domain</strong>. For details on specific APIs or annotations, see their dedicated sections.</p>
<hr />
<h2>1. Testing Domain: Functional Integration Tests (FITs)</h2>
<h3>1.1 What is a Functional Integration Test?</h3>
<p>The README defines a specific subtype of integration tests, called <strong>Functional Integration Tests (FITs)</strong>:</p>
<ul>
<li>Entry points:</li>
<li>gRPC controllers</li>
<li>HTTP/REST controllers</li>
<li>Kafka consumers / message listeners<br />
  (See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L1-L60"><code>README.md:1-60</code></a> for conceptual overview.)</li>
<li>Scope:</li>
<li>Test end-to-end functionality of a <strong>single service</strong>, including:<ul>
<li>Request handling (REST/gRPC/Kafka)</li>
<li>Business logic layers</li>
<li>Persistence (MySQL/H2/DynamoDB)</li>
<li>Caching (Redis)</li>
<li>Search (Elasticsearch)</li>
<li>Messaging (Kafka)</li>
</ul>
</li>
<li>Include <strong>side effects</strong> (DB changes, cache updates, Kafka events, etc.).</li>
<li>Environment:</li>
<li>Bootstraps the <strong>entire Spring ApplicationContext</strong> (no slicing).</li>
<li>Uses <strong>real infrastructure</strong> where possible (Testcontainers or embedded servers).</li>
<li>Only <strong>external systems outside the service boundary</strong> are mocked.</li>
</ul>
<p>The key idea is summarized in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L120-L160"><code>README.md:120-160</code></a>:</p>
<blockquote>
<p>"not every IT is a FIT, but every FIT is also an IT"</p>
</blockquote>
<p>So a FIT:
- Is a full integration test (IT) plus:
  - Business-meaningful scenarios
  - Well-defined Arrange / Act / Assert with real infra
  - Deterministic external boundary mocking</p>
<h3>1.2 Difference from “Normal” Integration Tests</h3>
<p>Traditional integration tests in Spring Boot often:</p>
<ul>
<li>Use sliced contexts (<code>@WebMvcTest</code>, <code>@DataJpaTest</code>) to limit scope.</li>
<li>Heavily mock out dependencies using libraries like Mockito.</li>
<li>Focus on <strong>technical integration</strong> of a layer (e.g., controller ↔ service).</li>
</ul>
<p>Fit4J’s FITs, as described in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L160-L220"><code>README.md:160-220</code></a>, differ by:</p>
<ul>
<li>Bootstrapping the <strong>full application</strong> (no slicing).</li>
<li>Avoiding mocks <strong>inside</strong> the service boundary.</li>
<li>Only mocking <strong>external boundaries</strong>:</li>
<li>REST/gRPC endpoints of other internal microservices.</li>
<li>Third‑party external systems.</li>
</ul>
<p>This shifts the test focus from “does this controller call this service?” to:
- “Given this external behavior, does the service fulfill its acceptance criteria as a whole?”</p>
<hr />
<h2>2. Problem Space in Distributed Systems Testing</h2>
<h3>2.1 Core Problems</h3>
<p>Fit4J addresses several pain points often seen in microservice test suites:</p>
<ol>
<li><strong>Fragile mocks and incomplete coverage</strong></li>
<li>
<p>Extensive mocking inside the service makes tests:</p>
<ul>
<li>Brittle to refactoring.</li>
<li>Blind to wiring/config issues.</li>
<li>Ignorant of serialization, validation, security, and Spring configuration problems.</li>
</ul>
</li>
<li>
<p><strong>Difficult infrastructure setup</strong></p>
</li>
<li>Running tests with real databases, Kafka, Redis, Elasticsearch, and DynamoDB is:<ul>
<li>Operationally heavy.</li>
<li>Hard to automate on developer laptops and CI.</li>
</ul>
</li>
<li>
<p>As a result, teams often compromise with H2-only DB tests or partial setups.</p>
</li>
<li>
<p><strong>Non-deterministic external dependencies</strong></p>
</li>
<li>External services (internal microservices or third parties) may:<ul>
<li>Be unavailable in dev/CI.</li>
<li>Return unstable or slow responses.</li>
</ul>
</li>
<li>
<p>Directly hitting them in tests causes flakiness and coupling to external systems.</p>
</li>
<li>
<p><strong>Lack of observability around messaging</strong></p>
</li>
<li>
<p>Verifying Kafka-based flows is painful:</p>
<ul>
<li>Hard to see what was produced/consumed.</li>
<li>Hard to correlate test actions with message activity.</li>
</ul>
</li>
<li>
<p><strong>Configuration complexity</strong></p>
</li>
<li>Each test suite needs boilerplate to:<ul>
<li>Start containers.</li>
<li>Configure ports.</li>
<li>Wire beans (e.g., embedded Redis, embedded DynamoDB).</li>
<li>Override Spring properties correctly.</li>
</ul>
</li>
</ol>
<h3>2.2 Fit4J’s Design Response</h3>
<p>The library’s features listed in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L220-L320"><code>README.md:220-320</code></a> target these problems:</p>
<ul>
<li>Declarative &amp; programmatic <strong>request‑response training</strong> for:</li>
<li>gRPC endpoints.</li>
<li>HTTP/REST endpoints.</li>
<li>Declarative Kafka consumer definitions to <strong>assert messages</strong> within test methods.</li>
<li>Declarative <strong>Testcontainers</strong> support for:</li>
<li>MySQL, DynamoDB, Kafka, Redis, Elasticsearch, S3 (via Localstack).</li>
<li><strong>Embedded</strong> alternatives when containers are not desired:</li>
<li>Embedded DynamoDB (<code>@EmbeddedDynamoDB</code>).</li>
<li>Embedded Redis (<code>@EmbeddedRedis</code>).</li>
<li>Embedded Kafka (via Spring Kafka Test).</li>
<li>Automatic <strong>tracing of Kafka messages</strong> published/consumed by the service.</li>
</ul>
<p>Together, these allow FITs to be:</p>
<ul>
<li><strong>Deterministic</strong> (mocked external boundaries).</li>
<li><strong>Realistic</strong> (real infra inside service boundary).</li>
<li><strong>Repeatable</strong> across local/dev/CI environments.</li>
</ul>
<hr />
<h2>3. External Dependency Mocking &amp; Request-Response Training</h2>
<h3>3.1 External Boundaries</h3>
<p>In this domain, <strong>external dependencies</strong> are:</p>
<ul>
<li>Other internal microservices:</li>
<li>Synchronous: REST/gRPC calls.</li>
<li>Asynchronous: Kafka topics.</li>
<li>Third-party external systems:</li>
<li>Payment providers, identity systems, external APIs.</li>
</ul>
<p>Fit4J’s model:<br />
The service under test remains intact; <strong>only external boundaries are mocked</strong>.</p>
<h3>3.2 Request-Response Trainings</h3>
<p>Fit4J provides <strong>declarative &amp; programmatic training</strong> to define mock interactions, as noted in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L310"><code>README.md:260-310</code></a>:</p>
<ul>
<li>For gRPC calls:</li>
<li>Configure training so that when service under test calls an external gRPC method with certain request, the mock server returns a predefined response.</li>
<li>For REST calls:</li>
<li>Similar pattern using a mock HTTP server or embedded wiring.</li>
</ul>
<p>At the domain level, this means:</p>
<ul>
<li>For each test scenario (FIT):</li>
<li>You define <strong>how external systems behave</strong> (their responses).</li>
<li>You then verify how your service reacts (state changes, side effects, produced messages).</li>
</ul>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L330-L400"><code>README.md:330-400</code></a> for how request-response training fits into test flow; and <code>fit4j-examples/example-grpc</code> and <code>fit4j-examples/example-rest</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L40"><code>fit4j-examples/README.md:1-40</code></a>) for concrete usage.</p>
<h3>3.3 Synchronous vs Asynchronous Boundaries</h3>
<p><strong>Synchronous</strong> (REST/gRPC):</p>
<ul>
<li>FITs use training to simulate:</li>
<li>Success responses.</li>
<li>Error responses.</li>
<li>Edge cases (timeouts, specific payloads, etc.).</li>
</ul>
<p><strong>Asynchronous</strong> (Kafka):</p>
<ul>
<li>FITs verify:</li>
<li>Messages produced by the service.</li>
<li>Possibly messages consumed by the service, depending on scenario.</li>
<li>Fit4J offers:</li>
<li>Embedded Kafka broker (via Spring Kafka Test).</li>
<li>Kafka Testcontainers configuration.</li>
<li>Automatic tracing of Kafka events (see <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L320"><code>README.md:260-320</code></a>).</li>
</ul>
<hr />
<h2>4. Embedded Infrastructure &amp; Testcontainers</h2>
<p>The business domain assumes modern microservices rely on multiple infrastructure components. Fit4J treats these as part of the <strong>testable system</strong>.</p>
<h3>4.1 Infrastructure Types</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L220-L320"><code>README.md:220-320</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L80"><code>fit4j-examples/README.md:1-80</code></a>, supported infra includes:</p>
<ul>
<li>Relational DB:</li>
<li>MySQL via Testcontainers.</li>
<li>H2 in-memory (“H2 Embedded Database”).</li>
<li>NoSQL:</li>
<li>DynamoDB via Testcontainers.</li>
<li>DynamoDB Embedded (<code>@EmbeddedDynamoDB</code>).</li>
<li>Caching:</li>
<li>Redis via Testcontainers.</li>
<li>Redis Embedded (<code>@EmbeddedRedis</code>).</li>
<li>Search:</li>
<li>Elasticsearch via Testcontainers.</li>
<li>Messaging:</li>
<li>Kafka via:<ul>
<li>Embedded Kafka (Spring Kafka Test).</li>
<li>Kafka Testcontainers.</li>
</ul>
</li>
<li>Object Storage:</li>
<li>S3 via Localstack Testcontainers.</li>
</ul>
<p>Example references:</p>
<ul>
<li>Testcontainers sample configuration: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L80"><code>src/test/resources/fit4j-test-containers-sample.yml:1-80</code></a></li>
<li>Embedded DynamoDB examples:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L1-L80"><code>fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:1-80</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/dynamodb/EmbeddedDynamoDBFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/dynamodb/EmbeddedDynamoDBFIT.kt:1-40</code></a></li>
</ul>
<h3>4.2 Declarative Testcontainers</h3>
<p>Fit4J enables a <strong>declarative configuration</strong> for Testcontainers, as described around <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L320-L380"><code>README.md:320-380</code></a>:</p>
<ul>
<li>YAML-driven container definitions (see <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L80"><code>src/test/resources/fit4j-test-containers-sample.yml:1-80</code></a>).</li>
<li>Properties you can expose from containers to Spring context, such as:</li>
<li><code>jdbcUrl</code>, <code>username</code>, <code>password</code> for MySQL.</li>
<li><code>host</code>/<code>port</code> for Redis.</li>
<li>Support for environment variables and URL parameters.</li>
</ul>
<p>Conceptually, this allows tests to say “this is the infra I depend on” without custom bootstrap boilerplate.</p>
<h4>Example (MySQL &amp; Redis containers)</h4>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L60"><code>src/test/resources/fit4j-test-containers-sample.yml:1-60</code></a>:</p>
<pre><code class="language-yaml">- container: org.testcontainers.containers.MySQLContainer
  name: mysql_db
  image: mysql:8.0
  env:
    - TZ: America/Los_Angeles
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
    - useLegacyDatetimeCode: &quot;false&quot;
  exposedProperties:
    - jdbcUrl
    - username
    - password
- container: org.testcontainers.containers.GenericContainer
  name: redis
  image: redis:6.2.1
  exposedPorts:
    - 6379
  exposedProperties:
    - host
</code></pre>
<p>Note: any <strong>real credentials</strong> should be masked in actual configs (e.g., <code>password: ********</code>).</p>
<h3>4.3 Embedded Alternatives</h3>
<p>For faster or lighter-weight setups:</p>
<ul>
<li><strong>Embedded DynamoDB</strong></li>
<li>Enable with <code>@EmbeddedDynamoDB</code> on test class (<a href="https://github.com/harezmi/fit4j/blob/main/README.md#L400-L460"><code>README.md:400-460</code></a>).</li>
<li>Library will:<ul>
<li>Start an embedded DynamoDB instance.</li>
<li>Override AWS DynamoDB client beans with embedded clients.</li>
</ul>
</li>
<li>
<p>Example: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/dynamodb/EmbeddedDynamoDBFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/dynamodb/EmbeddedDynamoDBFIT.kt:1-40</code></a>.</p>
</li>
<li>
<p><strong>Embedded Redis</strong></p>
</li>
<li>Enable with <code>@EmbeddedRedis</code> (referenced in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L320-L380"><code>README.md:320-380</code></a>).</li>
<li>
<p>Provides an embedded Redis server with configurable port as a Spring bean/property.</p>
</li>
<li>
<p><strong>Embedded Kafka</strong></p>
</li>
<li>Via Spring Kafka Test’s Embedded Kafka broker.</li>
<li>Exposed as a bean and bootstrap property when <code>@EnableEmbeddedKafka</code> is used (<a href="https://github.com/harezmi/fit4j/blob/main/README.md#L320-L380"><code>README.md:320-380</code></a>).</li>
</ul>
<p>These fit scenarios where developers want <strong>deterministic infra without Docker/Testcontainers</strong> (e.g., running tests on constrained CI agents or development laptops).</p>
<hr />
<h2>5. Deterministic Fixtures &amp; Repeatable Environments</h2>
<h3>5.1 Arrange–Act–Assert in FITs</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L380-L430"><code>README.md:380-430</code></a>, the project encourages a classic <strong>Arrange–Act–Assert</strong> pattern applied to distributed systems:</p>
<ul>
<li><strong>Arrange</strong></li>
<li>Start infra (via <code>@FIT</code>/<code>@IT</code>, Testcontainers, embedded services).</li>
<li>Define request-response trainings for external services.</li>
<li>Populate initial data:<ul>
<li>MySQL DB fixtures.</li>
<li>Redis cache entries.</li>
<li>Elasticsearch indices.</li>
<li>DynamoDB tables.</li>
</ul>
</li>
<li>
<p>Example: fixture population policies are described in sections referenced by <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L320"><code>README.md:260-320</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L80"><code>fit4j-examples/README.md:1-80</code></a>.</p>
</li>
<li>
<p><strong>Act</strong></p>
</li>
<li>
<p>Trigger the service:</p>
<ul>
<li>Send HTTP request.</li>
<li>Send gRPC request.</li>
<li>Publish Kafka message.</li>
</ul>
</li>
<li>
<p><strong>Assert</strong></p>
</li>
<li>Validate outcomes:<ul>
<li>HTTP/gRPC responses.</li>
<li>Database state.</li>
<li>Redis cache state.</li>
<li>Elasticsearch documents.</li>
<li>Kafka messages published/consumed.</li>
</ul>
</li>
</ul>
<p>The goal is <strong>repeatability</strong>: given the same trainings and fixture data, tests should always behave identically.</p>
<h3>5.2 Initial Data Population</h3>
<p>The README (and example modules) describe <strong>initial data population</strong> for several infra components:</p>
<ul>
<li>For MySQL Testcontainers:</li>
<li>Scripts or data files pre-load schemas and data.</li>
<li>For Redis:</li>
<li>Seed key/value pairs as test fixtures.</li>
<li>For Elasticsearch:</li>
<li>Pre-create indices and documents.</li>
</ul>
<p>These patterns are showcased in:</p>
<ul>
<li><code>fit4j-examples/example-mysql</code> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L60-L80"><code>fit4j-examples/README.md:60-80</code></a>).</li>
<li><code>fit4j-examples/example-redis</code> and <code>example-redis-embedded</code>.</li>
<li><code>fit4j-examples/example-elasticsearch</code>.</li>
</ul>
<p>Exact loading mechanisms are detailed in their respective example modules. At a domain level, this is about:</p>
<ul>
<li>Treating infra as <strong>testable state</strong>.</li>
<li>Ensuring each FIT defines <strong>exact starting conditions</strong>.</li>
</ul>
<hr />
<h2>6. Annotations @IT and @FIT in the Domain</h2>
<h3>6.1 @IT – Integration Test Environment</h3>
<p>The <code>@IT</code> annotation is described in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L430-L500"><code>README.md:430-500</code></a> as a base for ordinary integration tests:</p>
<p>Using <code>@IT</code>:</p>
<ul>
<li>Activates <code>test</code> Spring profile.</li>
<li>Enables bean definition override.</li>
<li>Sets up infra-related features:</li>
<li>Runs gRPC server in in-process mode (random name to avoid collisions).</li>
<li>Exposes embedded Kafka broker bean and bootstrap property if <code>@EnableEmbeddedKafka</code> is present.</li>
<li>Exposes embedded Redis bean and port if <code>@EmbeddedRedis</code> is present.</li>
<li>Enables declarative Testcontainers if <code>@Testcontainers</code> is present.</li>
<li>Exposes embedded DynamoDB bean if <code>@EmbeddedDynamoDB</code> is present.</li>
</ul>
<p>Domain-wise, <code>@IT</code> is used for:</p>
<ul>
<li>Verifying interactions between layers (e.g., controller ↔ service ↔ repository).</li>
<li>Ensuring infrastructure wiring is correct.</li>
<li>Without the extended FIT features like request-response training.</li>
</ul>
<h3>6.2 @FIT – Full Functional Integration Test</h3>
<p>The <code>@FIT</code> annotation, referenced throughout <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> and used in examples like:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L1-L40"><code>fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:1-40</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/dynamodb/EmbeddedDynamoDBFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/dynamodb/EmbeddedDynamoDBFIT.kt:1-40</code></a></li>
</ul>
<p>builds on <code>@IT</code> and adds:</p>
<ul>
<li>Programmatic and declarative request-response training for external services.</li>
<li>Message tracking for synchronous calls and asynchronous Kafka flows.</li>
<li>Additional infra conveniences (e.g., auto-configuration for external mocks).</li>
</ul>
<p>In the <strong>business domain</strong> of this library:</p>
<ul>
<li><code>@IT</code> = base integration environment (real infra, minimal mocks).</li>
<li><code>@FIT</code> = <code>@IT</code> + external boundary mocking + tracking, targeted at <strong>end-to-end business scenarios</strong>.</li>
</ul>
<hr />
<h2>7. Example Domain Scenario: End-to-End Flow</h2>
<p>To illustrate the problem space, consider a hypothetical FIT scenario where:</p>
<ul>
<li>Service under test:</li>
<li>Receives a REST request.</li>
<li>Calls an external gRPC service.</li>
<li>Persists data to MySQL.</li>
<li>Caches data in Redis.</li>
<li>Publishes a Kafka event.</li>
</ul>
<p>Using Fit4J, the testing domain would define:</p>
<ul>
<li>Test annotation:</li>
<li><code>@FIT</code> to enable full FIT environment.</li>
<li>Infra:</li>
<li>MySQL via Testcontainers (configured in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers-sample.yml"><code>fit4j-test-containers-sample.yml</code></a>).</li>
<li>Redis via Embedded Redis.</li>
<li>Kafka via Embedded Kafka.</li>
<li>External boundary:</li>
<li>gRPC call to another microservice:<ul>
<li>Defined via request-response training.</li>
</ul>
</li>
<li>Assertions:</li>
<li>HTTP response content/status.</li>
<li>Database row content.</li>
<li>Redis key/value.</li>
<li>Kafka event payload published.</li>
</ul>
<p>A test class might conceptually look like:</p>
<pre><code class="language-kotlin">// See fit4j-examples/example-rest/src/test/... for similar patterns
@FIT
class OrderCreationFIT {

    @Test
    fun `should create order and publish event`() {
        // Arrange: external gRPC training, DB fixture, Redis seed
        // Act: send REST request to /orders
        // Assert: response + DB + Redis + Kafka
    }
}
</code></pre>
<p>Line references for such patterns can be seen in real examples under:
- <code>fit4j-examples/example-rest</code>: request/response FITs.
- <code>fit4j-examples/example-kafka</code> and <code>example-kafka-testcontainers</code>: Kafka FITs.</p>
<hr />
<h2>8. High-Level Flow of a FIT (Visualization)</h2>
<p>The following diagram captures the <strong>high-level flow</strong> of a typical Fit4J functional integration test in this domain:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Start FIT test"] --> step2["Arrange infra and mocks"]
 step2 --> step3["Send request or message"]
 step3 --> step4["Service uses infra and externals"]
 step4 --> step5["Capture responses and side effects"]
 step5 --> step6["Assert state and messages"]
</div></div>
<ul>
<li><strong>Arrange infra and mocks</strong>:</li>
<li><code>@FIT</code>/<code>@IT</code> set up Spring context and infra (DB, Kafka, Redis, etc.).</li>
<li>Request-response trainings define external system behavior.</li>
<li><strong>Send request or message</strong>:</li>
<li>REST, gRPC, or Kafka-based entry point.</li>
<li><strong>Service uses infra and externals</strong>:</li>
<li>Service performs normal business logic.</li>
<li><strong>Capture &amp; Assert</strong>:</li>
<li>Fit4J provides tracing and helpers to assert results and side effects.</li>
</ul>
<hr />
<h2>9. Configuration &amp; Environment Considerations</h2>
<p>While the main focus here is business domain, a few configuration aspects are important conceptually:</p>
<ul>
<li><strong>Spring profile</strong></li>
<li><code>@IT</code> activates <code>test</code> profile (<a href="https://github.com/harezmi/fit4j/blob/main/README.md#L430-L470"><code>README.md:430-470</code></a>).</li>
<li>This isolates test-specific configuration from production.</li>
<li><strong>Embedded vs Containerized infra</strong></li>
<li>Choice depends on:<ul>
<li>Developer machine capabilities.</li>
<li>CI environment.</li>
<li>Need for production-like behavior (e.g., full MySQL vs H2).</li>
</ul>
</li>
<li><strong>Property exposure</strong></li>
<li>Testcontainers YAML (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L80"><code>src/test/resources/fit4j-test-containers-sample.yml:1-80</code></a>) exposes properties such as:<ul>
<li><code>jdbcUrl</code></li>
<li><code>username</code></li>
<li><code>password</code> (should be treated as <code>********</code> in real configs)</li>
</ul>
</li>
<li>These are wired into Spring <a href="https://github.com/harezmi/fit4j/blob/main/application-test.yml"><code>application-test.yml</code></a> or equivalent.</li>
</ul>
<p>For detailed configuration options and property mappings, see the <strong>Configuration Guide</strong> section of the project documentation.</p>
<hr />
<h2>10. How to Approach this Domain as a New Engineer</h2>
<p>When you are new to this repository and need to understand or extend tests:</p>
<ol>
<li><strong>Identify the test type</strong></li>
<li><code>@IT</code> vs <code>@FIT</code> on test classes.</li>
<li><strong>Determine the entry point</strong></li>
<li>REST, gRPC, or Kafka.</li>
<li><strong>Locate infra configuration</strong></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers-sample.yml"><code>fit4j-test-containers-sample.yml</code></a> for Testcontainers.</li>
<li>Look for <code>@EmbeddedRedis</code>, <code>@EmbeddedDynamoDB</code>, <code>@EnableEmbeddedKafka</code>.</li>
<li><strong>Inspect external boundary trainings</strong></li>
<li>How REST/gRPC dependencies are mocked.</li>
<li><strong>Track side effects</strong></li>
<li>DB, Redis, Kafka, Elasticsearch as observed in assertions.</li>
</ol>
<p>Understanding these aspects will allow you to reason about the <strong>business domain of each FIT</strong>: what scenario it covers, what external system behavior is assumed, and how the service is expected to react.</p>
  </div>
</section>


<section id="section-glossary-and-domain-terms" class="dw-section">
  <div class="dw-section-inner">
    <h1>Glossary &amp; Domain Terms</h1>
<p>This page defines the core terminology and project-specific concepts used across the FIT4J library and example tests. It is meant as a quick reference for experienced engineers who are new to this repository and need to understand how tests, fixtures, and infrastructure pieces fit together.</p>
<p>Use this glossary whenever you encounter an unfamiliar annotation, configuration property, or testing pattern in the codebase or in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>.</p>
<hr />
<h2>High‑Level Categories</h2>
<ul>
<li><strong>Test Types &amp; Annotations</strong> – FIT vs IT, and related annotations</li>
<li><strong>Fixtures &amp; Data</strong> – declarative vs programmatic fixtures, fixture groups</li>
<li><strong>Mocking &amp; Responses</strong> – mock response factory, response generation</li>
<li><strong>Infrastructure &amp; Containers</strong> – Testcontainers, Kafka, databases</li>
<li><strong>Configuration &amp; Scope</strong> – profiles, test scope, properties</li>
</ul>
<hr />
<h2>Core Term Table</h2>
<table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FIT</strong> (Functional Integration Test)</td>
<td>A high-level integration test style where the full service (Spring Boot application) is started with real infrastructure (DB, Kafka, Redis, etc.) and only external boundaries (other microservices, 3rd party systems) are mocked. Enabled via <code>@FIT</code> annotation which extends <code>@SpringBootTest</code> and activates the full FIT4J environment including fixture-based request/response training and call tracking. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt#L1-L20"><code>src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt:1-20</code></a>.</td>
</tr>
<tr>
<td><strong>IT</strong> (Integration Test)</td>
<td>A regular integration test style supported by FIT4J via <code>@IT</code> annotation. It wires basic test infrastructure (e.g., in-process gRPC server, declarative Testcontainers support) without the full FIT capabilities. Used when you need “plain” integration tests without fixture-driven request/response training. See explanation in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L220-L240"><code>README.md:220-240</code></a>.</td>
</tr>
<tr>
<td><strong>@FIT annotation</strong></td>
<td>Custom annotation marking a test class as a Functional Integration Test. It is effectively a specialized <code>@SpringBootTest</code> that: (1) activates the <code>test</code> Spring profile, (2) enables bean overriding in the container, (3) turns on FIT infrastructure like programmatic &amp; declarative fixtures, sync call and async message tracking. Supports optional parameters <code>fixtureFilePath</code> and <code>webEnvironment</code>. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L285"><code>README.md:260-285</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/DeclarativeTestFixtureDataProviderFIT.kt#L15-L20"><code>DeclarativeTestFixtureDataProviderFIT.kt:15-20</code></a>.</td>
</tr>
<tr>
<td><strong>@IT annotation</strong></td>
<td>Base annotation for integration tests in this library. Enables multiple configuration properties and beans useful for ordinary integration tests, such as in-process gRPC, declarative Testcontainers support, and other infra beans. <code>@FIT</code> builds on top of <code>@IT</code>. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L300-L330"><code>README.md:300-330</code></a>.</td>
</tr>
<tr>
<td><strong>Functional Integration Test</strong></td>
<td>The testing approach behind FIT: you run the service almost exactly like in production (real DB, broker, Redis, etc.), but replace outbound edges (HTTP/gRPC/Kafka calls to other systems) with deterministic mocks whose behavior is driven by fixtures. Business behavior is verified end-to-end, including database state and emitted messages. Summarized in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L330-L355"><code>README.md:330-355</code></a>.</td>
</tr>
<tr>
<td><strong>Fixture</strong> / <strong>Test Fixture</strong></td>
<td>Any predefined test data and mock setup used to drive a test scenario. In FIT4J, fixtures mainly refer to request/response bindings for mocked external interactions (HTTP, gRPC, Kafka), defined either programmatically or declaratively. They are used in the <strong>Arrange</strong> phase of tests to prepare deterministic behavior. See the fixture file examples in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L40"><code>src/test/resources/fit4j-fixtures.yml:1-40</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures-sample.yml#L1-L40"><code>fit4j-fixtures-sample.yml:1-40</code></a>.</td>
</tr>
<tr>
<td><strong>Declarative Fixture</strong></td>
<td>A fixture defined in YAML (or similar config) instead of in code. FIT4J reads these once, builds test fixture definitions, and serves them to all tests. Declarative fixtures describe: protocol (<code>http</code>/<code>grpc</code>), path/type, optional predicates on the request, and the response(s). Recommended due to faster test execution and shared ApplicationContext. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L60"><code>src/test/resources/fit4j-fixtures.yml:1-60</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L360-L390"><code>README.md:360-390</code></a>.</td>
</tr>
<tr>
<td><strong>Programmatic Fixture</strong></td>
<td>A fixture defined in Kotlin/Java using Spring <code>@TestConfiguration</code> and beans instead of YAML. You use builder classes to register request/response mappings in code. Functionally equivalent to declarative fixtures but created per-test-class in the ApplicationContext. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L390-L430"><code>README.md:390-430</code></a> for discussion of tradeoffs.</td>
</tr>
<tr>
<td><strong>Declarative fixture-driven response generation mode</strong></td>
<td>A runtime mode controlled by the property <code>fit4j.declarativeTestFixtureDrivenResponseGeneration.enabled</code>. When set to <code>true</code>, only declarative fixtures (YAML-based) are honored; programmatic fixture builders are ignored. This is useful to enforce a single source of truth for mock behavior and avoid ambiguity between declarative and programmatic definitions. See config snippet in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L430-L450"><code>README.md:430-450</code></a>.</td>
</tr>
<tr>
<td><strong>Fixture File / <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a></strong></td>
<td>The main YAML file containing declarative test fixtures. By default FIT4J looks for <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> on the classpath, but you can override the path via <code>@FIT(fixtureFilePath = "...")</code>. The file is structured under a top-level <code>tests</code> array with per-test <strong>fixture groups</strong>. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L80"><code>src/test/resources/fit4j-fixtures.yml:1-80</code></a>.</td>
</tr>
<tr>
<td><strong><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures-sample.yml"><code>fit4j-fixtures-sample.yml</code></a></strong></td>
<td>Example YAML fixture file demonstrating fixture syntax: <code>protocol</code>, <code>path</code>/<code>type</code>, predicates, multiple responses, and shared <code>common_fixtures</code>. Used only as documentation/example, not as core runtime config. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L1-L80"><code>src/test/resources/fit4j-fixtures-sample.yml:1-80</code></a>.</td>
</tr>
<tr>
<td><strong>Fixture Group / Test Fixture Group</strong></td>
<td>A named collection of fixtures within a fixture file that is associated with one or more test methods/classes. In YAML, each entry under <code>tests</code> has a <code>name</code> and a <code>fixtures</code> list. FIT4J resolves which group to use for a test based on explicit annotations, the test method name, class name, or <code>"*"</code> wildcard. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml#L1-L40"><code>fit4j-fixtures.yml:1-40</code></a>.</td>
</tr>
<tr>
<td><strong>Wildcard Fixture Group <code>name: "*"</code></strong></td>
<td>A default fixture group used when no specific group is matched for a test (no <code>@FixtureForFIT</code>, no matching group name). It typically contains general-purpose fixtures shared across tests. Example in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L12"><code>src/test/resources/fit4j-fixtures.yml:1-12</code></a>.</td>
</tr>
<tr>
<td><strong><code>@FixtureForFIT</code> annotation</strong></td>
<td>Annotation used on a test method to explicitly bind it to a particular fixture group name from the YAML fixture file. If absent, FIT4J first tries to match by test method name, then by <code>"*"</code> group, then falls back to test class name matching. See usage in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L10-L25"><code>src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:10-25</code></a>.</td>
</tr>
<tr>
<td><strong>Test Fixture Variables (<code>@testFixtureData.variables</code>)</strong></td>
<td>A Spring-managed bean providing per-test dynamic variables that can be referenced from declarative fixtures via SpEL, e.g. <code>#{@testFixtureData.variables.fooId}</code>. They allow dynamic generation of response fields while keeping fixtures declarative. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L40-L60"><code>src/test/resources/fit4j-fixtures.yml:40-60</code></a>.</td>
</tr>
<tr>
<td><strong>Custom Fixture Beans (<code>@testFixtureCreator</code>)</strong></td>
<td>Arbitrary Spring beans, often defined in an inner <code>@TestConfiguration</code> class, referenced from fixture YAML via SpEL to construct responses (e.g. <code>#{@testFixtureCreator.EXAMPLE_RESPONSE}</code>). This lets you centralize complex response payload building while still writing declarative fixtures. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L450-L485"><code>README.md:450-485</code></a> and example <code>RestExampleFIT</code> in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L485-L520"><code>README.md:485-520</code></a>.</td>
</tr>
<tr>
<td><strong>Call Trace</strong></td>
<td>The logical record of calls made by the system under test during a FIT: incoming request → outbound HTTP/gRPC calls → Kafka messages etc. While not fully shown in snippets, FIT4J mentions "sync call and async message tracking" for <code>@FIT</code>, which internally builds such call traces for assertions on “what was called” and “in which order”. Typically used to assert that certain external interactions occurred. (Conceptual: see <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L240-L260"><code>README.md:240-260</code></a> for feature list.)</td>
</tr>
<tr>
<td><strong>Mock Response Provider / MockResponseFactory</strong></td>
<td>Core service used by FIT4J to supply responses for mocked external endpoints based on current fixtures. Given an incoming mock request (HTTP or gRPC), it looks up the matching fixture (by protocol, path/type, predicate) and returns the configured response. Referenced in <a href="https://github.com/harezmi/fit4j/blob/main/TestFixtureGroupStateCleanupFIT.kt#L5-L20"><code>TestFixtureGroupStateCleanupFIT.kt:5-20</code></a> where <code>mockResponseFactory.getResponseFor(request)</code> is used.</td>
</tr>
<tr>
<td><strong>Mock Web Server</strong></td>
<td>A mock HTTP server (often backed by OkHttp’s MockWebServer or similar) managed by FIT4J for REST integrations. FIT4J exposes its host/port as Spring environment properties such as <code>fit4j.mockWebServer.host</code> and <code>fit4j.mockWebServer.port</code> so application code can be configured to call it instead of real external endpoints. Enabled automatically in FIT/IT contexts when the dependency is on the classpath. See property description in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L520-L550"><code>README.md:520-550</code></a>.</td>
</tr>
<tr>
<td><strong>Mock gRPC Server</strong></td>
<td>An in-process gRPC server started by the FIT/IT infrastructure to host either the application’s own gRPC endpoints or mock services for external gRPC dependencies. FIT4J uses fixtures to configure responses for external gRPC calls. Example fixture types: <code>com.example.fit4j.grpc.TestGrpc$GetAgeRequest</code> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml#L12-L30"><code>fit4j-fixtures.yml:12-30</code></a>.</td>
</tr>
<tr>
<td><strong>Mock HTTP Fixture (<code>protocol: http</code>)</strong></td>
<td>A declarative fixture that matches outbound HTTP calls from the service under test. It defines <code>path</code>, optional <code>method</code>, optional <code>predicate</code> on the request (e.g. <code>#request.body == 'withBody'</code>), and the <code>response</code>. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L60-L95"><code>src/test/resources/fit4j-fixtures.yml:60-95</code></a>.</td>
</tr>
<tr>
<td><strong>Mock gRPC Fixture (<code>protocol: grpc</code>)</strong></td>
<td>A declarative fixture that matches outbound gRPC calls. It defines <code>type</code> (fully-qualified Protobuf request class) and optional <code>predicate</code> on the request message. The <code>response</code> defines the gRPC payload or error status. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L20-L45"><code>src/test/resources/fit4j-fixtures.yml:20-45</code></a>.</td>
</tr>
<tr>
<td><strong>Predicate (SpEL)</strong></td>
<td>A Spring Expression Language condition attached to a fixture to make matching more precise, e.g. <code>predicate: "#request.name == 'Foo' &amp;&amp; #request.surname == 'Bar'"</code> for gRPC or <code>predicate: "#request.body == 'withBody'"</code> for HTTP. Only when the predicate evaluates to <code>true</code> for an incoming request is the fixture considered a match. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml#L20-L30"><code>fit4j-fixtures.yml:20-30</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures-sample.yml#L25-L40"><code>fit4j-fixtures-sample.yml:25-40</code></a>.</td>
</tr>
<tr>
<td><strong>Multiple Responses / Response Sequence</strong></td>
<td>A fixture can define <code>responses</code> as a list instead of a single <code>response</code>, specifying a sequence of responses for consecutive matching calls. Useful to simulate retries or transient failures (e.g., first 200, then 404). Example in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L40-L70"><code>src/test/resources/fit4j-fixtures-sample.yml:40-70</code></a>.</td>
</tr>
<tr>
<td><strong>Arrange–Act–Assert</strong></td>
<td>The canonical three-phase structure for FIT tests (and tests in general): Arrange (prepare data, fixtures, mocks), Act (execute API call or business operation), Assert (verify response, DB state, external calls). Described in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L550-L580"><code>README.md:550-580</code></a>. FIT4J’s fixtures and mock infrastructure primarily support the Arrange and Assert phases.</td>
</tr>
<tr>
<td><strong>Test Scope</strong></td>
<td>The lifecycle boundary for test data, fixtures, and infrastructure. In FIT4J, declarative fixtures are read once and shared across all tests, and the Spring <code>ApplicationContext</code> is reused to minimize setup cost. “Per-test” behavior (e.g., resetting fixture state, clearing Kafka topics) is controlled via FIT4J properties. While the term <code>test scope</code> isn’t a specific annotation, it conceptually refers to how long test state (containers, fixtures, topics) lives. See the FAQ discussion in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L360-L400"><code>README.md:360-400</code></a>.</td>
</tr>
<tr>
<td><strong>Testcontainers</strong></td>
<td>A Java library that runs real infrastructure (e.g., Kafka, PostgreSQL, Redis, Elasticsearch) in Docker containers for tests. FIT4J integrates with Testcontainers declaratively: it auto-registers container properties such as host, port, JDBC URL as Spring environment properties. See example usages in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L30"><code>fit4j-examples/README.md:1-30</code></a> and properties in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L450-L470"><code>README.md:450-470</code></a>.</td>
</tr>
<tr>
<td><strong>TestContainer Properties</strong></td>
<td>FIT4J-generated properties exposing Testcontainers’ runtime configuration to the application under test. These follow the pattern: <code>fit4j.&lt;container-name&gt;.host</code>, <code>fit4j.&lt;container-name&gt;.port</code>, and <code>fit4j.&lt;container-name&gt;.&lt;exposed-property&gt;</code>. Values are auto-set from <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>, including DB URLs, usernames, and passwords (passwords must be configured as <code>********</code> or via secure secret mechanisms). See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L470-L510"><code>README.md:470-510</code></a>.</td>
</tr>
<tr>
<td><strong><code>fit4j.&lt;container-name&gt;.host</code></strong></td>
<td>Auto-set property with the container’s host address (e.g., <code>localhost</code>). Application code can use this when constructing connection URLs to Testcontainers-managed services. See the TestContainer properties table in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L470-L490"><code>README.md:470-490</code></a>.</td>
</tr>
<tr>
<td><strong><code>fit4j.&lt;container-name&gt;.port</code></strong></td>
<td>Auto-set property with the container’s first mapped port. Used to connect to Testcontainers services (e.g., Kafka listener port, DB port). See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L470-L490"><code>README.md:470-490</code></a>.</td>
</tr>
<tr>
<td><strong><code>fit4j.&lt;container-name&gt;.&lt;exposed-property&gt;</code></strong></td>
<td>Auto-set properties listed in a Testcontainer’s <code>exposedProperties</code> definition (e.g., <code>jdbcUrl</code>, <code>username</code>, <code>password=********</code>). These are extracted from the container and injected into the Spring environment so that the service under test can connect using real parameters. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L470-L510"><code>README.md:470-510</code></a>.</td>
</tr>
<tr>
<td><strong>Kafka Topic Cleaner</strong></td>
<td>FIT4J facility controlled by <code>fit4j.kafka.topicCleaner.enabled</code>. When <code>true</code>, Kafka topics used in tests are automatically cleaned up between test method executions, ensuring test isolation and preventing cross-test interference. Default is <code>false</code>. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L510-L530"><code>README.md:510-530</code></a>.</td>
</tr>
<tr>
<td><strong>Kafka Message Consumption Delay</strong></td>
<td>Config configurable via <code>fit4j.kafka.delayBeforeMessageConsumption</code> (default <code>500</code> ms). It adds a delay before consuming messages to ensure DB transactions are committed before message processing. This improves determinism of tests that depend on both database writes and Kafka consumption. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L500-L520"><code>README.md:500-520</code></a>.</td>
</tr>
<tr>
<td><strong>Embedded Kafka</strong></td>
<td>A Kafka broker embedded in the test JVM, typically provided by Spring Kafka Test. FIT4J has examples that use embedded Kafka for integration tests without external Docker dependencies. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L10-L20"><code>fit4j-examples/README.md:10-20</code></a> (Kafka Embedded example).</td>
</tr>
<tr>
<td><strong>Kafka with Testcontainers</strong></td>
<td>Alternative Kafka testing setup where Kafka is provided via a Docker container managed by Testcontainers instead of an embedded broker. FIT4J supports this to better mimic production setups. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L10-L25"><code>fit4j-examples/README.md:10-25</code></a> (Kafka with Testcontainers example).</td>
</tr>
<tr>
<td><strong>Elasticsearch Testcontainer</strong></td>
<td>Example pattern where Elasticsearch is run using Testcontainers, and FIT4J tests interact with it as a real service. Exposed properties (host, port) are provided via <code>fit4j.elasticsearch.*</code> properties. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L20-L30"><code>fit4j-examples/README.md:20-30</code></a>.</td>
</tr>
<tr>
<td><strong>Redis Testcontainer</strong></td>
<td>Same pattern as Elasticsearch, but for Redis. FIT tests connect to a real Redis instance in a container via properties like <code>fit4j.redis.*</code>. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L20-L30"><code>fit4j-examples/README.md:20-30</code></a>.</td>
</tr>
<tr>
<td><strong><code>@TestConfiguration</code> in FIT tests</strong></td>
<td>Inner configuration class used inside a test annotated with <code>@FIT</code> (or <code>@IT</code>) to define additional beans needed only for that test, such as fixture creators or mock implementations. These beans can be referenced from fixtures via SpEL. Example: <code>RestExampleFIT</code> uses <code>@TestConfiguration</code> + <code>testFixtureCreator</code> bean in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L485-L520"><code>README.md:485-520</code></a>.</td>
</tr>
<tr>
<td><strong><code>webEnvironment</code> parameter of <code>@FIT</code></strong></td>
<td>Optional parameter to control the Spring Boot test web environment, defaulting to <code>SpringBootTest.WebEnvironment.RANDOM_PORT</code>. This determines whether a real HTTP server is started and which port it listens on for test calls. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L285"><code>README.md:260-285</code></a>.</td>
</tr>
<tr>
<td><strong><code>fixtureFilePath</code> parameter of <code>@FIT</code></strong></td>
<td>Optional parameter to override the default fixture file path (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> in the classpath). Allows tests to use custom fixture files (e.g., per module). See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L285"><code>README.md:260-285</code></a>.</td>
</tr>
<tr>
<td><strong>Example FIT Test (<code>DeclarativeTestFixtureDataProviderFIT</code>)</strong></td>
<td>A sample FIT test class demonstrating how to use the <code>@FIT</code> annotation and declarative fixtures. It autowires the ApplicationContext and uses YAML-defined fixtures to drive HTTP/gRPC mocks. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt:1-40</code></a>.</td>
</tr>
<tr>
<td><strong>Fixture State Cleanup</strong></td>
<td>The behavior of resetting fixture state between tests or at specific times so that sequences of responses and per-test variables do not leak across tests. <code>TestFixtureGroupStateCleanupFIT</code> demonstrates this by repeatedly calling <code>mockResponseFactory.getResponseFor(request)</code> and verifying that defined reset points or test group boundaries work as expected. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-40</code></a>.</td>
</tr>
<tr>
<td><strong>Example Modules (<code>fit4j-examples</code>)</strong></td>
<td>A collection of example projects demonstrating FIT use cases: gRPC, HTTP/REST, Kafka with embedded broker or Testcontainers, Elasticsearch, Redis. Helps you see idiomatic usage patterns. See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L30"><code>fit4j-examples/README.md:1-30</code></a>.</td>
</tr>
</tbody>
</table>
<hr />
<h2>Relationships Between Key Concepts</h2>
<p>To understand how these terms interact in a typical FIT:</p>
<ul>
<li><strong><code>@FIT</code> Test Class</strong> uses:</li>
<li><strong>Fixture File</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>) → contains <strong>Fixture Groups</strong> with HTTP/gRPC fixtures.</li>
<li><strong>MockResponseFactory</strong> → uses these fixtures to provide <strong>Mock HTTP/gRPC Responses</strong>.</li>
<li><strong>Testcontainers</strong> or <strong>Embedded Infrastructure</strong> → wired via <strong>TestContainer Properties</strong>.</li>
<li><strong>SpEL Predicates and Beans</strong> (<code>@testFixtureData</code>, <code>@testFixtureCreator</code>) make fixtures dynamic without losing declarative style.</li>
<li><strong>Kafka / DB / Redis / Elasticsearch</strong> are real services; only external microservices are mocked.</li>
</ul>
<p>This conceptual flow is detailed in other sections (architecture and execution flow), but the vocabulary above underpins all of it.</p>
<hr />
<h2>Where to Look in the Code</h2>
<p>While this page is term-focused, some concrete locations help anchor the definitions:</p>
<ul>
<li>Declarative fixtures:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L120"><code>src/test/resources/fit4j-fixtures.yml:1-120</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L1-L90"><code>src/test/resources/fit4j-fixtures-sample.yml:1-90</code></a></li>
<li>FIT test examples:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt#L1-L60"><code>src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt:1-60</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L1-L45"><code>src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-45</code></a></li>
<li>Examples overview:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L30"><code>fit4j-examples/README.md:1-30</code></a></li>
<li>Property reference &amp; FAQ:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/README.md#L220-L580"><code>README.md:220-580</code></a> (annotations, fixture modes, Testcontainers, Kafka settings)</li>
</ul>
<p>For runtime behavior and request/response flows, see the “Execution Flow” and “External Integrations” sections of the wiki, which build on the terminology defined here.</p>
  </div>
</section>


<section id="section-high-level-architecture" class="dw-section">
  <div class="dw-section-inner">
    <h1>High-Level Architecture</h1>
<p>This page describes the high-level architecture of Fit4J: how annotations, Spring Boot auto-configurations, and Spring Test <code>ContextCustomizer</code>s work together, and how protocol-/infrastructure-specific modules (HTTP, gRPC, Kafka, DB, Redis, DynamoDB, Elasticsearch) and the <code>fit4j-examples</code> module fit in.</p>
<p>The goal is to give experienced engineers a C4-style view of the system: main building blocks, interactions, and configuration points. See [Glossary] for term definitions.</p>
<hr />
<h2>Architectural Overview</h2>
<p>Fit4J is a test-support library, not a standalone service. The main “runtime” is your Spring Boot test context, which Fit4J extends via:</p>
<ul>
<li><strong>Spring Boot auto-configurations</strong>: Declare infrastructure and helper beans automatically when Fit4J is on the classpath.</li>
<li>Example: <code>org.fit4j.autoconfigure.TestHelperAutoConfiguration</code> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt</code></a></li>
<li>Example: <code>org.fit4j.autoconfigure.TestGrpcAutoConfiguration</code> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt</code></a></li>
<li><strong>Spring Test Context Customizers</strong>: Hook into <code>@SpringBootTest</code> and friends to start embedded servers and override infrastructure beans.</li>
<li>Example: <code>org.fit4j.context.EnableEmbeddedKafkaContextCustomizer</code> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt</code></a></li>
<li>Example: <code>org.fit4j.context.EmbeddedDynamoDBContextCustomizer</code> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt</code></a></li>
<li>Example: <code>org.fit4j.context.HttpServerContextCustomizer</code> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt</code></a></li>
<li><strong>Protocol-specific helpers</strong>: gRPC, HTTP/REST, Kafka, database, Redis, DynamoDB, Elasticsearch.</li>
<li><strong>Examples module</strong>: <code>fit4j-examples</code> demonstrates the usage of each technology stack and Fit4J feature.</li>
</ul>
<p>At a C4 System/Container level, Fit4J can be seen as a collection of “test infrastructure containers” that attach to your application under test via Spring.</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test method"] --> step2["Spring Test context"]
 step2 --> step3["Fit4J context customizers"]
 step3 --> step4["Embedded infra (DB, Kafka, Redis, gRPC, HTTP)"]
 step4 --> step5["Application under test"]
 step5 --> step6["Verification and helpers"]
</div></div>
<hr />
<h2>Technology Stack</h2>
<p>Key external dependencies (see <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md"><code>LICENSE_COMPATIBILITY_ANALYSIS.md</code></a>):</p>
<ul>
<li><strong>Spring Boot 3.x</strong>: core app &amp; test context (<a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L4-L7"><code>gradle.properties:4-7</code></a>)</li>
<li><strong>Kotlin</strong>: implementation language (<a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L3-L4"><code>gradle.properties:3-4</code></a>)</li>
<li><strong>gRPC &amp; Protobuf</strong>: for gRPC endpoints (<a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L8-L11"><code>gradle.properties:8-11</code></a>)</li>
<li><strong>Spring Kafka + Kafka Test</strong>: for Kafka producer/consumer integration</li>
<li><strong>Testcontainers</strong>: spinning up real infrastructure (MySQL, Kafka, Redis, Elasticsearch, etc.) in Docker (<a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L5-L7"><code>gradle.properties:5-7</code></a>)</li>
<li><strong>Embedded Redis</strong> (<code>com.github.codemonstur:embedded-redis</code>) and <strong>DynamoDB Local</strong> (<code>com.amazonaws:DynamoDBLocal</code>): in-process infrastructure</li>
<li><strong>Elasticsearch REST &amp; Java clients</strong></li>
<li><strong>Jackson</strong> &amp; <strong>Protobuf JsonFormat</strong>: JSON and Protobuf serialization (<a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md"><code>LICENSE_COMPATIBILITY_ANALYSIS.md</code></a>)</li>
</ul>
<p>Version examples:</p>
<pre><code class="language-properties"># Root project
# See gradle.properties:1-13
springBootVersion=3.3.7
grpcSpringBootVersion=3.1.0.RELEASE
protobufJavaVersion=3.21.2
testcontainersVersion=1.15.3
elasticSearchVersion=8.9.1
redisVersion=4.2.3
dynamodbVersion=1.12.717
grpcVersion=1.58.0
</code></pre>
<hr />
<h2>Spring Boot Auto-Configuration Layer</h2>
<h3>TestHelperAutoConfiguration</h3>
<p><code>TestHelperAutoConfiguration</code> provides core test support beans such as JSON helpers, verification helpers, Kafka trackers, and database cleanup helpers.</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt#L1-L25"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt:1-25</code></a></p>
<p>Key imported components:</p>
<ul>
<li><code>JsonHelper</code> (<code>org.fit4j.helper.JsonHelper</code>)</li>
<li><code>VerificationHelper</code> (<code>org.fit4j.helper.VerificationHelper</code>)</li>
<li><code>KafkaMessageTracker</code> (<code>org.fit4j.kafka.KafkaMessageTracker</code>)</li>
<li><code>MockServiceCallTracker</code> (<code>org.fit4j.mock.MockServiceCallTracker</code>)</li>
<li><code>DatabaseTestSupport</code> variants for H2/MySQL/PostgreSQL:</li>
<li><code>DatabaseTestSupportForH2</code></li>
<li><code>DatabaseTestSupportForMysql</code></li>
<li><code>DatabaseTestSupportForPostgreSQL</code></li>
<li><code>NoopDatabaseTestSupport</code></li>
</ul>
<p>It is annotated with:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt:16-18
@AutoConfiguration
class TestHelperAutoConfiguration {
    // @Bean methods (omitted in snippet) create test helper beans
}
</code></pre>
<p><strong>Why:</strong> Centralizes reusable testing utilities so every test suite doesn’t have to define them manually. It uses <code>@ConditionalOnMissingBean</code> (see imports at <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt#L19-L20"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt:19-20</code></a>) to avoid clashing with user-defined beans.</p>
<h3>TestGrpcAutoConfiguration</h3>
<p><code>TestGrpcAutoConfiguration</code> is the gRPC-focused auto-configuration.</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L1-L18"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:1-18</code></a></p>
<p>Key components:</p>
<ul>
<li><code>TestGrpcServiceConfigurer</code></li>
<li><code>TestGrpcServiceDefinitionProvider</code></li>
<li><code>GrpcChannelConfigurer</code></li>
<li><code>MockResponseFactory</code></li>
<li><code>MockServiceCallTracker</code></li>
<li>Declarative mocking:</li>
<li><code>DeclarativeTestFixtureProvider</code></li>
<li><code>JsonContentExpressionResolver</code></li>
<li><code>PredicateEvaluator</code></li>
<li><code>ClassScanner</code> to discover gRPC service definitions.</li>
</ul>
<p>Skeleton:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:9-18
@AutoConfiguration
@AutoConfigureAfter(TestHelperAutoConfiguration::class)
class TestGrpcAutoConfiguration(
) {
    @Bean
    @ConditionalOnBean(TestGrpcServiceDefinitionProvider::class)
    fun testGrpcServiceConfigurer(): TestGrpcServiceConfigurer { /* ... */ }
}
</code></pre>
<p><strong>Why:</strong> Automatically wires a gRPC test server and setups declarative responses without forcing test authors to configure low-level gRPC components.</p>
<hr />
<h2>Spring Test Context Customizer Layer</h2>
<p>Fit4J uses Spring’s <code>ContextCustomizer</code> hook to mutate the test <code>ApplicationContext</code> before it is refreshed, enabling or replacing infrastructure at test time.</p>
<h3>Embedded Kafka</h3>
<p><code>EnableEmbeddedKafkaContextCustomizer</code> modifies the context when a corresponding annotation (e.g., <code>@EnableEmbeddedKafka</code> or custom Fit4J annotations) is detected.</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt#L1-L23"><code>src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt:1-23</code></a></p>
<p>Key aspects:</p>
<ul>
<li>Maintains a static <code>EmbeddedKafkaBroker</code> to avoid starting multiple brokers:</li>
</ul>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt:9-16
class EnableEmbeddedKafkaContextCustomizer : EmbeddedKafkaContextCustomizer() {
    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)
    companion object {
        var embeddedKafkaBroker: EmbeddedKafkaBroker? = null
    }
</code></pre>
<ul>
<li>Creates the broker and registers it as a bean and bootstrap server property:</li>
</ul>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt:18-27
override fun customizeContext(context: ConfigurableApplicationContext, mergedConfig: MergedContextConfiguration) {
    logger.debug(&quot;${this.javaClass.simpleName} is customizing ApplicationContext&quot;)

    if (embeddedKafkaBroker == null) {
        val environment = context.environment
        embeddedKafkaBroker = EmbeddedKafkaBrokerFactory.create(
            EmbeddedKafka(partitions = 1)
        ) { text: String? -&gt;
            environment.resolvePlaceholders(text!!)
        }
    }
    val bf = (context.parent as BeanDefinitionRegistry)
    // registers broker and possibly sets spring.kafka.bootstrap-servers
}
</code></pre>
<p><strong>Effect on configuration:</strong></p>
<ul>
<li>Typically sets <code>spring.kafka.bootstrap-servers</code> at runtime so the application uses the embedded broker instead of external Kafka.</li>
<li>Tests can use normal <code>KafkaTemplate</code> and <code>@KafkaListener</code> beans; Fit4J tracks messages via <code>KafkaMessageTracker</code>.</li>
</ul>
<h3>Embedded DynamoDB</h3>
<p><code>EmbeddedDynamoDBContextCustomizer</code> spins up an in-process DynamoDB Local instance and registers it as a Spring bean, used when a test annotation like <code>@EmbeddedDynamoDB</code> is present.</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt#L1-L25"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt:1-25</code></a></p>
<p>Key logic:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt:13-24
class EmbeddedDynamoDBContextCustomizer : ContextCustomizer {
    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)

    override fun customizeContext(context: ConfigurableApplicationContext, mergedConfig: MergedContextConfiguration) {
        logger.debug(&quot;${this.javaClass.simpleName} is customizing ApplicationContext&quot;)

        val listableBeanFactory = context.beanFactory as DefaultListableBeanFactory
        val embedded = DynamoDBEmbedded.create()
        listableBeanFactory.registerSingleton(&quot;amazonDynamoDBEmbedded&quot;, embedded)
        listableBeanFactory.registerDisposableBean(&quot;amazonDynamoDBEmbedded&quot;) { embedded.shutdown() }
    }
}
</code></pre>
<p><strong>Why:</strong> Lets you run the application against a local DynamoDB without Docker/Testcontainers. Fit4J often also overrides the AWS <code>AmazonDynamoDB</code> bean in the user application to point to this embedded instance (see “Embedded DynamoDB” section in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L120-L134"><code>README.md:120-134</code></a>).</p>
<h3>Embedded HTTP Server (MockWebServer-like)</h3>
<p><code>HttpServerContextCustomizer</code> configures an in-process HTTP mock server (e.g., based on OkHttp MockWebServer or a wrapper around it) for REST/HTTP tests.</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt#L1-L24"><code>src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt:1-24</code></a></p>
<p>Key logic:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt:13-26
override fun customizeContext(context: ConfigurableApplicationContext, mergedConfig: MergedContextConfiguration) {
    registerHttpServer(context)
}

private fun registerHttpServer(context: ConfigurableApplicationContext) {
    logger.debug(&quot;${this.javaClass.simpleName} is customizing ApplicationContext&quot;)

    val listableBeanFactory = context.beanFactory as DefaultListableBeanFactory

    val httpServerWrapper = HttpServerWrapper()
    httpServerWrapper.start()

    listableBeanFactory.registerSingleton(&quot;httpServer&quot;, httpServerWrapper)
    listableBeanFactory.registerDisposableBean(&quot;httpServer&quot;, DisposableBean {
        httpServerWrapper.stop()
    })

    context.environment.propertySources.addAfter(
        // adds dynamic properties such as base URL for the mock server
    )
}
</code></pre>
<p><strong>Why:</strong> Allows test methods to define HTTP expectations and responses, while the application under test uses a normal <code>WebClient</code>/<code>RestTemplate</code> pointing to the injected base URL.</p>
<h3>Other Context Customizers</h3>
<p>By convention (and based on the README features list <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L90-L104"><code>README.md:90-104</code></a>), the library also has similar customizers for:</p>
<ul>
<li><strong>Embedded Redis</strong> – spin up an embedded Redis server and override Redis connection properties.</li>
<li><strong>Testcontainers-based infrastructure</strong> – automatically start containers defined in Fit4J configuration files and expose properties to the Spring environment.</li>
</ul>
<p>These follow the same pattern: implement <code>ContextCustomizer</code>, start resource, register bean, inject environment properties, and register shutdown hooks.</p>
<hr />
<h2>Protocol- and Infrastructure-Specific Modules</h2>
<h3>HTTP / REST</h3>
<ul>
<li><strong>Mock HTTP server</strong>: Provided via <code>HttpServerContextCustomizer</code> and <code>HttpServerWrapper</code>.</li>
<li><strong>Declarative fixtures</strong>: Tests declare expected request/response pairs; Fit4J routes actual requests from the application under test to these fixtures.</li>
<li><strong>Examples</strong>: <code>fit4j-examples/example-rest</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L4-L7"><code>fit4j-examples/README.md:4-7</code></a>).</li>
</ul>
<p>Config example in tests (your test service might read these dynamic properties):</p>
<pre><code class="language-properties"># application-test.properties
# See src/test/resources/application-test.properties:1-11
redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}

elasticSearch.host=${fit4j.elasticSearchContainerDefinition.host}
elasticSearch.port=${fit4j.elasticSearchContainerDefinition.port}

spring.kafka.template.default-topic=fit4j-test-topic
</code></pre>
<p>These properties are typically added/overridden by Fit4J’s context customizers once Testcontainers/embedded instances are started.</p>
<h3>gRPC</h3>
<ul>
<li><strong>gRPC support</strong> uses:</li>
<li><code>TestGrpcAutoConfiguration</code> to configure gRPC server and channels.</li>
<li>Declarative training for gRPC methods (request → response mapping).</li>
<li>Automatic discovery of annotated gRPC services via <code>ClassScanner</code>.</li>
<li><strong>Examples</strong>: <code>fit4j-examples/example-grpc</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L4"><code>fit4j-examples/README.md:1-4</code></a>).</li>
</ul>
<p>Your service still uses regular gRPC stubs; Fit4J intercepts calls via configured channels and mock service definitions.</p>
<h3>Kafka</h3>
<p>Kafka is supported in two modes:</p>
<ol>
<li><strong>Embedded Kafka broker</strong> (Spring Kafka Test):</li>
<li>Driven by <code>EnableEmbeddedKafkaContextCustomizer</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt#L1-L27"><code>src/main/kotlin/org/fit4j/context/EnableEmbeddedKafkaContextCustomizer.kt:1-27</code></a>).</li>
<li>Auto-sets <code>spring.kafka.bootstrap-servers</code> for the application.</li>
<li>
<p>Used in <code>fit4j-examples/example-kafka</code> (embedded broker) <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L5-L7"><code>fit4j-examples/README.md:5-7</code></a>.</p>
</li>
<li>
<p><strong>Testcontainers Kafka</strong>:</p>
</li>
<li>Uses Testcontainers definitions from YAML, such as <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L20"><code>src/test/resources/fit4j-test-containers-sample.yml:1-20</code></a>.</li>
<li>Example Kafka container block (truncated in snippet, but pattern similar to Redis/Elasticsearch).</li>
<li>Used in <code>fit4j-examples/example-kafka-testcontainers</code> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L7-L8"><code>fit4j-examples/README.md:7-8</code></a>).</li>
</ol>
<p>Fit4J additionally offers:</p>
<ul>
<li><strong>Kafka message tracing</strong> via <code>KafkaMessageTracker</code>:</li>
<li>Captures messages produced/consumed by your service.</li>
<li>Enables assertion of message content and count in tests.</li>
</ul>
<p>Spring Kafka configuration in tests can be minimal, relying on Fit4J to supply dynamic properties:</p>
<pre><code class="language-properties"># See src/test/resources/application-test.properties:13-18
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.template.default-topic=fit4j-test-topic
</code></pre>
<p>The critical part—<code>spring.kafka.bootstrap-servers</code>—is injected by Fit4J.</p>
<h3>Database (MySQL, H2, etc.)</h3>
<p>While direct DB auto-config fragments are not in the snippets, the architecture is:</p>
<ul>
<li>Use <strong>Testcontainers</strong> for real DB instances (MySQL, PostgreSQL, etc.).</li>
<li>Use <code>DatabaseTestSupport</code> implementations (H2/MySQL/PostgreSQL) to:</li>
<li>Clear database state between tests.</li>
<li>Populate initial data.</li>
<li>Fit4J maps container properties into Spring <code>datasource</code> properties, usually from YAML such as <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L12"><code>src/test/resources/fit4j-test-containers-sample.yml:1-12</code></a>, which includes MySQL container config.</li>
</ul>
<p>Excerpt from sample YAML (DB part):</p>
<pre><code class="language-yaml"># See src/test/resources/fit4j-test-containers-sample.yml:1-12
- container: org.testcontainers.containers.MySQLContainer
  name: example_mysql
  image: mysql:8.0
  env:
    - TZ: America/Los_Angeles
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
    - useLegacyDatetimeCode: &quot;false&quot;
  exposedProperties:
    - jdbcUrl
    - username
    - password
</code></pre>
<p>All actual credentials must be masked in documentation; test configs in your project should use environment variables or non-sensitive values.</p>
<h3>Redis</h3>
<p>Two modes:</p>
<ol>
<li><strong>Testcontainers Redis</strong>:</li>
<li>Defined in the same YAML file as other containers:</li>
</ol>
<p><code>yaml
   # See src/test/resources/fit4j-test-containers-sample.yml:13-20
   - container: org.testcontainers.containers.GenericContainer
     name: redis
     image: redis:6.2.1
     exposedPorts:
       - 6379
     exposedProperties:
       - host</code></p>
<p>Fit4J exposes <code>fit4j.redisContainerDefinition.host</code> and <code>fit4j.redisContainerDefinition.port</code> (see usage in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties#L1-L3"><code>application-test.properties:1-3</code></a>).</p>
<ol>
<li><strong>Embedded Redis</strong>:</li>
<li>Uses <code>embedded-redis</code> library (<a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L18"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-18</code></a>).</li>
<li>Enabled via annotation (described in README: “Embedded Redis support with configurable ports” <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L90-L104"><code>README.md:90-104</code></a>).</li>
<li>Likely implemented via another <code>ContextCustomizer</code> similar to DynamoDB, starting/stopping embedded Redis and injecting host/port properties.</li>
</ol>
<h3>DynamoDB</h3>
<p>Two options:</p>
<ol>
<li><strong>Testcontainers DynamoDB</strong>:</li>
<li>Part of the Testcontainers suite as described in README: “Declarative TestContainers support for MySQL, DynamoDB, Kafka, Redis, ElasticSearch etc.” <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L90-L101"><code>README.md:90-101</code></a>.</li>
<li>
<p>Container properties are injected into Spring environment.</p>
</li>
<li>
<p><strong>Embedded DynamoDB</strong>:</p>
</li>
<li>Provided by <code>EmbeddedDynamoDBContextCustomizer</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt#L13-L24"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt:13-24</code></a>).</li>
<li>Enabled by an <code>@EmbeddedDynamoDB</code> annotation (see README explanation <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L135-L145"><code>README.md:135-145</code></a>).</li>
<li>The test library <strong>overrides the AWS DynamoDB client bean</strong> in your service to point to the embedded instance.</li>
</ol>
<p><strong>Why:</strong> Faster feedback for tests when you don’t need full containerized AWS emulation, and reduced external dependencies.</p>
<h3>Elasticsearch</h3>
<ul>
<li>Testcontainers is used to run Elasticsearch:</li>
</ul>
<pre><code class="language-yaml"># See src/test/resources/fit4j-test-containers-sample.yml:21-34
- container: org.testcontainers.elasticsearch.ElasticsearchContainer
  name: elastic-search
  image: docker.elastic.co/elasticsearch/elasticsearch:8.10.2
  exposedPorts:
    - 9200
    - 9300
  env:
    - ELASTICSEARCH_USERNAME: root
    - ELASTICSEARCH_PASSWORD: ********
    - xpack.security.enabled: false
    - bootstrap.memory_lock: true
    - cluster.routing.allocation.disk.threshold_enabled: false
    - JAVA_TOOL_OPTIONS: -Xmx10G
</code></pre>
<p>(Password masked to <code>********</code>.)</p>
<ul>
<li>
<p>Fit4J exposes properties like <code>fit4j.elasticSearchContainerDefinition.host</code> and <code>fit4j.elasticSearchContainerDefinition.port</code>, which are then mapped in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties#L4-L7"><code>application-test.properties:4-7</code></a>.</p>
</li>
<li>
<p>Examples: <code>fit4j-examples/example-elasticsearch</code> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L7-L9"><code>fit4j-examples/README.md:7-9</code></a>).</p>
</li>
</ul>
<hr />
<h2>Configuration and Property Injection</h2>
<p>Fit4J’s architecture centers around dynamic property resolution:</p>
<ul>
<li><strong>Container definitions</strong>: YAML like <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml"><code>src/test/resources/fit4j-test-containers-sample.yml</code></a> define Testcontainers-based services.</li>
<li><strong>Generated properties</strong>: At startup, Fit4J Testcontainers integration resolves:</li>
<li><code>fit4j.&lt;containerName&gt;ContainerDefinition.host</code></li>
<li><code>fit4j.&lt;containerName&gt;ContainerDefinition.port</code></li>
<li>Plus other exposed properties (e.g., <code>jdbcUrl</code>, <code>username</code>, <code>password</code>).</li>
<li><strong>Application test config</strong>: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties"><code>src/test/resources/application-test.properties</code></a> maps these to the application’s expected properties (Redis, Elasticsearch, Kafka, etc.).</li>
</ul>
<p>Example:</p>
<pre><code class="language-properties"># See src/test/resources/application-test.properties:1-7
redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}

elasticSearch.host=${fit4j.elasticSearchContainerDefinition.host}
elasticSearch.port=${fit4j.elasticSearchContainerDefinition.port}
</code></pre>
<p>This decouples tests from hardcoded host/port values and allows infrastructure to be reconfigured centrally via YAML.</p>
<p>Logging configuration:</p>
<pre><code class="language-properties"># See src/test/resources/application-test.properties:9-12
logging.level.root=fatal
logging.level.org.fit4j=debug
logging.level.org.springframework.boot=debug
</code></pre>
<p>This is particularly important for debugging context customizers and auto-configurations, as they log debug-level information about what was started or overridden.</p>
<hr />
<h2>fit4j-examples Module</h2>
<p>The <code>fit4j-examples</code> module (<code>fit4j-examples/</code>) is not part of the core library but demonstrates its architecture in practice. It contains multiple submodules, each focused on a specific stack.</p>
<p>Top-level README: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L11"><code>fit4j-examples/README.md:1-11</code></a> lists:</p>
<ul>
<li><code>example-basic</code>: basic usage</li>
<li><code>example-grpc</code>: gRPC test examples</li>
<li><code>example-rest</code>: HTTP/REST test examples</li>
<li><code>example-kafka</code>: Kafka with embedded broker</li>
<li><code>example-kafka-testcontainers</code>: Kafka with Testcontainers</li>
<li><code>example-elasticsearch</code>: Elasticsearch with Testcontainers</li>
<li><code>example-redis</code>: Redis with Testcontainers</li>
</ul>
<p>Each example:</p>
<ul>
<li>Defines its own Spring Boot application under test.</li>
<li>Uses Fit4J annotations and configuration files to start required infrastructure.</li>
<li>Shows best practices for wiring <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> and container YAML.</li>
</ul>
<p>This structure mirrors the modularity of Fit4J’s architecture: each protocol/infrastructure support piece is loosely coupled and independently demonstrable.</p>
<hr />
<h2>How Components Work Together</h2>
<p>From a high-level “test execution” perspective:</p>
<ol>
<li><strong>Test runner</strong> starts a Spring Boot test (<code>@SpringBootTest</code>, <code>@ExtendWith</code>).</li>
<li><strong>Spring Test</strong> analyzes annotations and config to build a <code>MergedContextConfiguration</code>.</li>
<li><strong>Fit4J ContextCustomizers</strong> contribute to context preparation:</li>
<li>Start embedded/Testcontainers resources (Kafka, DB, Redis, DynamoDB, Elasticsearch, HTTP, gRPC).</li>
<li>Register beans (e.g., <code>EmbeddedKafkaBroker</code>, <code>HttpServerWrapper</code>, <code>amazonDynamoDBEmbedded</code>).</li>
<li>Inject dynamic properties (e.g., <code>spring.kafka.bootstrap-servers</code>, <code>redis.host</code>).</li>
<li><strong>Spring Boot Auto-Configuration</strong> from Fit4J runs:</li>
<li>Creates helper beans (<code>JsonHelper</code>, <code>VerificationHelper</code>, <code>KafkaMessageTracker</code>).</li>
<li>Configures protocol-specific test infrastructure (gRPC, HTTP).</li>
<li><strong>Application under test</strong> is created using these beans and properties.</li>
<li><strong>Test methods</strong> interact through their normal “public interfaces”:</li>
<li>HTTP (MockWebServer URL)</li>
<li>gRPC stubs</li>
<li>Kafka producers/consumers</li>
<li>DB repositories</li>
<li>Redis/DynamoDB/Elasticsearch clients</li>
<li><strong>Fit4J helpers</strong> capture and validate behavior:</li>
<li>Kafka message tracing</li>
<li>Mock service call tracking</li>
<li>DB cleanup and initial data</li>
<li>Declarative fixtures for HTTP/gRPC</li>
</ol>
<p>Any change in a context customizer or auto-configuration can affect multiple examples and user tests. When you extend the library:</p>
<ul>
<li>Prefer adding new auto-configuration classes (e.g., for a new protocol).</li>
<li>Or add new <code>ContextCustomizer</code> implementations for new embedded infra.</li>
<li>Ensure properties are injected via environment property sources, not hardcoded, to preserve flexibility.</li>
</ul>
<p>For deeper details on individual protocols or test patterns, see the dedicated sections (e.g., “Execution Flow”, “External Integrations”, or per-protocol reference pages) and [Glossary] for shared terminology.</p>
  </div>
</section>


<section id="section-technology-stack" class="dw-section">
  <div class="dw-section-inner">
    <h1>Technology Stack &amp; Dependencies</h1>
<p>This page describes the core technologies, libraries, and infrastructure dependencies used across the project. It focuses on how they fit together in the context of FIT-based integration testing (FIT4J) and what they are typically used for in this repository.</p>
<p>Use this as a reference when adding new tests, debugging environment issues, or upgrading dependencies.</p>
<hr />
<h2>Overview of the Stack</h2>
<p>At a high level, the project is:</p>
<ul>
<li><strong>Language-centric</strong>: Kotlin (with Java interop) on top of the JVM.</li>
<li><strong>Framework-centric</strong>: Spring Boot 3.x for application and test wiring.</li>
<li><strong>Test-centric</strong>: JUnit 5, Spring Boot Test, Testcontainers, and embedded services (Kafka, Redis, DynamoDB, H2).</li>
<li><strong>Integration-heavy</strong>: Kafka, Redis, Elasticsearch, MySQL/Postgres (via JDBC), AWS DynamoDB SDK.</li>
<li><strong>Build-tool agnostic</strong>: Primarily Gradle, but easily mappable to Maven.</li>
</ul>
<p>Version pins and global properties are defined in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L1-L11"><code>gradle.properties:1-11</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L1-L8"><code>fit4j-examples/gradle.properties:1-8</code></a></li>
</ul>
<hr />
<h2>Languages &amp; Core Runtime</h2>
<h3>Kotlin (Primary)</h3>
<p><strong>Dependencies</strong></p>
<ul>
<li>Kotlin Standard Library  </li>
<li>Artifact: <code>org.jetbrains.kotlin:kotlin-stdlib</code>  </li>
<li>Declared in: <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L1-L4"><code>LICENSE-THIRD-PARTY.md:1-4</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L1-L7"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:1-7</code></a>  </li>
<li>Kotlin Coroutines  </li>
<li>Artifact: <code>org.jetbrains.kotlinx:kotlinx-coroutines-core</code>  </li>
<li>Declared in: <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L1-L4"><code>LICENSE-THIRD-PARTY.md:1-4</code></a></li>
</ul>
<p><strong>Version</strong></p>
<ul>
<li><code>kotlinVersion=1.6.21</code> in <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L4-L6"><code>gradle.properties:4-6</code></a></li>
</ul>
<p><strong>Usage</strong></p>
<ul>
<li>Most test code is written in Kotlin, e.g.:<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt#L1-L20"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt:1-20</code></a>  </li>
<li>Coroutines are typically used where asynchronous flows or non-blocking IO are needed in tests or support utilities.</li>
</ul>
<p>When adding new modules, keep Kotlin and Coroutines versions aligned with <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties"><code>gradle.properties</code></a> to avoid ABI issues.</p>
<h3>Java Interop</h3>
<p>While Kotlin is primary, Java-based frameworks and libraries are used extensively:</p>
<ul>
<li>Spring Boot (Java-based framework)</li>
<li>AWS SDK for DynamoDB (Java SDK v1)</li>
<li>gRPC server/client stubs (Java/Kotlin compatible)</li>
<li>Testcontainers core library (Java)</li>
</ul>
<p>Ensure any raw Java code is compiled with a JVM version compatible with Spring Boot 3.3.x (Jakarta namespace).</p>
<hr />
<h2>Application &amp; Framework Layer</h2>
<h3>Spring Boot &amp; Spring Test</h3>
<p><strong>Version</strong></p>
<ul>
<li><code>springBootVersion=3.3.7</code> in:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L3-L5"><code>gradle.properties:3-5</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L1-L3"><code>fit4j-examples/gradle.properties:1-3</code></a></li>
</ul>
<p><strong>Typical Components</strong></p>
<ul>
<li>Spring Boot Test (<code>spring-boot-starter-test</code>)</li>
<li>Spring Kafka (<code>spring-kafka</code>) – listed in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L18"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-18</code></a></li>
<li>Jackson Kotlin module (<code>com.fasterxml.jackson.module:jackson-module-kotlin</code>) – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L18"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-18</code></a></li>
<li>Jakarta annotation API (<code>jakarta.annotation:jakarta.annotation-api</code>) – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L31-L35"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:31-35</code></a></li>
</ul>
<p><strong>Usage</strong></p>
<p>Tests are organized as Spring Boot test contexts, enabling:</p>
<ul>
<li><code>@FIT</code> (custom annotation) to bootstrap FIT4J integration test context.<br />
  Example: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt#L6-L16"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt:6-16</code></a></li>
<li>Auto-wiring of beans into tests, e.g.:</li>
<li><code>@Autowired private lateinit var amazonDynamoDB: AmazonDynamoDB</code> in<br />
<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L16-L24"><code>fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:16-24</code></a></li>
</ul>
<p>Spring Boot’s configuration system is used to map Testcontainers/embedded endpoints to properties, e.g.:</p>
<pre><code class="language-properties"># See src/test/resources/application-test.properties:1-8
redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}

elasticSearch.host=${fit4j.elasticSearchContainerDefinition.host}
elasticSearch.port=${fit4j.elasticSearchContainerDefinition.port}
</code></pre>
<hr />
<h2>Testing Frameworks &amp; Utilities</h2>
<h3>JUnit 5</h3>
<p>JUnit 5 is the main test runner:</p>
<ul>
<li>Example usage: <code>@Test</code> in<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt#L11-L18"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt:11-18</code></a><br />
  and<br />
<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L20-L31"><code>fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:20-31</code></a></li>
</ul>
<p>Typical usage patterns:</p>
<ul>
<li><code>@BeforeEach</code>, <code>@AfterEach</code> for lifecycle management (see DynamoDB example test).</li>
<li><code>Assertions</code> or Hamcrest <code>MatcherAssert</code> for assertions.</li>
</ul>
<h3>Spring Boot Test</h3>
<p>Used implicitly via Spring Boot starter test dependencies to:</p>
<ul>
<li>Start an application context per test class.</li>
<li>Wire Testcontainers-based beans into the context.</li>
<li>Integrate <code>@FIT</code> with Spring lifecycle.</li>
</ul>
<p>See the main README for high-level test behavior: <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L90"><code>README.md:60-90</code></a>.</p>
<h3>MockK (Kotlin Mocking)</h3>
<p><strong>Version</strong></p>
<ul>
<li><code>mockkVersion=1.9.1</code> in <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L5-L8"><code>gradle.properties:5-8</code></a></li>
</ul>
<p><strong>Dependency</strong></p>
<ul>
<li><code>io.mockk:mockk</code> – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L4-L8"><code>LICENSE-THIRD-PARTY.md:4-8</code></a></li>
</ul>
<p>Used for mocking collaborators in unit-level tests when a full Spring context is not required. Typically:</p>
<pre><code class="language-kotlin">// Example pattern (not from file)
val service = mockk&lt;MyService&gt;()
every { service.call() } returns &quot;OK&quot;
</code></pre>
<p>When writing new tests, prefer MockK for Kotlin classes instead of Mockito.</p>
<h3>Hamcrest (Assertions)</h3>
<p>Hamcrest is used for expressive assertions:</p>
<ul>
<li><code>MatcherAssert.assertThat</code> and <code>Matchers.contains</code> in<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt#L17-L23"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt:17-23</code></a></li>
</ul>
<p>You can freely mix Hamcrest with JUnit assertions depending on readability.</p>
<hr />
<h2>Containerized Test Infrastructure (Testcontainers)</h2>
<h3>Testcontainers Core</h3>
<p><strong>Version</strong></p>
<ul>
<li><code>testcontainersVersion=1.15.3</code> in:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L5-L7"><code>gradle.properties:5-7</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L4-L6"><code>fit4j-examples/gradle.properties:4-6</code></a></li>
</ul>
<p><strong>Dependency</strong></p>
<ul>
<li><code>org.testcontainers:testcontainers</code> – MIT, see <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L23-L28"><code>LICENSE-THIRD-PARTY.md:23-28</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L7-L13"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:7-13</code></a></li>
</ul>
<p><strong>Usage</strong></p>
<p>The library uses <strong>declarative container definitions</strong> through YAML files in <code>src/test/resources</code> that are interpreted by FIT4J:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L24"><code>src/test/resources/fit4j-test-containers.yml:1-24</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L40"><code>src/test/resources/fit4j-test-containers-sample.yml:1-40</code></a></li>
</ul>
<p>Examples of defined containers:</p>
<ul>
<li>MySQL / Postgres DB</li>
<li>Redis</li>
<li>Elasticsearch</li>
<li>Kafka</li>
<li>DynamoDB</li>
</ul>
<p>Snippet (MySQL + Redis + Elasticsearch):</p>
<pre><code class="language-yaml"># See src/test/resources/fit4j-test-containers.yml:1-22
- container: org.testcontainers.containers.MySQLContainer
  name: mysqlContainerDefinition
  image: mysql:8.0
  exposedPorts:
    - 3306
  exposedProperties:
    - jdbcUrl
    - username
    - password
  reuse: false

- container: org.testcontainers.containers.GenericContainer
  name: redisContainerDefinition
  image: redis:6.2.1
  exposedPorts:
    - 6379
  exposedProperties:
    - host
    - firstMappedPort
  reuse: false
</code></pre>
<p>FIT4J maps <code>exposedProperties</code> to <code>fit4j.*</code> properties (e.g. <code>fit4j.redisContainerDefinition.host</code>) and then they are used in standard Spring <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties#L1-L8"><code>application-test.properties:1-8</code></a>.</p>
<h3>Embedded vs Testcontainers</h3>
<p>The stack supports both <strong>embedded</strong> and <strong>real containers</strong> via Testcontainers:</p>
<ul>
<li>Declarative Testcontainers:</li>
<li>See README sections:<ul>
<li>“How to Work with TestContainers?”: <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L120-L180"><code>README.md:120-180</code></a></li>
<li>Initial data population examples: <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L180-L240"><code>README.md:180-240</code></a></li>
</ul>
</li>
<li>Embedded DynamoDB:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/README.md#L240-L260"><code>README.md:240-260</code></a> describes <code>@EmbeddedDynamoDB</code>:
    &gt; adding <code>@EmbeddedDynamoDB</code> on the test class starts an embedded DynamoDB instance and replaces the AWS client bean.</li>
<li>Embedded Redis:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L280"><code>README.md:260-280</code></a> describes embedded Redis as an alternative to Testcontainers.</li>
</ul>
<p>Testcontainers is the recommended option for realistic integration tests; embedded variants are useful for fast feedback or CI environments with limited Docker support.</p>
<hr />
<h2>Messaging &amp; Streaming</h2>
<h3>Kafka</h3>
<p>The stack supports Kafka in two ways:</p>
<ol>
<li><strong>Embedded Kafka (Recommended)</strong><br />
   Using Spring Kafka Test and a FIT4J annotation:</li>
</ol>
<p>```kotlin
   // See README.md:280-305
   import org.fit4j.kafka.EnableEmbeddedKafka
   import org.fit4j.annotation.FIT</p>
<p>@EnableEmbeddedKafka
   @FIT
   class SampleFIT {
       // Your test code
   }
   ```</p>
<ul>
<li><code>@EnableEmbeddedKafka</code> is provided by FIT4J (<code>org.fit4j.kafka.EnableEmbeddedKafka</code>).</li>
<li>Alternatively, <code>@EmbeddedKafka</code> from Spring Kafka Test is supported (requires <code>@DirtiesContext</code> to avoid JVM shutdown races).</li>
</ul>
<p>Configuration example:</p>
<p><code>properties
   # See src/test/resources/application-test.properties:10-16
   spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
   spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
   spring.kafka.template.default-topic=fit4j-test-topic</code></p>
<ol>
<li><strong>Kafka via Testcontainers</strong>  </li>
<li>
<p>Kafka container is defined in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L30-L36"><code>src/test/resources/fit4j-test-containers-sample.yml:30-36</code></a>:</p>
<p><code>yaml
 - container: org.testcontainers.containers.GenericContainer
   name: kafka-service-bus
   image: confluentinc/cp-kafka:5.4.3
   reuse: true</code></p>
</li>
</ol>
<p>Use this when you need a broker setup closer to production (e.g. Confluent images).</p>
<p>Spring Kafka core library (<code>org.springframework.kafka:spring-kafka</code>) is referenced in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L19"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-19</code></a>.</p>
<hr />
<h2>Data Stores</h2>
<h3>Relational Databases (MySQL, Postgres, H2)</h3>
<p><strong>MySQL via Testcontainers</strong></p>
<p>Defined in YAML (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> and README snippets):</p>
<pre><code class="language-yaml"># Example from README.md:10-24
- container: org.testcontainers.containers.MySQLContainer
  name: mysqlContainerDefinition
  image: mysql:8.0
  ports:
    - 3306
  username: root
  password: ********
  databaseName: v1
  initScript: scripts/v1_init.sql
</code></pre>
<ul>
<li>Initial data is populated via <code>initScript</code> (e.g. <a href="https://github.com/harezmi/fit4j/blob/main/scripts/v1_init.sql"><code>scripts/v1_init.sql</code></a>).</li>
<li>The database connection details are exposed as properties and injected into tests.</li>
</ul>
<p><strong>Postgres via Testcontainers</strong></p>
<ul>
<li>Defined in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L18"><code>src/test/resources/fit4j-test-containers.yml:1-18</code></a>, with typical properties:</li>
<li><code>username: postgres</code></li>
<li><code>password: ********</code></li>
<li><code>databaseName: testdb</code></li>
<li>Time zone and auth environment variables.</li>
</ul>
<p><strong>H2 Embedded</strong></p>
<ul>
<li>H2 is used for in-memory tests without containers:</li>
<li>Listed in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L41-L48"><code>LICENSE-THIRD-PARTY.md:41-48</code></a></li>
<li>Examples in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-h2/README.md#L1-L20"><code>fit4j-examples/example-h2/README.md:1-20</code></a> (referenced by <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L8-L13"><code>fit4j-examples/README.md:8-13</code></a>)</li>
</ul>
<p>Use H2 when your test does not require DB engine-specific behavior.</p>
<h3>Redis</h3>
<p>Two primary approaches:</p>
<ol>
<li>
<p><strong>Redis via Testcontainers</strong></p>
</li>
<li>
<p>Defined in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L18-L30"><code>src/test/resources/fit4j-test-containers.yml:18-30</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L10-L20"><code>src/test/resources/fit4j-test-containers-sample.yml:10-20</code></a></li>
</ul>
</li>
<li>
<p>Example:</p>
<p><code>yaml
 # See src/test/resources/fit4j-test-containers.yml:18-30
 - container: org.testcontainers.containers.GenericContainer
   name: redisContainerDefinition
   image: redis:6.2.1
   initScript: scripts/redis_initial_data.yml
   exposedPorts:
     - 6379
   exposedProperties:
     - host
     - firstMappedPort
   reuse: false</code></p>
</li>
<li>
<p><a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> then maps <code>redis.host</code> and <code>redis.port</code> from the container:<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties#L1-L4"><code>src/test/resources/application-test.properties:1-4</code></a></p>
</li>
<li>
<p><code>RedisDataProviderFIT</code> illustrates reading initial data from YAML:<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt#L11-L23"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt:11-23</code></a></p>
</li>
<li>
<p><strong>Embedded Redis</strong></p>
</li>
<li>
<p>Uses <code>com.github.codemonstur:embedded-redis</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L9-L13"><code>LICENSE-THIRD-PARTY.md:9-13</code></a>).</p>
</li>
<li>Explained in README: <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L260-L280"><code>README.md:260-280</code></a></li>
<li>Suitable when Docker is unavailable or when you need fast in-memory tests.</li>
</ol>
<p>Jedis (<code>redis.clients:jedis</code>) is the primary Redis client library (<a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L23-L27"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:23-27</code></a>).</p>
<h3>Elasticsearch</h3>
<p><strong>Dependencies</strong></p>
<ul>
<li>REST Client: <code>org.elasticsearch.client:elasticsearch-rest-client</code></li>
<li>Java Client: <code>co.elastic.clients:elasticsearch-java</code><br />
  Both listed in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L6-L10"><code>LICENSE-THIRD-PARTY.md:6-10</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L19-L23"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:19-23</code></a>.</li>
</ul>
<p><strong>Testcontainers</strong></p>
<ul>
<li>Elasticsearch containers defined in:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L30-L44"><code>src/test/resources/fit4j-test-containers.yml:30-44</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L20-L32"><code>src/test/resources/fit4j-test-containers-sample.yml:20-32</code></a></li>
</ul>
<p>Example:</p>
<pre><code class="language-yaml"># See src/test/resources/fit4j-test-containers-sample.yml:20-32
- container: org.testcontainers.elasticsearch.ElasticsearchContainer
  name: elasticSearchContainerDefinition
  image: docker.elastic.co/elasticsearch/elasticsearch:8.10.2
  exposedPorts:
    - 9200
    - 9300
  env:
    - ELASTICSEARCH_USERNAME: root
    - ELASTICSEARCH_PASSWORD: ********
    - xpack.security.enabled: false
    - bootstrap.memory_lock: true
</code></pre>
<p>Application properties map host/port to <code>elasticSearch.host</code> and <code>elasticSearch.port</code> in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties#L4-L8"><code>src/test/resources/application-test.properties:4-8</code></a>.</p>
<h3>AWS DynamoDB</h3>
<p><strong>Dependencies</strong></p>
<ul>
<li>AWS SDK v1 for DynamoDB:</li>
<li><code>com.amazonaws:aws-java-sdk-dynamodb</code> (implied from imports in tests)</li>
<li><code>com.amazonaws:DynamoDBLocal</code> for local engine – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L11-L15"><code>LICENSE-THIRD-PARTY.md:11-15</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L27-L31"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:27-31</code></a></li>
</ul>
<p><strong>Usage</strong></p>
<ul>
<li>DynamoDB via Testcontainers:</li>
</ul>
<p><code>kotlin
  // See fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:12-31
  @Testcontainers(definitions = ["dynamodb"])
  @FIT
  class DynamoDBExampleFIT {
      @Autowired
      private lateinit var amazonDynamoDB: AmazonDynamoDB
      ...
  }</code></p>
<p>Corresponding container definition:</p>
<p><code>yaml
  # See src/test/resources/fit4j-test-containers-sample.yml:36-42
  - container: org.testcontainers.containers.GenericContainer
    name: dynamodb
    image: amazon/dynamodb-local:1.13.6
    exposedPorts:
      - 8000</code></p>
<ul>
<li>Embedded DynamoDB:</li>
</ul>
<p>README describes <code>@EmbeddedDynamoDB</code> which:
  - Starts a DynamoDBLocal instance on an ephemeral port.
  - Overrides the AWS DynamoDB client bean with a local client.<br />
    See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L240-L260"><code>README.md:240-260</code></a> for details.</p>
<p>Use Testcontainers when you want container lifecycle aligned with other infra; use embedded for lighter tests.</p>
<hr />
<h2>gRPC &amp; Protobuf</h2>
<h3>gRPC</h3>
<p><strong>Versions</strong></p>
<ul>
<li><code>grpcVersion=1.58.0</code> in <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L8-L11"><code>gradle.properties:8-11</code></a></li>
<li><code>grpcVersion=1.63.0</code> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L7-L8"><code>fit4j-examples/gradle.properties:7-8</code></a></li>
<li><code>grpcSpringBootVersion=3.1.0.RELEASE</code> in both <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L6-L9"><code>gradle.properties:6-9</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L2-L3"><code>fit4j-examples/gradle.properties:2-3</code></a></li>
</ul>
<p><strong>Dependencies</strong></p>
<ul>
<li>gRPC core: <code>io.grpc:grpc-*</code> – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L4-L8"><code>LICENSE-THIRD-PARTY.md:4-8</code></a></li>
<li>Spring Boot gRPC starter: <code>net.devh:grpc-spring-boot-starter</code> – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L4-L8"><code>LICENSE-THIRD-PARTY.md:4-8</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L7-L13"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:7-13</code></a></li>
</ul>
<p><strong>Usage</strong></p>
<p>The project supports FITs against gRPC endpoints:</p>
<ul>
<li>Request/response training for gRPC endpoints (see README feature list: <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L90-L120"><code>README.md:90-120</code></a>).</li>
<li>gRPC Spring Boot starter integrates gRPC servers into Spring Boot test contexts.</li>
</ul>
<p>When adding new gRPC tests, ensure:</p>
<ul>
<li>Proto definitions are compiled using <code>protobuf-java</code> version pinned in <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L7-L10"><code>gradle.properties:7-10</code></a>.</li>
<li>gRPC and gRPC Spring Boot versions remain compatible.</li>
</ul>
<h3>Protocol Buffers</h3>
<p><strong>Dependencies</strong></p>
<ul>
<li><code>com.google.protobuf:protobuf-java</code></li>
<li><code>com.google.protobuf:protobuf-java-util</code><br />
  Listed in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L29-L37"><code>LICENSE-THIRD-PARTY.md:29-37</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L11-L15"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:11-15</code></a>.</li>
</ul>
<p><strong>Version</strong></p>
<ul>
<li><code>protobufJavaVersion=3.21.2</code> in:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L7-L10"><code>gradle.properties:7-10</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L3-L4"><code>fit4j-examples/gradle.properties:3-4</code></a></li>
</ul>
<p>Used for:</p>
<ul>
<li>gRPC message definitions.</li>
<li>Serialization/deserialization in tests where binary protocol data is asserted.</li>
</ul>
<hr />
<h2>Resilience &amp; Utilities</h2>
<h3>Resilience4j</h3>
<p><strong>Dependency</strong></p>
<ul>
<li><code>io.github.resilience4j:resilience4j-*</code> – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L9-L13"><code>LICENSE-THIRD-PARTY.md:9-13</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L23-L27"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:23-27</code></a></li>
</ul>
<p>Resilience4j is typically used to wrap external calls (e.g. Kafka, HTTP, or DB) with:</p>
<ul>
<li>Circuit breakers</li>
<li>Retry policies</li>
<li>Time limiters</li>
</ul>
<p>In tests, you may need to configure or disable certain resilience components to avoid hiding exceptions.</p>
<h3>Common Utilities</h3>
<p>The stack includes several standard utility libraries:</p>
<ul>
<li><strong>Apache Commons Lang</strong> (<code>org.apache.commons:commons-lang3</code>) – <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L19"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-19</code></a></li>
<li><strong>SnakeYAML</strong> (<code>org.yaml:snakeyaml</code>) – used for YAML-based container definitions and initial data files; see <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L19"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-19</code></a>.</li>
<li><strong>ByteBuddy</strong> (<code>net.bytebuddy:byte-buddy</code>) – instrumentation and proxying, required by mocking and Testcontainers; <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L15-L19"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:15-19</code></a>.</li>
</ul>
<p>These are usually transitive dependencies and rarely configured directly, but they are foundational to the behavior of MockK, Testcontainers, and Spring Test.</p>
<hr />
<h2>Build &amp; Dependency Management</h2>
<h3>Gradle</h3>
<p>Primary build system with shared configuration via:</p>
<ul>
<li>Root <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L1-L11"><code>gradle.properties:1-11</code></a> for core library</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L1-L8"><code>fit4j-examples/gradle.properties:1-8</code></a> for examples</li>
</ul>
<p>Key properties:</p>
<pre><code class="language-properties"># See gradle.properties:1-11
group = io.github.harezmi
version = 0.0.12

springBootVersion=3.3.7
kotlinVersion=1.6.21
testcontainersVersion=1.15.3
grpcSpringBootVersion=3.1.0.RELEASE
mockkVersion=1.9.1
protobufJavaVersion=3.21.2
dynamoDBLocalVersion=2.2.1
grpcVersion=1.58.0
elasticSearchVersion=8.9.1
redisVersion=4.2.3
</code></pre>
<p>These properties should be consumed from module <a href="https://github.com/harezmi/fit4j/blob/main/build.gradle.kts"><code>build.gradle.kts</code></a>/<a href="https://github.com/harezmi/fit4j/blob/main/build.gradle"><code>build.gradle</code></a> via Gradle’s <code>extra</code> properties or <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties"><code>gradle.properties</code></a> lookup. When upgrading versions, update here first to keep modules consistent.</p>
<h3>Maven (Conceptual)</h3>
<p>Although Maven files are not shown in the snippets, the stack is Maven-compatible:</p>
<ul>
<li>Each Gradle property maps directly to a Maven <code>&lt;dependencyManagement&gt;</code> or <code>&lt;properties&gt;</code> entry.</li>
<li>If you create a Maven module, mirror these versions to avoid divergence.</li>
</ul>
<hr />
<h2>Configuration Files &amp; Environment Mapping</h2>
<p>Key configuration files for test infrastructure:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml"><code>src/test/resources/fit4j-test-containers.yml</code></a><br />
  Declarative container definitions for DB, Redis, Elasticsearch.</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml"><code>src/test/resources/fit4j-test-containers-sample.yml</code></a><br />
  Extended sample including Kafka and DynamoDB containers.</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties"><code>src/test/resources/application-test.properties</code></a><br />
  Bridges FIT4J/Testcontainers properties to Spring Boot properties; controls logging and Kafka serializers.</li>
</ul>
<p>Sensitive values (passwords, tokens) must always be masked in documentation and external configs:</p>
<ul>
<li>Example in docs (masking applied):</li>
</ul>
<p><code>yaml
  # Based on README.md:10-24
  username: root
  password: ********</code></p>
<p>When you add new containers or embedded services:</p>
<ol>
<li>Define them in a <code>fit4j-test-containers*.yml</code> file.</li>
<li>Expose properties needed by the service under test.</li>
<li>Map them into <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> (or test-specific <code>application-*.yml</code>).</li>
</ol>
<hr />
<h2>High-Level Dependency Overview</h2>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test code (FIT)"] --> step2["Spring Boot Test"]
 step2 --> step3["Testcontainers or Embedded"]
 step3 --> step4["External services (DB, Kafka, Redis, ES, DynamoDB)"]
</div></div>
<ul>
<li><strong>Test code (FIT)</strong>: Kotlin/JUnit tests annotated with <code>@FIT</code>, <code>@EnableEmbeddedKafka</code>, <code>@Testcontainers</code>.</li>
<li><strong>Spring Boot Test</strong>: Bootstraps the application context and test beans.</li>
<li><strong>Testcontainers or Embedded</strong>: Depending on annotations/config, either Docker-based containers or embedded servers are started.</li>
<li><strong>External services</strong>: Your system-under-test interacts with DB, Kafka, Redis, Elasticsearch, DynamoDB, which are all locally provisioned through the above layers.</li>
</ul>
<hr />
<h2>Where to Go Next</h2>
<ul>
<li>For term definitions (e.g., FIT, Container Definition, Embedded Mode), see <strong>[Glossary]</strong>.</li>
<li>For how these dependencies are used in concrete flows (e.g., Kafka publishing, DB initialization), see <strong>Execution Flow</strong> and <strong>External Integrations</strong> sections.</li>
<li>For configuration and environment details, see <strong>Configuration Guide</strong>.</li>
</ul>
  </div>
</section>


<section id="section-core-architecture" class="dw-section">
  <div class="dw-section-inner">
    <h1>Core Architecture &amp; Design Principles</h1>
<p>This page explains how Fit4J is structured internally and how its core components work together to support fixture‑driven integration testing. It focuses on layered autoconfiguration modules, fixture resolution, and how Fit4J plugs into Spring’s test lifecycle through <code>@IT</code> and <code>@FIT</code>.</p>
<hr />
<h2>High‑Level Architectural View</h2>
<p>At a high level, Fit4J builds on top of Spring Boot’s test infrastructure:</p>
<ul>
<li><strong>Base integration testing layer</strong> enabled by <code>@IT</code> (Integration Test).</li>
<li><strong>Full FIT environment</strong> enabled by <code>@FIT</code>, which extends <code>@IT</code> and adds:</li>
<li>Declarative and programmatic fixture support.</li>
<li>Centralized mock service response plumbing.</li>
<li>Call and message tracking across HTTP, gRPC, and Kafka.</li>
<li><strong>Autoconfiguration modules</strong> that provide:</li>
<li>Test helpers and DB utilities.</li>
<li>Mocking and call tracking infrastructure.</li>
<li>Fixture loading and resolution infrastructure.</li>
</ul>
<p>These are wired using Spring Boot <code>@AutoConfiguration</code> classes under <code>org.fit4j.autoconfigure</code>.</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test class with @FIT"] --> step2["Spring Boot test context"]
 step2 --> step3["@IT and @FIT autoconfigs"]
 step3 --> step4["Helpers, mocks, fixtures beans"]
</div></div>
<p>Autoconfiguration is gated by a custom condition annotation <code>@EnableOnFIT</code> so fixture/mocking infrastructure is only active when running FIT tests.</p>
<hr />
<h2>Annotations and Test Lifecyle Integration</h2>
<h3><code>@IT</code> – Base Integration Test Layer</h3>
<p><code>@IT</code> is a meta‑annotation used for ordinary integration tests. It centralizes several pieces of configuration traditionally repeated across test classes:</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ul>
<li>Activates Spring <code>test</code> profile.</li>
<li>Enables bean definition override in the <code>ApplicationContext</code>.</li>
<li>Runs gRPC server <strong>in-process</strong> at a random port and assigns a random in‑process name.</li>
<li>Auto‑configures <code>grpc.client.inProcess.address</code>.</li>
<li>Exposes <strong>Embedded Kafka</strong> as a Spring bean and property if <code>@EnableEmbeddedKafka</code> is present.</li>
<li>Exposes <strong>Embedded Redis</strong> as a Spring bean and property if <code>@EmbeddedRedis</code> is present.</li>
<li>Enables <strong>declarative Testcontainers</strong> support if <code>@Testcontainers</code> is used.</li>
</ul>
<p>This annotation is intended for:</p>
<ul>
<li>Service ↔ repository integration tests.</li>
<li>Controller ↔ service integration tests.</li>
<li>Tests that need infra but not the full fixture/trace ecosystem.</li>
</ul>
<p>Example usage (see <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>):</p>
<pre><code class="language-kotlin">// See src/test/kotlin/.../SampleIntegrationTest.kt:1-15 (conceptual example)
import org.fit4j.IntegrationTest
import org.junit.jupiter.api.Test

@IT
class SampleIntegrationTest {
    @Test
    fun `it should work`() {
        // normal integration assertions
    }
}
</code></pre>
<h3><code>@FIT</code> – Full Fixture‑Driven Integration Testing</h3>
<p><code>@FIT</code> inherits from <code>@IT</code> and <strong>adds the full FIT environment</strong>. According to <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ul>
<li>All <code>@IT</code> capabilities.</li>
<li>Programmatic and declarative <strong>request‑response trainings</strong> for external services.</li>
<li>Synchronous call and asynchronous <strong>message tracking</strong>.</li>
<li>Additional beans such as:</li>
<li><code>TestRestTemplate</code> (for web environment).</li>
<li>Google <code>JsonFormat</code> Printer/Parser as beans if on the classpath.</li>
<li>MockWebServer configuration and properties (<code>fit4j.mockWebServer.host</code>, <code>fit4j.mockWebServer.port</code>) if <code>okhttp3.mockwebserver</code> is on the classpath.</li>
<li>Test‑scoped beans for per‑test‑method isolation.</li>
</ul>
<p><code>@FIT</code> is designed for <strong>end‑to‑end flow tests</strong> that verify:</p>
<ul>
<li>Service behavior across external HTTP/gRPC calls.</li>
<li>Kafka message publishing and consumption.</li>
<li>State changes in DB/Redis and side‑effects.</li>
</ul>
<p>Fixture behavior (YAML vs programmatic) and training of external services are covered in more detail under “Fixture Resolution”.</p>
<hr />
<h2>Autoconfiguration Modules</h2>
<p>Fit4J uses Spring Boot autoconfiguration to assemble its test infrastructure. These are under <code>org.fit4j.autoconfigure</code>.</p>
<h3>Common Design Choices</h3>
<ul>
<li>Each module is an <code>@AutoConfiguration</code> class.</li>
<li>Most are annotated with <code>@EnableOnFIT</code> to activate only when the FIT environment is needed.</li>
<li><code>@ConditionalOnMissingBean</code> is used to allow overrides in user test configurations.</li>
<li>The configuration is <strong>test-scope oriented</strong>, meaning beans are built to suit test lifecycles (per run, per method) where appropriate.</li>
</ul>
<h3><code>TestMockAutoConfiguration</code></h3>
<p><a href="https://github.com/harezmi/fit4j/blob/main/org/fit4j/autoconfigure/TestMockAutoConfiguration.kt#L1-L35"><code>org/fit4j/autoconfigure/TestMockAutoConfiguration.kt:1-35</code></a> defines the core mock and call tracking infrastructure:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/autoconfigure/TestMockAutoConfiguration.kt:1-35
package org.fit4j.autoconfigure

import org.fit4j.context.ApplicationContextLifecycleListener
import org.fit4j.mock.CallTrace
import org.fit4j.mock.CallTraceFactory
import org.fit4j.mock.MockResponseFactory
import org.fit4j.mock.MockResponseProvider
import org.fit4j.mock.MockServiceCallTracker
import org.fit4j.mock.declarative.DeclarativeTestFixtureDrivenServiceResponseProvider
import org.springframework.boot.autoconfigure.AutoConfiguration
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.context.annotation.Bean
import org.springframework.core.env.ConfigurableEnvironment

@AutoConfiguration
@EnableOnFIT
class TestMockAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    fun applicationContextLifecycleListener(): ApplicationContextLifecycleListener {
        return ApplicationContextLifecycleListener()
    }

    @Bean
    fun mockServiceCallTracker(
        callTaceFactoryList: List&lt;CallTraceFactory&lt;*, *, *&gt;&gt;
    ): MockServiceCallTracker {
        @Suppress(&quot;UNCHECKED_CAST&quot;)
        return MockServiceCallTracker(
            callTaceFactoryList as List&lt;CallTraceFactory&lt;Any, Any, CallTrace&lt;*, *&gt;&gt;&gt;
        )
    }

    @Bean
    fun mockServiceResponseFactory(
        mockResponseProviderList: List&lt;MockResponseProvider&gt;,
        configurableEnvironment: ConfigurableEnvironment
    ): MockResponseFactory {
        // implementation omitted in snippet
    }
}
</code></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li><code>ApplicationContextLifecycleListener</code></li>
<li>Observes Spring <code>ApplicationContext</code> lifecycle events.</li>
<li>Used to reset tracking or re‑initialize mocks between tests, keeping the test environment deterministic.</li>
<li>Ensures declarative fixtures are loaded at the right time in the lifecycle.</li>
<li><code>MockServiceCallTracker</code></li>
<li>Central registry for all external service calls made during tests.</li>
<li>Built from a list of <code>CallTraceFactory</code> implementations, one per protocol/type (e.g. HTTP, gRPC).</li>
<li>Allows assertions on:<ul>
<li>“Was endpoint X called with payload Y?”</li>
<li>“How many times was Kafka topic Z published?”</li>
</ul>
</li>
<li><code>MockResponseFactory</code></li>
<li>Aggregates multiple <code>MockResponseProvider</code> implementations:<ul>
<li>Declarative fixture‑driven providers.</li>
<li>Programmatic providers.</li>
</ul>
</li>
<li>Uses <code>ConfigurableEnvironment</code> to access properties that influence response selection (e.g. fixture file location, environment flags).</li>
<li>Acts as a single point to resolve “what should this external call return during this test?”.</li>
</ul>
<p>This module is where <strong>protocol‑level concerns</strong> and <strong>fixture‑level concerns</strong> converge: call traces + response resolution.</p>
<h3><code>TestFixtureAutoConfiguration</code></h3>
<p><a href="https://github.com/harezmi/fit4j/blob/main/org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt#L1-L35"><code>org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt:1-35</code></a> is dedicated to declarative fixtures:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt:1-35
package org.fit4j.autoconfigure

import com.fasterxml.jackson.databind.ObjectMapper
import org.fit4j.mock.declarative.DeclarativeTestFixtureBuilder
import org.fit4j.mock.declarative.DeclarativeTestFixtureDrivenServiceResponseProvider
import org.fit4j.mock.declarative.DeclarativeTestFixtureProvider
import org.fit4j.mock.declarative.ExpressionResolver
import org.fit4j.mock.declarative.JsonContentExpressionResolver
import org.fit4j.mock.declarative.JsonToMockResponseConverter
import org.fit4j.mock.declarative.PredicateEvaluator
import org.springframework.boot.autoconfigure.AutoConfiguration
import org.springframework.context.ApplicationContext
import org.springframework.context.annotation.Bean

@AutoConfiguration
@EnableOnFIT
class TestFixtureAutoConfiguration {

    @Bean
    fun declarativeTestFixtureServiceResponseProvider(
        declarativeTestFixtureProvider: DeclarativeTestFixtureProvider,
        jsonToMockResponseConverterList: List&lt;JsonToMockResponseConverter&gt;
    ): DeclarativeTestFixtureDrivenServiceResponseProvider {
        return DeclarativeTestFixtureDrivenServiceResponseProvider(
            jsonToMockResponseConverterList,
            declarativeTestFixtureProvider
        )
    }

    @Bean
    fun declarativeTestFixtureProvider(
        applicationContext: ApplicationContext,
        declarativeTestFixtureBuilders: List&lt;DeclarativeTestFixtureBuilder&gt;
    ): DeclarativeTestFixtureProvider {
        // implementation omitted in snippet
    }

    @Bean
    fun predicateEvaluator(): PredicateEvaluator {
        // implementation omitted in snippet
    }

    @Bean
    fun expressionResolver(objectMapper: ObjectMapper): ExpressionResolver {
        return JsonContentExpressionResolver(objectMapper)
    }
}
</code></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li><code>DeclarativeTestFixtureProvider</code></li>
<li>Loads fixture definitions from YAML (or other supported sources) once.</li>
<li>Uses a list of <code>DeclarativeTestFixtureBuilder</code> components to map raw fixture definitions into internal structures.</li>
<li>Injected with <code>ApplicationContext</code> to:<ul>
<li>Resolve beans if needed for advanced fixture logic.</li>
<li>Locate resources (e.g. <code>classpath:...</code> fixture files).</li>
</ul>
</li>
<li><code>DeclarativeTestFixtureDrivenServiceResponseProvider</code></li>
<li>Implements <code>MockResponseProvider</code>.</li>
<li>Uses:<ul>
<li><code>DeclarativeTestFixtureProvider</code> to obtain defined fixtures.</li>
<li><code>JsonToMockResponseConverter</code> instances to convert fixture JSON into typed mock responses for different protocol handlers.</li>
</ul>
</li>
<li>Participates in <code>MockResponseFactory</code> resolution chain.</li>
<li><code>PredicateEvaluator</code> and <code>ExpressionResolver</code></li>
<li>Support <strong>conditional fixtures</strong>, e.g. “if request.body.userId == '123' then respond with fixture A”.</li>
<li><code>JsonContentExpressionResolver</code> uses Jackson <code>ObjectMapper</code> to evaluate expressions over JSON payloads.</li>
</ul>
<p>Given the test (<a href="https://github.com/harezmi/fit4j/blob/main/DeclarativeTestFixtureDataProviderFIT.kt#L1-L30"><code>DeclarativeTestFixtureDataProviderFIT.kt:1-30</code></a>):</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt:1-30
@FIT
class DeclarativeTestFixtureDataProviderFIT {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Autowired
    private lateinit var declarativeTestFixtureBuilders: List&lt;DeclarativeTestFixtureBuilder&gt;

    private lateinit var provider: DeclarativeTestFixtureProvider

    @Autowired
    private lateinit var predicateEvaluator: PredicateEvaluator

    @Autowired
    private lateinit var expressionResolver: ExpressionResolver

    @BeforeEach
    fun setUp() {
        provider = DeclarativeTestFixtureProvider(
            applicationContext,
            declarativeTestFixtureBuilders,
            &quot;classpath:fit4j-fixtures-sample.yml&quot;
        )
    }

    @Test
    fun `fixtures are resolved correctly`() {
        // test logic omitted
    }
}
</code></pre>
<p>You can see how the provider is typically constructed via autoconfiguration, but can also be manually instantiated for tests.</p>
<h3><code>TestHelperAutoConfiguration</code></h3>
<p><a href="https://github.com/harezmi/fit4j/blob/main/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt#L1-L40"><code>org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt:1-40</code></a> wires helper utilities:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt:1-40
package org.fit4j.autoconfigure

import com.fasterxml.jackson.databind.ObjectMapper
import com.google.protobuf.util.JsonFormat
import org.fit4j.dbcleanup.DatabaseTestSupport
import org.fit4j.dbcleanup.DatabaseTestSupportForH2
import org.fit4j.dbcleanup.DatabaseTestSupportForMysql
import org.fit4j.dbcleanup.DatabaseTestSupportForPostgreSQL
import org.fit4j.dbcleanup.NoopDatabaseTestSupport
import org.fit4j.helper.JsonHelper
import org.fit4j.helper.VerificationHelper
import org.fit4j.kafka.KafkaMessageTracker
import org.fit4j.mock.MockServiceCallTracker
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.autoconfigure.AutoConfiguration
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
</code></pre>
<p><em>(rest of the file is not in the snippet but can be inferred)</em></p>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Configure <code>DatabaseTestSupport</code> based on available DB drivers:</li>
<li><code>DatabaseTestSupportForH2</code></li>
<li><code>DatabaseTestSupportForMysql</code></li>
<li><code>DatabaseTestSupportForPostgreSQL</code></li>
<li>Fallback <code>NoopDatabaseTestSupport</code></li>
<li>Provide <code>JsonHelper</code> and <code>VerificationHelper</code>:</li>
<li>Simplify JSON assertions and transformations.</li>
<li>Offer high‑level APIs to verify DB, Kafka, and external calls in tests.</li>
<li>Register a central <code>KafkaMessageTracker</code>:</li>
<li>Tracks published/consumed Kafka messages.</li>
<li>Used by verification helpers for message‑driven flows.</li>
<li>Bind <code>MockServiceCallTracker</code> into helper layer:</li>
<li>Helpers can use call traces to build higher‑level assertions.</li>
</ul>
<p><code>JsonFormat</code> (from gRPC) is also exposed as a bean <strong>when on the classpath and with <code>@FIT</code></strong> (see <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> capabilities table), allowing conversion between JSON and Protobuf for both fixtures and assertions.</p>
<hr />
<h2>Fixture Definition and Resolution</h2>
<p>Fit4J supports <strong>two complementary strategies</strong> for fixtures:</p>
<ol>
<li><strong>Declarative fixtures</strong> in YAML.</li>
<li><strong>Programmatic fixtures</strong> via <code>@TestConfiguration</code> or dedicated providers.</li>
</ol>
<p>According to <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ul>
<li><em>Declarative fixtures</em>:</li>
<li>Defined in a YAML file.</li>
<li>Loaded once by the test infrastructure.</li>
<li>Shared across test classes: <strong>ApplicationContext is not recreated per test class</strong>, which:<ul>
<li>Increases speed.</li>
<li>Reduces memory usage (especially with Testcontainers).</li>
</ul>
</li>
<li>
<p>Recommended when possible.</p>
</li>
<li>
<p><em>Programmatic fixtures</em>:</p>
</li>
<li>Typically defined in a <code>@TestConfiguration</code> within a test package.</li>
<li>Cause Spring <code>ApplicationContext</code> to be <strong>recreated for each test class</strong> that imports them.</li>
<li>Provide maximum flexibility when fixture logic is complex or dynamic.</li>
</ul>
<h3>Declarative Fixture Flow</h3>
<p>End‑to‑end, the flow for declarative fixtures in a <code>@FIT</code> test looks like this:</p>
<ol>
<li><strong>Context bootstrap</strong></li>
<li>Test is annotated with <code>@FIT</code>.</li>
<li><code>@FIT</code> implies <code>@IT</code>, causing:<ul>
<li>Base infra (profiles, in‑process gRPC, embedded Kafka, etc.) to be configured.</li>
</ul>
</li>
<li>
<p><code>EnableOnFIT</code>‑gated autoconfigurations are activated:</p>
<ul>
<li><code>TestFixtureAutoConfiguration</code></li>
<li><code>TestMockAutoConfiguration</code></li>
<li><code>TestHelperAutoConfiguration</code></li>
</ul>
</li>
<li>
<p><strong>Fixture provider initialization</strong></p>
</li>
<li><code>DeclarativeTestFixtureProvider</code> is created:<ul>
<li>Uses <code>ApplicationContext</code> and <code>DeclarativeTestFixtureBuilder</code> beans.</li>
<li>Locates YAML fixture resources (e.g. <code>classpath:fit4j-fixtures.yml</code>).</li>
</ul>
</li>
<li>
<p>Raw YAML is parsed and transformed into internal fixture descriptions.</p>
</li>
<li>
<p><strong>Response provider wiring</strong></p>
</li>
<li><code>DeclarativeTestFixtureDrivenServiceResponseProvider</code> is created:<ul>
<li>Injected with <code>DeclarativeTestFixtureProvider</code> and a list of <code>JsonToMockResponseConverter</code>s.</li>
</ul>
</li>
<li>
<p>This provider is added to <code>MockResponseFactory</code> via <code>mockResponseProviderList</code>.</p>
</li>
<li>
<p><strong>Test execution</strong></p>
</li>
<li>An external call made by the system under test hits a protocol‑specific interceptor/handler.</li>
<li>The handler asks <code>MockResponseFactory</code> for a response; the factory:<ul>
<li>Queries providers in order.</li>
<li><code>DeclarativeTestFixtureDrivenServiceResponseProvider</code> evaluates:</li>
<li>Matching rules via <code>PredicateEvaluator</code> and <code>ExpressionResolver</code>.</li>
<li>Appropriate fixture entries for the request payload.</li>
<li>Builds a mock response using <code>JsonToMockResponseConverter</code>.</li>
</ul>
</li>
<li>
<p>Simultaneously, <code>MockServiceCallTracker</code> records the call trace.</p>
</li>
<li>
<p><strong>Assertion</strong></p>
</li>
<li>Test uses:<ul>
<li><code>MockServiceCallTracker</code> (and helper wrappers) to assert calls.</li>
<li><code>KafkaMessageTracker</code> to assert Kafka behavior.</li>
<li>DB helpers to assert persisted data.</li>
</ul>
</li>
<li>Declarative fixture YAML is <strong>never reloaded</strong> in the same test context, ensuring performance.</li>
</ol>
<h3>Programmatic Fixture Flow</h3>
<p>When fixtures are defined programmatically:</p>
<ul>
<li>A <code>@TestConfiguration</code> or manual <code>MockResponseProvider</code> bean is defined in the test module.</li>
<li>Spring creates a dedicated ApplicationContext for each test class using that configuration.</li>
<li><code>MockResponseFactory</code> composes both declarative and programmatic providers if both exist.</li>
</ul>
<p>Constraints and trade‑off (per <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>):</p>
<ul>
<li>More flexible but slower for large suites.</li>
<li>Can increase resource usage in Testcontainers‑heavy environments.</li>
</ul>
<hr />
<h2>Spring Test Lifecycle Integration</h2>
<p>Fit4J’s design hinges on deep integration with Spring’s test lifecycle:</p>
<ul>
<li><strong>Context lifecycle listener</strong> (<code>ApplicationContextLifecycleListener</code>):</li>
<li>Tracks ApplicationContext start/stop events.</li>
<li>Likely:<ul>
<li>Clears call/message trackers when the context is reset.</li>
<li>Ensures fixture definitions are built at the correct lifecycle phase.</li>
</ul>
</li>
<li><strong>Test‑scoped beans</strong>:</li>
<li>Some beans are scoped per test method in <code>@FIT</code> scenarios to:<ul>
<li>Prevent cross‑test pollution (stateful mocks).</li>
<li>Preserve deterministic behavior when tests run in parallel.</li>
</ul>
</li>
<li><strong>Environment‑aware configuration</strong>:</li>
<li>Most autoconfiguration beans accept <code>ConfigurableEnvironment</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/TestMockAutoConfiguration.kt#L19-L31"><code>TestMockAutoConfiguration.kt:19-31</code></a>).</li>
<li>Environment properties used by Fit4J include (from <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> examples):<ul>
<li><code>fit4j.mockWebServer.host</code></li>
<li><code>fit4j.mockWebServer.port</code></li>
<li><code>spring.kafka.bootstrap-servers</code></li>
</ul>
</li>
<li>These are used by:<ul>
<li>Client stubs in the test context.</li>
<li>Fixture resolution, when environment‑dependent behavior is required.</li>
</ul>
</li>
</ul>
<h3>Interaction with Spring Boot Test Features</h3>
<p>Fit4J does not replace Spring Boot test features; it composes them:</p>
<ul>
<li><code>@SpringBootTest</code> is still used (implicitly via <code>@IT</code>/<code>@FIT</code>).</li>
<li>Web environment:</li>
<li><code>@FIT(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code>:<ul>
<li>Adds TestRestTemplate and full HTTP stack.</li>
<li>Keeps all FIT tracking and fixture features.</li>
</ul>
</li>
</ul>
<hr />
<h2>Package / Module Structure</h2>
<p>From the snippets, the main conceptual layers:</p>
<ul>
<li><strong>Autoconfiguration Layer</strong> (<code>org.fit4j.autoconfigure</code>):</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/TestMockAutoConfiguration.kt"><code>TestMockAutoConfiguration.kt</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/TestFixtureAutoConfiguration.kt"><code>TestFixtureAutoConfiguration.kt</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/TestHelperAutoConfiguration.kt"><code>TestHelperAutoConfiguration.kt</code></a></li>
<li><strong>Context / Lifecycle Layer</strong> (<code>org.fit4j.context</code>):</li>
<li><code>ApplicationContextLifecycleListener</code></li>
<li><strong>Mocking / Tracing Layer</strong> (<code>org.fit4j.mock.*</code>):</li>
<li><code>MockServiceCallTracker</code>, <code>MockResponseFactory</code>, <code>MockResponseProvider</code></li>
<li><code>CallTrace</code>, <code>CallTraceFactory</code></li>
<li><strong>Declarative Fixture Layer</strong> (<code>org.fit4j.mock.declarative.*</code>):</li>
<li><code>DeclarativeTestFixtureProvider</code>, <code>DeclarativeTestFixtureBuilder</code></li>
<li><code>DeclarativeTestFixtureDrivenServiceResponseProvider</code></li>
<li><code>JsonToMockResponseConverter</code></li>
<li><code>ExpressionResolver</code>, <code>JsonContentExpressionResolver</code></li>
<li><code>PredicateEvaluator</code></li>
<li><strong>Helper Layer</strong> (<code>org.fit4j.helper</code>, <code>org.fit4j.dbcleanup</code>, <code>org.fit4j.kafka</code>):</li>
<li><code>JsonHelper</code>, <code>VerificationHelper</code></li>
<li><code>DatabaseTestSupport*</code></li>
<li><code>KafkaMessageTracker</code></li>
</ul>
<p>This maps to a <strong>layered test infrastructure design</strong>:</p>
<ul>
<li>Bottom: Integration with DB, Kafka, gRPC, HTTP (infra).</li>
<li>Middle: Cross‑cutting trackers &amp; fixtures (mocking, traces).</li>
<li>Top: Convenience helpers and annotations (<code>@IT</code>, <code>@FIT</code>).</li>
</ul>
<hr />
<h2>Configuration and Properties</h2>
<p>While many properties are auto‑set by autoconfiguration, the following patterns are important:</p>
<ul>
<li><strong>gRPC in‑process configuration</strong> (driven by <code>@IT</code>):</li>
<li>A random in‑process server name and port are chosen.</li>
<li>Property like <code>grpc.client.inProcess.address</code> is auto‑configured.</li>
<li>
<p>Clients using <code>@GrpcClient("inProcess")</code> (or equivalent) are wired to the in‑process server.</p>
</li>
<li>
<p><strong>Kafka configuration</strong>:</p>
</li>
<li>When <code>@EnableEmbeddedKafka</code> or equivalent is present:<ul>
<li>Embedded Kafka broker is exposed as a bean.</li>
<li><code>spring.kafka.bootstrap-servers</code> is set to embedded broker address.</li>
</ul>
</li>
<li>
<p>Fit4J tracks messages through <code>KafkaMessageTracker</code>.</p>
</li>
<li>
<p><strong>MockWebServer configuration</strong>:</p>
</li>
<li>If <code>okhttp3.mockwebserver.MockWebServer</code> is available:<ul>
<li>A <code>MockWebServer</code> bean is exposed.</li>
<li>Environment properties:</li>
<li><code>fit4j.mockWebServer.host</code></li>
<li><code>fit4j.mockWebServer.port</code></li>
</ul>
</li>
<li>
<p>HTTP clients can read from these properties to call the mock server instead of real endpoints.</p>
</li>
<li>
<p><strong>DynamoDB, Redis, Testcontainers</strong>:</p>
</li>
<li>Annotations like <code>@EmbeddedDynamoDB</code>, <code>@EmbeddedRedis</code>, and <code>@Testcontainers</code> trigger corresponding beans and support.</li>
<li>Fit4J autoconfigs are designed to respect these when present.</li>
</ul>
<p>Example test <a href="https://github.com/harezmi/fit4j/blob/main/application.yml"><code>application.yml</code></a> excerpt (values masked):</p>
<pre><code class="language-yaml"># See src/test/resources/application.yml:1-20
spring:
  profiles:
    active: test

fit4j:
  fixtures:
    location: classpath:fit4j-fixtures.yml
  kafka:
    verificationEnabled: true

grpc:
  client:
    inProcess:
      address: in-process://********
</code></pre>
<hr />
<h2>Design Principles Recap</h2>
<ol>
<li>
<p><strong>Composition over customization</strong><br />
   Fit4J composes Spring Boot’s test features instead of re‑implementing them, using autoconfiguration and conditional beans.</p>
</li>
<li>
<p><strong>Fixture‑first design</strong><br />
   Declarative YAML fixtures are preferred for repeatable, fast tests; programmatic fixtures exist for advanced needs.</p>
</li>
<li>
<p><strong>Protocol‑agnostic tracing</strong><br />
   The <code>CallTraceFactory</code>/<code>MockServiceCallTracker</code> pattern allows adding new protocols (e.g. MQTT, proprietary) without changing core architecture.</p>
</li>
<li>
<p><strong>Environment‑aware behavior</strong><br />
   Autoconfig classes read <code>ConfigurableEnvironment</code> and annotations to enable features only when relevant.</p>
</li>
<li>
<p><strong>Fast feedback with shared context</strong><br />
   Declarative fixtures and shared ApplicationContext keep the suite fast, particularly important when combined with Testcontainers.</p>
</li>
</ol>
<p>For term definitions (e.g. “fixture”, “call trace”, “training”), see <strong>[Glossary]</strong>.</p>
  </div>
</section>


<section id="section-spring-test-context-integration" class="dw-section">
  <div class="dw-section-inner">
    <h1>Spring Test Context &amp; Extension Integration</h1>
<p>This page explains how Fit4J integrates with the Spring TestContext Framework and JUnit 5. It covers the custom context factories, context customizers, and the <code>Fit4JTestExtension</code> that together orchestrate embedded infrastructure, dynamic properties, and test-scoped metadata.</p>
<hr />
<h2>Overview</h2>
<p>Fit4J builds on Spring’s TestContext Framework to:</p>
<ul>
<li>Automatically attach additional <code>ContextCustomizer</code>s for FIT/IT-style tests.</li>
<li>Inject dynamic, test-aware properties into the <code>ApplicationContext</code>.</li>
<li>Wire embedded infrastructure (Kafka, Redis, DynamoDB, HTTP server, Testcontainers, etc.).</li>
<li>Expose test metadata (class, method) into the Spring environment.</li>
<li>Coordinate all of this with JUnit 5 via <code>Fit4JTestExtension</code>.</li>
</ul>
<p>At a high level:</p>
<ul>
<li><strong>ContextCustomizerFactory</strong> implementations decide <em>when</em> to apply a given customizer (usually based on annotations and classpath checks).</li>
<li><strong>ContextCustomizer</strong> implementations actually mutate the <code>ConfigurableApplicationContext</code> (properties, parent context, beans).</li>
<li><strong>Fit4JTestExtension</strong> sets up the current test context so that context customizers can read test metadata and expose it as properties.</li>
</ul>
<hr />
<h2>High-Level Flow</h2>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["JUnit 5 runs test"] --> step2["Spring builds context"]
 step2 --> step3["Fit4J factories select customizers"]
 step3 --> step4["Customizers tweak ApplicationContext"]
 step4 --> step5["Fit4JTestExtension exposes test metadata"]
 step5 --> step6["Tests use embedded infra and props"]
</div></div>
<hr />
<h2>AbstractContextCustomizerFactory: Central Dispatch</h2>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/AbstractContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/AbstractContextCustomizerFactory.kt</code></a></p>
<p><code>AbstractContextCustomizerFactory</code> is the base for all Fit4J factories that plug into Spring’s <code>ContextCustomizerFactory</code> SPI.</p>
<p>Key aspects (see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/AbstractContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/AbstractContextCustomizerFactory.kt</code></a>):</p>
<ul>
<li>Declares:</li>
</ul>
<p><code>kotlin
  abstract fun buildContextCustomizer(
      testClass: Class&lt;*&gt;,
      configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
  ): ContextCustomizer?</code></p>
<ul>
<li>
<p>Implements <code>createContextCustomizer(...)</code> from Spring’s <code>ContextCustomizerFactory</code> and delegates to <code>buildContextCustomizer(...)</code>.</p>
</li>
<li>
<p>Provides helper utilities (inferred from usage in subclasses):</p>
</li>
<li><code>isAnnotationPresent(testClass, annotationClass)</code> – checks for a given annotation, often via <code>AnnotatedElementUtils</code>.</li>
<li><code>isClassPresent("fqcn")</code> – checks classpath presence (used for optional integrations such as DynamoDB local).</li>
<li>Likely filters on Fit4J-specific annotations such as <code>@IT</code> and/or <code>@FIT</code> from <code>org.fit4j.annotation.IT</code> (see import in <code>AbstractContextCustomizerFactory</code>).</li>
</ul>
<p><strong>Why it exists</strong></p>
<ul>
<li>Centralizes common selection logic and helper methods for all Fit4J context customizer factories.</li>
<li>Ensures that customizers are only created for relevant tests (e.g., those tagged with Fit4J annotations).</li>
<li>Keeps individual factories focused on a single responsibility (embedded Kafka, HTTP server, etc.).</li>
</ul>
<hr />
<h2>Fit4JTestContextCustomizerFactory &amp; Fit4JTestContextCustomizer</h2>
<h3>Factory</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizerFactory.kt</code></a></p>
<pre><code class="language-kotlin">class Fit4JTestContextCustomizerFactory : AbstractContextCustomizerFactory() {

    companion object {
        val customizer = Fit4JTestContextCustomizer()
    }

    override fun buildContextCustomizer(
        testClass: Class&lt;*&gt;,
        configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
    ): ContextCustomizer {
        return customizer
    }
}
</code></pre>
<ul>
<li>Always returns a singleton <code>Fit4JTestContextCustomizer</code>.</li>
<li>Because it extends <code>AbstractContextCustomizerFactory</code>, Spring will invoke it whenever building a test <code>ApplicationContext</code>.</li>
</ul>
<h3>Customizer</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizer.kt</code></a></p>
<p>Core responsibilities (see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizer.kt</code></a>):</p>
<ol>
<li><strong>Log customization</strong></li>
</ol>
<p><code>kotlin
   logger.debug("${this.javaClass.simpleName} is customizing ApplicationContext")</code></p>
<ol>
<li><strong>Create dynamic property suppliers</strong></li>
</ol>
<p>```kotlin
   val supplierMap = mutableMapOf&lt;String, Supplier&lt;*&gt;&gt;()</p>
<p>supplierMap["fit4j.testClass.name"] = Supplier {
       Fit4JTestContextManager.getTestClassName()
   }
   supplierMap["fit4j.testClass.simpleName"] = Supplier {
       Fit4JTestContextManager.getTestClassSimpleName()
   }
   ```</p>
<ol>
<li><strong>Attach a parent application context</strong></li>
</ol>
<p><code>kotlin
   context.parent = ParentApplicationContextFactory.parentApplicationContext</code></p>
<ol>
<li><strong>Attach dynamic property source</strong></li>
</ol>
<p><code>kotlin
   context.environment.propertySources.addAfter(
       "Inlined Test Properties",
       DynamicValuesPropertySource("fit4j-test-property-source", supplierMap)
   )</code></p>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestContextCustomizer.kt</code></a> for full implementation).</p>
<p><strong>Why this matters</strong></p>
<ul>
<li>
<p>Makes test metadata (test class name, simple name) available to the Spring environment:</p>
</li>
<li>
<p><code>fit4j.testClass.name</code></p>
</li>
<li><code>fit4j.testClass.simpleName</code></li>
</ul>
<p>These can be used in:
  - <code>@Value("\${fit4j.testClass.name}")</code>
  - YAML/properties for logging, routing, or fixture selection.</p>
<ul>
<li>Delegates to <code>ParentApplicationContextFactory</code> for shared test infrastructure (e.g., common beans or fixtures reused across test contexts).</li>
<li>Uses <code>DynamicValuesPropertySource</code> so properties are <em>evaluated lazily</em> via <code>Supplier</code>s and always reflect the current JUnit context provided by <code>Fit4JTestExtension</code>.</li>
</ul>
<hr />
<h2>Fit4JTestContextManager: Bridge Between JUnit and Spring</h2>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestContextManager.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestContextManager.kt</code></a></p>
<p>The <code>Fit4JTestContextManager</code> exposes static methods to retrieve current test metadata from <code>Fit4JTestExtension</code>:</p>
<pre><code class="language-kotlin">class Fit4JTestContextManager {
    companion object {
        @JvmStatic
        fun getTestClassSimpleName(): String? {
            return getTestClass()?.simpleName
        }

        @JvmStatic
        fun getTestClassName(): String? {
            return getTestClass()?.name
        }

        @JvmStatic
        fun getTestMethodName(): String? {
            return currentExtensionContext?.testMethod?.get()?.name
        }

        @JvmStatic
        fun getTestClass(): Class&lt;*&gt;? {
            return currentExtensionContext?.requiredTestClass
        }

        // Additional helpers (not fully shown):
        // fun storeRequest(HttpRequest) ...
        // fun getRequest(): HttpRequest? ...
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestContextManager.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestContextManager.kt</code></a> for details).</p>
<p><strong>Integration point</strong></p>
<ul>
<li>Relies on <code>Fit4JTestExtension.Companion.currentExtensionContext</code>.</li>
<li>This is how <code>Fit4JTestContextCustomizer</code> knows what test is currently running when it computes dynamic properties.</li>
</ul>
<hr />
<h2>Fit4JTestExtension: JUnit 5 Lifecycle Orchestrator</h2>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestExtension.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestExtension.kt</code></a></p>
<pre><code class="language-kotlin">class Fit4JTestExtension : BeforeAllCallback,
    AfterAllCallback,
    BeforeEachCallback,
    BeforeTestExecutionCallback,
    AfterTestExecutionCallback,
    TestExecutionExceptionHandler {

    companion object {
        /*
        Tests are started to run on the client side, and ExtensionContext is set there.
        */
        // val currentExtensionContext: ExtensionContext? = ...
    }

    // beforeAll, beforeEach, beforeTestExecution, afterTestExecution, afterAll, handleTestExecutionException...
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/Fit4JTestExtension.kt"><code>src/main/kotlin/org/fit4j/context/Fit4JTestExtension.kt</code></a> for full implementation).</p>
<p><strong>What it does</strong></p>
<ul>
<li>Implements multiple JUnit 5 callbacks:</li>
<li><code>BeforeAllCallback</code>, <code>AfterAllCallback</code> – per–test-class lifecycle.</li>
<li><code>BeforeEachCallback</code>, <code>BeforeTestExecutionCallback</code>, <code>AfterTestExecutionCallback</code> – per-test-method lifecycle.</li>
<li>
<p><code>TestExecutionExceptionHandler</code> – central place to react to test exceptions.</p>
</li>
<li>
<p>Manages a static reference <code>currentExtensionContext</code> used by <code>Fit4JTestContextManager</code> to supply test metadata to Spring.</p>
</li>
</ul>
<p><strong>Typical lifecycle</strong></p>
<ol>
<li><strong>BeforeAll</strong> of a test class:</li>
<li>Sets <code>currentExtensionContext</code> to the class context.</li>
<li>
<p>Optionally pre-loads or configures parent application context.</p>
</li>
<li>
<p><strong>BeforeEach / BeforeTestExecution</strong>:</p>
</li>
<li>Updates <code>currentExtensionContext</code> for each test method.</li>
<li>
<p>Possibly records an initial <code>HttpRequest</code> or fixture state (see imports in <code>Fit4JTestContextManager</code>).</p>
</li>
<li>
<p><strong>AfterTestExecution / AfterAll</strong>:</p>
</li>
<li>Cleans up test-specific data from context.</li>
<li>
<p>May coordinate with <code>ApplicationContextLifecycleListener</code> (created in auto-config) to reset or validate state.</p>
</li>
<li>
<p><strong>TestExecutionExceptionHandler</strong>:</p>
</li>
<li>Handles assertion failures or infrastructure errors uniformly.</li>
<li>Could be used to enrich error reporting with Fit4J-specific context (call traces, HTTP exchanges).</li>
</ol>
<p><strong>Why this matters</strong></p>
<ul>
<li>This extension is the <em>glue</em> that keeps JUnit’s understanding of “current test” synchronized with Spring’s dynamic configuration.</li>
<li>Without it, the <code>fit4j.testClass.*</code> properties would be null or stale, and context customizers wouldn’t be able to adapt per test.</li>
</ul>
<hr />
<h2>Embedded Infrastructure Context Customizers</h2>
<p>Fit4J provides several concrete <code>ContextCustomizerFactory</code> implementations backed by context customizers that wire embedded infrastructure into the test <code>ApplicationContext</code>. All of them extend <code>AbstractContextCustomizerFactory</code>, so they can participate in the same selection pipeline.</p>
<h3>Embedded Kafka</h3>
<p><strong>Factory</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedKafkaContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedKafkaContextCustomizerFactory.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class EmbeddedKafkaContextCustomizerFactory : AbstractContextCustomizerFactory() {
    companion object {
        val customizer = EmbeddedKafkaContextCustomizer()
        val customizer2 = EnableEmbeddedKafkaContextCustomizer()
    }
    override fun buildContextCustomizer(
        testClass: Class&lt;*&gt;,
        configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
    ): ContextCustomizer? {
        val enableEmbeddedKafkaExists =
            isAnnotationPresent(testClass, EnableEmbeddedKafka::class.java)
        // ... choose customizer or null based on annotations
    }
}
</code></pre>
<ul>
<li>Uses:</li>
<li>Fit4J-specific <code>@EnableEmbeddedKafka</code> (<code>org.fit4j.kafka.EnableEmbeddedKafka</code>).</li>
<li>
<p>Spring Kafka’s <code>@EmbeddedKafka</code> (<code>org.springframework.kafka.test.context.EmbeddedKafka</code>).</p>
</li>
<li>
<p>Selects either:</p>
</li>
<li><code>EmbeddedKafkaContextCustomizer</code> – when using Spring’s embedded Kafka.</li>
<li><code>EnableEmbeddedKafkaContextCustomizer</code> – when using Fit4J’s own annotation.</li>
<li><code>null</code> if no relevant annotation is present.</li>
</ul>
<p><strong>Customizer</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedKafkaContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedKafkaContextCustomizer.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">open class EmbeddedKafkaContextCustomizer : ContextCustomizer {
    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)
    override fun customizeContext(context: ConfigurableApplicationContext, mergedConfig: MergedContextConfiguration) {
        logger.debug(&quot;${this.javaClass.simpleName} is customizing ApplicationContext&quot;)

        context.environment.propertySources.addAfter(
            &quot;Inlined Test Properties&quot;,
            MapPropertySource(
                &quot;fit4j-embedded-kafka-property-source&quot;,
                mapOf(
                    &quot;spring.kafka.bootstrap-servers&quot; to &quot;\${spring.embedded.kafka.brokers}&quot;
                )
            )
        )
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedKafkaContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedKafkaContextCustomizer.kt</code></a>).</p>
<p><strong>Effect on configuration</strong></p>
<ul>
<li>Adds a property source mapping:</li>
</ul>
<p><code>properties
  spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}</code></p>
<ul>
<li>This means:</li>
<li>Your <code>KafkaTemplate</code> and other Kafka clients can use <code>spring.kafka.bootstrap-servers</code>.</li>
<li>The actual broker endpoints come from the Spring embedded Kafka test support (<code>spring.embedded.kafka.brokers</code>).</li>
</ul>
<p>No credentials are embedded here; Kafka is assumed to be unsecured for tests.</p>
<hr />
<h3>Embedded DynamoDB</h3>
<p><strong>Factory</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizerFactory.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class EmbeddedDynamoDBContextCustomizerFactory : AbstractContextCustomizerFactory() {
    companion object {
        val customizer = EmbeddedDynamoDBContextCustomizer()
    }
    override fun buildContextCustomizer(
        testClass: Class&lt;*&gt;,
        configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
    ): ContextCustomizer? {
        return if (
            isClassPresent(&quot;com.amazonaws.services.dynamodbv2.local.embedded.DynamoDBEmbedded&quot;)
            &amp;&amp; isAnnotationPresent(testClass, EmbeddedDynamoDB::class.java)
        ) customizer
        else null
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizerFactory.kt</code></a>).</p>
<ul>
<li>Only activates when:</li>
<li>The local DynamoDB implementation (<code>DynamoDBEmbedded</code>) is on the classpath.</li>
<li>The test class is annotated with <code>@EmbeddedDynamoDB</code> (<code>org.fit4j.dynamodb.EmbeddedDynamoDB</code>).</li>
</ul>
<p><strong>Customizer</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class EmbeddedDynamoDBContextCustomizer : ContextCustomizer {
    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)

    override fun customizeContext(context: ConfigurableApplicationContext, mergedConfig: MergedContextConfiguration) {
        logger.debug(&quot;${this.javaClass.simpleName} is customizing ApplicationContext&quot;)
        // Register local DynamoDB client, beans, teardown hooks, etc.
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedDynamoDBContextCustomizer.kt</code></a>).</p>
<p><strong>Why this matters</strong></p>
<ul>
<li>Provides fully in-memory/local DynamoDB for tests without changing production configuration.</li>
<li>The factory’s <code>isClassPresent</code> check prevents failures when the DynamoDB local dependency is not part of the project.</li>
</ul>
<hr />
<h3>Embedded Redis</h3>
<p><strong>Factory</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedRedisContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedRedisContextCustomizerFactory.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class EmbeddedRedisContextCustomizerFactory : AbstractContextCustomizerFactory() {
    override fun buildContextCustomizer(
        testClass: Class&lt;*&gt;,
        configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
    ): ContextCustomizer? {
        return if (isAnnotationPresent(testClass, EmbeddedRedis::class.java))
            EmbeddedRedisContextCustomizer(
                AnnotationUtils.findAnnotation(testClass, EmbeddedRedis::class.java)!!
            )
        else null
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/EmbeddedRedisContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/EmbeddedRedisContextCustomizerFactory.kt</code></a>).</p>
<ul>
<li>Activates when a test class is annotated with <code>@EmbeddedRedis</code> (<code>org.fit4j.redis.EmbeddedRedis</code>).</li>
<li>Uses <code>AnnotationUtils.findAnnotation</code> to retrieve annotation arguments for configuration (e.g., port, database index) and passes them to <code>EmbeddedRedisContextCustomizer</code>.</li>
</ul>
<p><strong>Customizer</strong></p>
<ul>
<li><code>EmbeddedRedisContextCustomizer</code> is not shown in the snippet, but typically:</li>
<li>Starts embedded Redis before the context is fully refreshed.</li>
<li>Sets Redis host/port properties.</li>
<li>Registers teardown callbacks so Redis stops after tests.</li>
</ul>
<hr />
<h3>HTTP Web Server</h3>
<p><strong>Factory</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/HttpWebServerContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/HttpWebServerContextCustomizerFactory.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class HttpWebServerContextCustomizerFactory : AbstractContextCustomizerFactory() {
    companion object {
        val httpServerCustomizer = HttpServerContextCustomizer()
    }
    override fun buildContextCustomizer(
        testClass: Class&lt;*&gt;,
        configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
    ): ContextCustomizer? {
        return httpServerCustomizer
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/HttpWebServerContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/HttpWebServerContextCustomizerFactory.kt</code></a>).</p>
<ul>
<li>Always returns a singleton <code>HttpServerContextCustomizer</code>.</li>
<li>Likely limited to Fit4J-enabled tests via <code>AbstractContextCustomizerFactory</code> logic (e.g., <code>@FIT</code> or <code>@IT</code> check).</li>
</ul>
<p><strong>Customizer</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class HttpServerContextCustomizer : ContextCustomizer {
    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)

    override fun customizeContext(context: ConfigurableApplicationContext, mergedConfig: MergedContextConfiguration) {
        registerHttpServer(context)
    }

    private fun registerHttpServer(context: ConfigurableApplicationContext) {
        // Typically:
        // - start HttpServerWrapper on random port
        // - register beans in DefaultListableBeanFactory
        // - add MapPropertySource with http server base URL
        // - register DisposableBean for shutdown
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt"><code>src/main/kotlin/org/fit4j/context/HttpServerContextCustomizer.kt</code></a>).</p>
<p>Typical effects:</p>
<ul>
<li>Starts a local HTTP server via <code>HttpServerWrapper</code>.</li>
<li>Registers the server and its URL as beans/properties so tests and application code can call it.</li>
<li>Ensures proper teardown through <code>DisposableBean</code> and <code>DefaultListableBeanFactory</code>.</li>
</ul>
<p><strong>Configuration impact</strong></p>
<p>You might see properties like:</p>
<pre><code class="language-properties">fit4j.http.server.base-url=http://localhost:${fit4j.http.server.port}
</code></pre>
<p>Any sensitive headers or tokens should be configured via environment variables or externalized configuration, and must be masked if shown in documentation (e.g., <code>Authorization: Bearer token-****</code>).</p>
<hr />
<h3>Testcontainers</h3>
<p><strong>Factory</strong></p>
<ul>
<li><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/TestContainersContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/TestContainersContextCustomizerFactory.kt</code></a></li>
</ul>
<pre><code class="language-kotlin">class TestContainersContextCustomizerFactory : AbstractContextCustomizerFactory() {
    override fun buildContextCustomizer(
        testClass: Class&lt;*&gt;,
        configAttributes: MutableList&lt;ContextConfigurationAttributes&gt;
    ): ContextCustomizer? {
        return if (isAnnotationPresent(testClass, org.fit4j.testcontainers.Testcontainers::class.java)) {
            val definitions = findDefinitions(testClass)
            TestContainersContextCustomizer(true, definitions)
        } else null
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/context/TestContainersContextCustomizerFactory.kt"><code>src/main/kotlin/org/fit4j/context/TestContainersContextCustomizerFactory.kt</code></a>).</p>
<ul>
<li>Activates when test is annotated with <code>@org.fit4j.testcontainers.Testcontainers</code>.</li>
<li><code>findDefinitions(testClass)</code> scans for container definitions (e.g., <code>TestContainerDefinition</code> beans or configuration classes).</li>
<li><code>TestContainersContextCustomizer</code> then:</li>
<li>Starts required containers.</li>
<li>Injects host/port into Spring properties.</li>
<li>Ensures containers are properly re-used or shut down between tests.</li>
</ul>
<p><strong>Example usage</strong></p>
<p>In <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/TestContainersContextCustomizerWithAnnotationFIT.kt"><code>src/test/kotlin/org/fit4j/testcontainers/TestContainersContextCustomizerWithAnnotationFIT.kt</code></a>:</p>
<pre><code class="language-kotlin">@FIT
@Testcontainers
@Disabled
class TestContainersContextCustomizerWithAnnotationFIT {

    @Autowired(required = false)
    private var testContainerDefinitions: List&lt;TestContainerDefinition&gt;? = null

    @TestConfiguration
    class TestConfig {
        // container definitions, listeners, etc.
    }
}
</code></pre>
<hr />
<h2>ApplicationContextLifecycleListener and Auto-Configuration Hooks</h2>
<p>Fit4J uses Spring Boot auto-configuration classes to install lifecycle listeners and test scopes that work in concert with the context customizers.</p>
<h3>TestMockAutoConfiguration</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestMockAutoConfiguration.kt"><code>src/main/kotlin/org/fit4j/autoconfigure/TestMockAutoConfiguration.kt</code></a></p>
<pre><code class="language-kotlin">@AutoConfiguration
@EnableOnFIT
class TestMockAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean
    fun applicationContextLifecycleListener(
        // likely dependencies here
    ): ApplicationContextLifecycleListener {
        // create and return listener
    }

    @Bean
    fun mockResponseProvider(...): MockResponseProvider { ... }

    @Bean
    fun mockServiceCallTracker(...): MockServiceCallTracker { ... }

    // more mocking-related beans
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestMockAutoConfiguration.kt"><code>src/main/kotlin/org/fit4j/autoconfigure/TestMockAutoConfiguration.kt</code></a>).</p>
<ul>
<li><code>@EnableOnFIT</code> ensures this configuration only applies to Fit4J-enabled tests (see project-wide annotations).</li>
<li>Injects <code>ApplicationContextLifecycleListener</code> (from <code>org.fit4j.context</code>) that can:</li>
<li>React to <code>ApplicationContext</code> events (refresh, close).</li>
<li>Sync mock/fixture lifecycle with test lifecycle.</li>
<li>Supplies various mock-related beans (call trace, mock response factory, etc.) used by Fit4J tests.</li>
</ul>
<h3>TestScopeAutoConfiguration</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestScopeAutoConfiguration.kt"><code>src/main/kotlin/org/fit4j/autoconfigure/TestScopeAutoConfiguration.kt</code></a></p>
<pre><code class="language-kotlin">@AutoConfiguration
@EnableOnFIT
class TestScopeAutoConfiguration {
    companion object {
        @Bean
        fun testScope(): TestScope {
            return TestScope()
        }

        @Bean
        fun customScopeConfigurer(testScope: TestScope): CustomScopeConfigurer {
            return CustomScopeConfigurer().apply {
                addScope(&quot;test&quot;, testScope)
            }
        }
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestScopeAutoConfiguration.kt"><code>src/main/kotlin/org/fit4j/autoconfigure/TestScopeAutoConfiguration.kt</code></a>).</p>
<ul>
<li>Registers a custom Spring bean scope called <code>"test"</code>.</li>
<li>Beans declared with scope <code>"test"</code> are tied to the current Fit4J test context.</li>
<li>The scope is likely coordinated with <code>Fit4JTestExtension</code> and <code>ApplicationContextLifecycleListener</code>.</li>
</ul>
<hr />
<h2>Context Caching Considerations</h2>
<p>Fit4J’s integration is careful to play well with Spring’s <code>ApplicationContext</code> caching.</p>
<ul>
<li>In <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt"><code>src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt</code></a>, nested FIT tests validate that context caching works correctly when using Fit4J annotations.</li>
<li>In <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/context/ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt"><code>src/test/kotlin/org/fit4j/context/ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt</code></a>, similar checks are made for non-Fit tests (<code>@SpringBootTest</code>, profiles, etc.).</li>
</ul>
<p><strong>Why it matters</strong></p>
<ul>
<li>Excessive context customization can break cache keys and cause unnecessary context rebuilds.</li>
<li>Fit4J’s customizers:</li>
<li>Avoid injecting non-deterministic values directly into the <code>MergedContextConfiguration</code>.</li>
<li>Rely on lazy <code>DynamicValuesPropertySource</code> so caching remains predictable while properties still adapt dynamically at runtime.</li>
</ul>
<p>From a user perspective:</p>
<ul>
<li>Multiple tests with identical configuration (same annotations, profiles, property sources) will share the same cached context, even when using Fit4J.</li>
<li>Per-test variability is achieved via:</li>
<li>Test scope (<code>"test"</code>).</li>
<li>JUnit extension state.</li>
<li>Dynamic property suppliers.</li>
</ul>
<hr />
<h2>Practical Usage Patterns</h2>
<h3>Enabling Fit4J Features in Tests</h3>
<p>Fit4J-specific features (custom scopes, mocks, embedded infrastructure) are usually enabled via annotations:</p>
<ul>
<li><code>@FIT</code> or <code>@IT</code> – Fit4J integration marker for tests.</li>
<li><code>@EmbeddedKafka</code>, <code>@EnableEmbeddedKafka</code> – for Kafka.</li>
<li><code>@EmbeddedRedis</code> – for Redis.</li>
<li><code>@EmbeddedDynamoDB</code> – for DynamoDB Local.</li>
<li><code>@org.fit4j.testcontainers.Testcontainers</code> – for Testcontainers integration.</li>
</ul>
<p>Because the factories rely on <code>isAnnotationPresent</code>, adding or removing these annotations directly affects which customizers are applied.</p>
<h3>Accessing Test Metadata Inside Beans</h3>
<p>Any Spring bean can access current test metadata:</p>
<pre><code class="language-kotlin">@Component
class ExampleBean(
    @Value(&quot;\${fit4j.testClass.name:unknown}&quot;) private val testClassName: String
) {
    fun logContext() {
        logger.info(&quot;Running in test class: $testClassName&quot;)
    }
}
</code></pre>
<p>Configuration snippet:</p>
<pre><code class="language-properties">logging.pattern.level=%5p [${fit4j.testClass.simpleName:NoTest}] :
</code></pre>
<p>This allows logs and behavior to change depending on the test class, while still sharing a cached <code>ApplicationContext</code>.</p>
<hr />
<h2>Configuration Notes and Security</h2>
<ul>
<li>All added properties are in-memory and test-only. They <strong>must not</strong> contain real credentials or secrets.</li>
<li>When referencing external services in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> or <a href="https://github.com/harezmi/fit4j/blob/main/application-test.yml"><code>application-test.yml</code></a> with Fit4J, use masked values in any shared documentation:</li>
</ul>
<p><code>properties
  external.service.base-url=https://sandbox.example.com
  external.service.api-key=api-key-****
  external.service.password=********</code></p>
<ul>
<li>Kafka and embedded services typically run without authentication for tests. If you configure any secured endpoints, ensure tokens/passwords are externalized and masked when shown in docs or logs.</li>
</ul>
<hr />
<h2>Where to Look Next</h2>
<ul>
<li>For term definitions like <code>FIT</code>, <code>IT</code>, <code>TestScope</code>, <code>ApplicationContextLifecycleListener</code>, see <strong>[Glossary]</strong>.</li>
<li>For embedded Kafka, Redis, DynamoDB, and Testcontainers usage from test code, see the <strong>External Integrations/Data Flow</strong> section.</li>
<li>For mock/fixture behavior (CallTrace, MockResponseProvider), see the <strong>Testing</strong> or <strong>Fixture/Mocking</strong> sections.</li>
</ul>
  </div>
</section>


<section id="section-database-and-entity-model" class="dw-section">
  <div class="dw-section-inner">
    <h1>Database &amp; Entity Model</h1>
<p>This section explains how databases are modeled and managed in tests. It covers the <code>DatabaseTestSupport</code> abstraction and concrete implementations for H2, MySQL, and PostgreSQL, as well as the DynamoDB <code>PlayerItem</code> entity used in example tests. The focus is both on <em>how</em> the test infrastructure cleans and resets state, and <em>how</em> entities are modeled in relational and DynamoDB scenarios.</p>
<hr />
<h2>Overview</h2>
<p>The test infrastructure provides:</p>
<ul>
<li>A common <code>DatabaseTestSupport</code> SPI for database cleanup and inspection.</li>
<li>An <code>AbstractDatabaseTestSupport</code> base class that encapsulates transaction and schema handling.</li>
<li>Concrete implementations:</li>
<li><code>DatabaseTestSupportForH2</code> for in‑memory H2 databases.</li>
<li><code>DatabaseTestSupportForMysql</code> for MySQL.</li>
<li><code>DatabaseTestSupportForPostgreSQL</code> for PostgreSQL.</li>
<li><code>NoopDatabaseTestSupport</code> for disabling cleanup.</li>
<li>Example DynamoDB entities and schemas (e.g., <code>PlayerItem</code>) used in FIT tests with and without Testcontainers.</li>
</ul>
<p>These pieces ensure that each test method runs with a clean database state and predictable identifier/sequence values.</p>
<hr />
<h2>Core Database Support Abstractions</h2>
<h3><code>DatabaseTestSupport</code> interface</h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupport.kt#L1-L13"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupport.kt:1-13</code></a></p>
<pre><code class="language-kotlin">package org.fit4j.dbcleanup

import java.sql.Connection

interface DatabaseTestSupport {
    fun resetAllIdentifiers()
    fun clearAllTables()
    fun openDBConsole()
    fun connection() : Connection
}
</code></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>
<p><code>resetAllIdentifiers()</code><br />
  Reset auto‑increment columns or sequences so that primary keys start from a known baseline (typically 1) after each test.</p>
</li>
<li>
<p><code>clearAllTables()</code><br />
  Truncate or delete from all application tables so each test starts with an empty schema.</p>
</li>
<li>
<p><code>openDBConsole()</code><br />
  Database‑specific implementation to open a DB console (e.g., H2 web console) for debugging.</p>
</li>
<li>
<p><code>connection(): Connection</code><br />
  Returns a live JDBC connection for low‑level debugging or adhoc SQL.</p>
</li>
</ul>
<p>This SPI allows tests to interact with the database infrastructure without knowing the specific RDBMS.</p>
<hr />
<h3><code>AbstractDatabaseTestSupport</code> base class</h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/AbstractDatabaseTestSupport.kt#L1-L34"><code>src/main/kotlin/org/fit4j/dbcleanup/AbstractDatabaseTestSupport.kt:1-34</code></a></p>
<pre><code class="language-kotlin">abstract class AbstractDatabaseTestSupport(
    val dataSource: DataSource,
    val transactionManager: PlatformTransactionManager,
    val cleanupEnabled:Boolean = true
) : DatabaseTestSupport {

    override fun resetAllIdentifiers() {
        resetAllIdentifiers(dataSource, transactionManager, schemaName())
    }

    override fun clearAllTables() {
        // ...
        // delegate into executeClearAllTables(jdbcTemplate, schemaName)
    }

    abstract fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String)
    abstract fun executeClearAllTables(jdbcTemplate: JdbcTemplate, schemaName: String)
    abstract fun schemaName(): String

    @AfterTestMethod
    fun doCleanUp() {
        if (cleanupEnabled) {
            this.clearAllTables()
            this.resetAllIdentifiers()
        }
    }
}
</code></pre>
<p><strong>Key design points:</strong></p>
<ul>
<li>Injects <code>DataSource</code> and <code>PlatformTransactionManager</code> so cleanup runs inside Spring‑managed transactions.</li>
<li>The public methods <code>resetAllIdentifiers()</code> and <code>clearAllTables()</code> delegate to abstract <code>execute*</code> methods that subclasses implement with dialect‑specific SQL.</li>
<li><code>schemaName()</code> lets each implementation decide which schema to operate on (e.g., <code>"PUBLIC"</code> for H2 vs. a named schema in PostgreSQL).</li>
<li><code>@AfterTestMethod doCleanUp()</code> ensures that <strong>after every test method</strong>:</li>
<li>All tables are cleared.</li>
<li>All identifiers are reset.<br />
  This guarantees deterministic primary key values in subsequent tests.</li>
</ul>
<p><strong>Why this matters:</strong><br />
Tests like <code>DatabaseTestSupportCheckingTestSuite</code> rely on predictable primary key values (e.g., first insert gets <code>id=1</code> after every test). This determinism simplifies assertions and reduces flakiness.</p>
<hr />
<h3>No-op implementation</h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/NoopDatabaseTestSupport.kt#L1-L19"><code>src/main/kotlin/org/fit4j/dbcleanup/NoopDatabaseTestSupport.kt:1-19</code></a></p>
<pre><code class="language-kotlin">class NoopDatabaseTestSupport : DatabaseTestSupport {
    override fun resetAllIdentifiers() {
    }

    override fun clearAllTables() {
    }

    override fun openDBConsole() {
    }

    override fun connection(): Connection {
        throw NotImplementedError()
    }
}
</code></pre>
<p>Use <code>NoopDatabaseTestSupport</code> when:</p>
<ul>
<li>You do not want automatic cleanup (e.g., performance‑sensitive suites).</li>
<li>The tests manage data lifecycle explicitly.</li>
<li>There is no relational DB involved (e.g., pure unit tests).</li>
</ul>
<p>Note that <code>connection()</code> is intentionally unsupported here.</p>
<hr />
<h2>Relational Database Implementations</h2>
<p>Each implementation extends <code>AbstractDatabaseTestSupport</code> and provides:</p>
<ul>
<li>A DB‑specific <code>executeResetAllIdentifiers(...)</code>.</li>
<li>A DB‑specific <code>executeClearAllTables(...)</code> (not fully shown in snippets but implied).</li>
</ul>
<h3>H2: <code>DatabaseTestSupportForH2</code></h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForH2.kt#L1-L18"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForH2.kt:1-18</code></a></p>
<pre><code class="language-kotlin">class DatabaseTestSupportForH2(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager,
    cleanupEnabled:Boolean = true
) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {

    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        val tablesWithPKColumns = jdbcTemplate.queryForList(&quot;&quot;&quot;
            SELECT 
                t.table_name,
                k.column_name,
                c.is_identity
            -- ...
        &quot;&quot;&quot;.trimIndent())
        // logic to reset IDENTITY columns based on H2 metadata
    }
}
</code></pre>
<p><strong>Behavior:</strong></p>
<ul>
<li>Uses H2 metadata (<code>information_schema</code>) to discover tables with primary keys and identify IDENTITY columns (<code>c.is_identity</code>).</li>
<li>Resets IDENTITY values so that subsequent inserts restart from the initial value (usually 1).</li>
<li>Likely uses H2‑specific commands such as <code>ALTER TABLE ... ALTER COLUMN ... RESTART WITH 1</code> or similar.</li>
</ul>
<p><strong>Usage in tests:</strong></p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportCheckingTestSuite.kt#L18-L31"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportCheckingTestSuite.kt:18-31</code></a></p>
<pre><code class="language-kotlin">@Test
fun `populate db`() {
    Assertions.assertTrue(databaseTestSupport is DatabaseTestSupportForH2)
    Assertions.assertEquals(0, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;select count(*) from my_foo&quot;))
    jdbcTemplate.update(&quot;insert into my_foo(name) values ('Foo')&quot;)
    jdbcTemplate.update(&quot;insert into my_foo(name) values ('Bar')&quot;)
    Assertions.assertEquals(1, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;select id from my_foo where name = 'Foo'&quot;))
    Assertions.assertEquals(2, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;select id from my_foo where name = 'Bar'&quot;))

    Assertions.assertEquals(0, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;select count(*) from my_foo2&quot;))
}
</code></pre>
<p>This verifies:</p>
<ul>
<li>Tables start empty at test start.</li>
<li>IDs are sequential and reset appropriately across test methods due to <code>doCleanUp()</code>.</li>
</ul>
<hr />
<h3>MySQL: <code>DatabaseTestSupportForMysql</code></h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForMySQL.kt#L1-L31"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForMySQL.kt:1-31</code></a></p>
<pre><code class="language-kotlin">class DatabaseTestSupportForMysql(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager,
    cleanupEnabled:Boolean = true
) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {

    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        // Query tables with their PK columns and auto-increment status
        val tablesWithPKColumns = jdbcTemplate.queryForList(&quot;&quot;&quot;
            SELECT 
                t.table_name,
                k.column_name,
                c.extra
            FROM information_schema.tables t
            JOIN information_schema.table_constraints tc 
                ON t.table_name = tc.table_name
                AND t.table_schema = tc.table_schema
                AND tc.constraint_type = 'PRIMARY KEY'
            JOIN information_schema.key_column_usage k 
            -- ...
        &quot;&quot;&quot;.trimIndent())
        // logic to reset AUTO_INCREMENT values
    }
}
</code></pre>
<p><strong>Behavior:</strong></p>
<ul>
<li>Reads MySQL <code>information_schema</code> to find tables with primary keys and detect <code>AUTO_INCREMENT</code> columns (via <code>c.extra</code>).</li>
<li>For each auto‑increment PK, it likely issues <code>ALTER TABLE &lt;table&gt; AUTO_INCREMENT = 1</code> or an equivalent reset.</li>
<li><code>executeClearAllTables</code> (not shown) typically uses <code>TRUNCATE TABLE</code> for each application table in the given schema.</li>
</ul>
<p><strong>Verification test:</strong></p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt#L30-L41"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt:30-41</code></a></p>
<pre><code class="language-kotlin">@Test
fun `verify tables are cleared and sequences are reset`() {
    Assertions.assertTrue(databaseTestSupport is DatabaseTestSupportForMysql)
    // Verify my_foo table is empty and AUTO_INCREMENT is reset
    Assertions.assertEquals(0, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;SELECT COUNT(*) FROM my_foo&quot;))
    jdbcTemplate.update(&quot;INSERT INTO my_foo(name) VALUES ('Foo')&quot;)
    jdbcTemplate.update(&quot;INSERT INTO my_foo(name) VALUES ('Bar')&quot;)
    // Auto-increment should start from 1 again
    Assertions.assertEquals(1, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;SELECT id FROM my_foo WHERE name = 'Foo'&quot;))
    Assertions.assertEquals(2, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;SELECT id FROM my_foo WHERE name = 'Bar'&quot;))

    // Verify my_users table is empty and AUTO_INCREMENT is reset
    // (similar checks as above)
}
</code></pre>
<p><strong>Configuration with Testcontainers (example):</strong></p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt#L1-L24"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt:1-24</code></a></p>
<pre><code class="language-kotlin">@FIT
@Testcontainers(definitions = [&quot;mySQLContainerDefinition&quot;])
@TestPropertySource(properties = [
    &quot;spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver&quot;,
    &quot;spring.datasource.url=\${fit4j.mySQLContainerDefinition.jdbcUrl}&quot;,
    &quot;spring.datasource.username=\${fit4j.mySQLContainerDefinition.username}&quot;,
    &quot;spring.datasource.password=\${fit4j.mySQLContainerDefinition.password}&quot;
])
class MySQLFIT { /* ... */ }
</code></pre>
<p>All actual password values are provided by Testcontainers configuration properties; keep them masked in any docs or logs (e.g., <code>password=********</code>).</p>
<hr />
<h3>PostgreSQL: <code>DatabaseTestSupportForPostgreSQL</code></h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForPostgreSQL.kt#L1-L17"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForPostgreSQL.kt:1-17</code></a></p>
<pre><code class="language-kotlin">class DatabaseTestSupportForPostgreSQL(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager,
    cleanupEnabled:Boolean = true
) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {

    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        // Query all sequences from both information_schema and pg_catalog to ensure complete coverage
        val sequenceNames = jdbcTemplate.queryForList(
            &quot;&quot;&quot;
                SELECT sequence_name 
                FROM information_schema.sequences 
                -- plus pg_catalog queries...
            &quot;&quot;&quot;.trimIndent()
        )
        // logic to reset sequences (e.g., ALTER SEQUENCE ... RESTART WITH 1)
    }
}
</code></pre>
<p><strong>Behavior:</strong></p>
<ul>
<li>Aggregates sequence names from both <code>information_schema.sequences</code> and <code>pg_catalog</code> to cover:</li>
<li>Explicitly created sequences.</li>
<li>Sequences created implicitly for <code>SERIAL</code>/<code>BIGSERIAL</code> columns.</li>
<li>Resets each sequence (likely via <code>ALTER SEQUENCE &lt;schema&gt;.&lt;name&gt; RESTART WITH 1</code> or using <code>setval</code>).</li>
<li>Works closely with <code>executeClearAllTables</code> to ensure no residual rows remain before sequence reset.</li>
</ul>
<p><strong>Sample Testcontainers configuration:</strong></p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L31-L43"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:31-43</code></a></p>
<pre><code class="language-kotlin">@Nested
@Order(2)
@FIT
@Testcontainers(definitions = [&quot;postgreSQLContainerDefinition&quot;])
@TestPropertySource(properties = [
    &quot;spring.datasource.driver-class-name=org.postgresql.Driver&quot;,
    &quot;spring.datasource.url=\${fit4j.postgreSQLContainerDefinition.jdbcUrl}&quot;,
    &quot;spring.datasource.username=\${fit4j.postgreSQLContainerDefinition.username}&quot;,
    &quot;spring.datasource.password=\${fit4j.postgreSQLContainerDefinition.password}&quot;
])
inner class SecondFIT {
    // ...
}
</code></pre>
<p><strong>Verification test:</strong></p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L45-L55"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:45-55</code></a></p>
<pre><code class="language-kotlin">@Test
fun `verify tables are cleared and sequences are reset`() {
    Assertions.assertTrue(databaseTestSupport is DatabaseTestSupportForPostgreSQL)
    // Verify my_foo table is empty and SERIAL sequence is reset
    Assertions.assertEquals(0, jdbcTemplate.queryForObject&lt;Int&gt;(&quot;SELECT COUNT(*) FROM my_foo&quot;))
    jdbcTemplate.update(&quot;INSERT INTO my_foo(name) VALUES ('Foo')&quot;)
    jdbcTemplate.update(&quot;INSERT INTO my_foo(name) VALUES ('Bar')&quot;)
    // Sequence should start from 1 again
    Assertions.assertEquals(1, jdbcTemplate.queryForObject&lt;Long&gt;(&quot;SELECT id FROM my_foo WHERE name = 'Foo'&quot;))
}
</code></pre>
<hr />
<h2>DynamoDB Entity Model</h2>
<p>Relational DBs are not the only persistence modeled in this repository. The DynamoDB examples demonstrate how FIT tests can be written against a NoSQL store using AWS SDK v1’s object mapper.</p>
<h3><code>PlayerItem</code> DynamoDB entity</h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/PlayerItem.kt#L1-L29"><code>fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/PlayerItem.kt:1-29</code></a></p>
<pre><code class="language-kotlin">@DynamoDBTable(tableName = &quot;PlayerTable&quot;)
class PlayerItem {
    @get:DynamoDBHashKey(attributeName = &quot;PK&quot;)
    var pK: String? = null

    @get:DynamoDBRangeKey(attributeName = &quot;SK&quot;)
    var sK: String? = null

    @get:DynamoDBAttribute(attributeName = &quot;id&quot;)
    var id: Long? = null

    // Additional attributes, converters and timestamps
    // e.g. createdAt, updatedAt, custom converters via @DynamoDBTypeConverted
}
</code></pre>
<p><strong>Modeling choices:</strong></p>
<ul>
<li><strong>Table name:</strong> <code>"PlayerTable"</code> (configured via <code>@DynamoDBTable</code>).</li>
<li><strong>Primary key:</strong>  </li>
<li>Hash key: <code>PK</code> mapped to <code>pK</code>.  </li>
<li>
<p>Range key: <code>SK</code> mapped to <code>sK</code>.<br />
  This enables composite keys like <code>"PLAYER#1"</code> / <code>"PLAYER#1"</code>.</p>
</li>
<li>
<p><strong>Attributes:</strong>  </p>
</li>
<li><code>id</code> is stored as a separate attribute (not the primary key), which can be used as a business identifier.</li>
<li>
<p>The class is designed to be used with DynamoDBMapper, so it follows the Java bean style with mutable properties.</p>
</li>
<li>
<p><strong>Converters:</strong><br />
  Annotations like <code>@DynamoDBTypeConverted</code> and <code>DynamoDBTypeConverter</code> (imported in the file) are used to map non‑primitive types (e.g., <code>Timestamp</code>, <code>UUID</code>) to DynamoDB string/number formats.</p>
</li>
</ul>
<h3>DynamoDB schema and setup in tests</h3>
<p>Example: classic (non‑Testcontainers) DynamoDB FIT</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L40-L66"><code>fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:40-66</code></a></p>
<pre><code class="language-kotlin">val createTableRequest = CreateTableRequest()
    .withTableName(&quot;PlayerTable&quot;)
    .withKeySchema(
        KeySchemaElement().withAttributeName(&quot;PK&quot;).withKeyType(KeyType.HASH),
        KeySchemaElement().withAttributeName(&quot;SK&quot;).withKeyType(KeyType.RANGE)
    )
    .withAttributeDefinitions(
        AttributeDefinition().withAttributeName(&quot;PK&quot;).withAttributeType(&quot;S&quot;),
        AttributeDefinition().withAttributeName(&quot;SK&quot;).withAttributeType(&quot;S&quot;)
    )
    .withBillingMode(&quot;PROVISIONED&quot;)
    .withProvisionedThroughput(ProvisionedThroughput(1L, 1L))
    .withStreamSpecification(
        StreamSpecification()
            .withStreamEnabled(true)
            .withStreamViewType(StreamViewType.NEW_AND_OLD_IMAGES)
    )
    .withSSESpecification(
        SSESpecification()
            .withEnabled(true)
            .withSSEType(SSEType.KMS)
            .withKMSMasterKeyId(&quot;&quot;) // masked in docs
    )
amazonDynamoDB.createTable(createTableRequest)
</code></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>The key schema and attributes match the annotations on <code>PlayerItem</code>.</li>
<li>Streams and SSE are enabled for demonstration purposes; in real systems, configure KMS key IDs securely (mask them in docs as <code>kmsKeyId=********</code>).</li>
</ul>
<h3>DynamoDB Example test flow</h3>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L68-L96"><code>fit4j-examples/example-dynamodb/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:68-96</code></a></p>
<pre><code class="language-kotlin">@AfterEach
fun tearDown() {
    amazonDynamoDB.deleteTable(&quot;PlayerTable&quot;)
}

@Test
fun `it should work`() {
    val playerItem1 = PlayerItem(1L, &quot;John Doe&quot;)
    val playerItem2 = PlayerItem(2L, &quot;Joe Doe&quot;)
    dynamoDBMapper.save(playerItem1)
    dynamoDBMapper.save(playerItem2)

    val playerItem1FromDB = dynamoDBMapper.load(
        PlayerItem::class.java,
        &quot;PLAYER#1&quot;, &quot;PLAYER#1&quot;
    )

    val playerItem2FromDB = dynamoDBMapper.load(
        PlayerItem::class.java,
        &quot;PLAYER#2&quot;, &quot;PLAYER#2&quot;
    )

    val playerItem3FromDB = dynamoDBMapper.load(
        PlayerItem::class.java,
        &quot;PLAYER#3&quot;, &quot;PLAYER#3&quot;
    )

    Assertions.assertEquals(playerItem1, playerItem1FromDB)
    Assertions.assertEquals(playerItem2, playerItem2FromDB)
    Assertions.assertNull(playerItem3FromDB)
}
</code></pre>
<p>Key aspects:</p>
<ul>
<li>The test itself implements lifecycle management (creating and deleting the <code>PlayerTable</code>) instead of using a generic <code>DatabaseTestSupport</code> abstraction.</li>
<li>The entity equality implies <code>PlayerItem</code> overrides <code>equals</code>/<code>hashCode</code> (or Kotlin data‑class semantics if applied elsewhere).</li>
<li>PK/SK values like <code>"PLAYER#1"</code> are derived from the logical <code>id</code> and/or name (the exact transformation happens in the <code>PlayerItem</code> implementation or a converter).</li>
</ul>
<p>The Testcontainers‑based example (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt#L40-L98"><code>fit4j-examples/example-dynamodb-testcontainers/src/test/kotlin/org/fit4j/examples/dynamodb/DynamoDBExampleFIT.kt:40-98</code></a>) mirrors the same pattern but uses a containerized DynamoDB (e.g., localstack or DynamoDB Local) instead of a purely mock or local endpoint.</p>
<hr />
<h2>Entity &amp; Support Relationship Diagram</h2>
<p>The following diagram summarizes the relationship between the core database support abstractions and the <code>PlayerItem</code> DynamoDB entity:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
classDiagram
 class DatabaseTestSupport {
 +resetAllIdentifiers()
 +clearAllTables()
 +openDBConsole()
 +connection()
 }
 class AbstractDatabaseTestSupport {
 +dataSource DataSource
 +transactionManager PlatformTransactionManager
 +cleanupEnabled Boolean
 +resetAllIdentifiers()
 +clearAllTables()
 +doCleanUp()
 }
 class DatabaseTestSupportForH2 {
 +executeResetAllIdentifiers()
 +executeClearAllTables()
 +schemaName()
 }
 class PlayerItem {
 +pK String
 +sK String
 +id Long
 }
 AbstractDatabaseTestSupport --|> DatabaseTestSupport : implements
 DatabaseTestSupportForH2 --|> AbstractDatabaseTestSupport : extends
 PlayerItem --> "PlayerTable" : stored in
</div></div>
<blockquote>
<p>Note: <code>"PlayerTable"</code> is conceptual in the diagram; the actual table name is configured by <code>@DynamoDBTable(tableName = "PlayerTable")</code>.</p>
</blockquote>
<hr />
<h2>Configuration Considerations</h2>
<h3>Spring DataSource configuration with Testcontainers</h3>
<p>Across the MySQL and PostgreSQL test suites, Testcontainers integration is driven via properties, for example:</p>
<p>File: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L31-L43"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:31-43</code></a></p>
<pre><code class="language-kotlin">@TestPropertySource(properties = [
    &quot;spring.datasource.driver-class-name=org.postgresql.Driver&quot;,
    &quot;spring.datasource.url=\${fit4j.postgreSQLContainerDefinition.jdbcUrl}&quot;,
    &quot;spring.datasource.username=\${fit4j.postgreSQLContainerDefinition.username}&quot;,
    &quot;spring.datasource.password=\${fit4j.postgreSQLContainerDefinition.password}&quot;
])
</code></pre>
<p><strong>Important:</strong></p>
<ul>
<li>
<p>All actual credentials and JDBC URLs are resolved from container definitions and must never be inlined into source or docs.<br />
  Example (redacted):<br />
<code>spring.datasource.url=jdbc:postgresql://localhost:5432/test?user=test&amp;password=********</code></p>
</li>
<li>
<p>The <code>cleanupEnabled</code> flag in each <code>DatabaseTestSupportFor…</code> constructor can be wired via Spring (e.g., a property) if you need to disable automatic cleanup in specific profiles.</p>
</li>
</ul>
<h3>DynamoDB Endpoint and Credentials</h3>
<p>The DynamoDB examples (both local and Testcontainers) typically configure:</p>
<ul>
<li>Endpoint (e.g., pointing to localstack or DynamoDB Local).</li>
<li>AWS credentials (access key, secret key) for the client.</li>
</ul>
<p>These are not present in the snippets but must always be masked in documentation and configuration examples:</p>
<pre><code class="language-properties">aws.dynamodb.endpoint=http://localhost:4566
aws.accessKeyId=AKIA****
aws.secretAccessKey=********
</code></pre>
<hr />
<h2>How to Extend to a New Database</h2>
<p>To support another relational database (e.g., Oracle or SQL Server):</p>
<ol>
<li><strong>Create a subclass</strong> of <code>AbstractDatabaseTestSupport</code> in <code>src/main/kotlin/org/fit4j/dbcleanup/</code>, e.g.:</li>
</ol>
<p>```kotlin
   class DatabaseTestSupportForSqlServer(
       dataSource: DataSource,
       transactionManager: PlatformTransactionManager,
       cleanupEnabled: Boolean = true
   ) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {</p>
<pre><code>   override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
       // Use sys.identity_columns or equivalent metadata
   }

   override fun executeClearAllTables(jdbcTemplate: JdbcTemplate, schemaName: String) {
       // TRUNCATE or DELETE tables in schema
   }

   override fun schemaName(): String = "dbo"
</code></pre>
<p>}
   ```</p>
<ol>
<li>
<p><strong>Configure Spring</strong> to autowire this implementation when the corresponding driver URL is used (typically via conditional configuration).</p>
</li>
<li>
<p><strong>Add a test suite</strong> similar to <code>DatabaseTestSupportForMySQLCheckingTestSuite</code> to validate:</p>
</li>
<li>Tables start empty.</li>
<li>Identifiers reset to 1 after each test.</li>
</ol>
<hr />
<h2>Summary</h2>
<ul>
<li><code>DatabaseTestSupport</code> and <code>AbstractDatabaseTestSupport</code> define a reusable pattern for test database cleanup across multiple RDBMS.</li>
<li>H2, MySQL, and PostgreSQL implementations differ mainly in how they query metadata and reset identifiers (IDENTITY, AUTO_INCREMENT, SEQUENCE).</li>
<li><code>NoopDatabaseTestSupport</code> is provided for contexts where automatic cleanup is not desired.</li>
<li><code>PlayerItem</code> demonstrates how DynamoDB entities are modeled and tested using <code>DynamoDBMapper</code>, with manual lifecycle management per test.</li>
<li>Test configuration relies on Spring <code>DataSource</code> properties (often fed by Testcontainers), and all credentials must be masked in configuration and documentation.</li>
</ul>
  </div>
</section>


<section id="section-indexing-and-performance" class="dw-section">
  <div class="dw-section-inner">
    <h1>Indexing, Data Initialization &amp; Performance</h1>
<p>This section explains how FIT4J initializes data for Redis and Elasticsearch in test environments and how that impacts test performance and isolation. It covers YAML-based initial data files, the <code>RedisDataPopulator</code> and <code>ElasticsearchDataPopulator</code> utilities, and how to wire them into Testcontainers and embedded setups.</p>
<hr />
<h2>Goals of Data Initialization</h2>
<p>YAML-driven initialization is used to:</p>
<ul>
<li>Make tests deterministic and self-contained.</li>
<li>Reduce boilerplate setup code in each test.</li>
<li>Improve performance by reusing containers with pre-loaded datasets when appropriate.</li>
<li>Control test isolation (fresh data per test suite vs. reused state across runs).</li>
</ul>
<p>The patterns described here are focused on <strong>test environments</strong>, not production.</p>
<hr />
<h2>Initial Data with Testcontainers</h2>
<h3>Container Definitions</h3>
<p>Testcontainers-based services are configured via YAML definitions such as <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L40"><code>src/test/resources/fit4j-test-containers.yml:1-40</code></a>.</p>
<p>Relevant sections:</p>
<pre><code class="language-yaml"># PostgreSQL (example – included for context)
- container: org.testcontainers.containers.PostgreSQLContainer
  name: postgresContainerDefinition
  image: postgres:latest
  username: postgres
  password: ********
  databaseName: testdb
  env:
    - TZ: &quot;UTC&quot;
    - POSTGRES_HOST_AUTH_METHOD: trust
  exposedProperties:
    - jdbcUrl
    - username
    - password
    - host
    - firstMappedPort
  reuse: false

# Redis with initScript
- container: org.testcontainers.containers.GenericContainer
  name: redisContainerDefinition
  image: redis:6.2.1
  initScript: scripts/redis_initial_data.yml
  exposedPorts:
    - 6379
  exposedProperties:
    - host
    - firstMappedPort
  reuse: false

# Elasticsearch with initScript
- container: org.testcontainers.elasticsearch.ElasticsearchContainer
  name: elasticSearchContainerDefinition
  image: docker.elastic.co/elasticsearch/elasticsearch:8.10.2
  initScript: scripts/elasticsearch_initial_data.yml
  exposedPorts:
    - 9200
    - 9300
  env:
    - ELASTICSEARCH_USERNAME: root
    - ELASTICSEARCH_PASSWORD: ********
</code></pre>
<p>Key points:</p>
<ul>
<li><code>initScript</code> is a path on the classpath (e.g. <a href="https://github.com/harezmi/fit4j/blob/main/scripts/redis_initial_data.yml"><code>scripts/redis_initial_data.yml</code></a>).</li>
<li>For Redis (generic container), FIT4J uses its own data populator based on this file.</li>
<li>For Elasticsearch, FIT4J uses <code>ElasticsearchDataPopulator</code> to ingest documents.</li>
<li><code>reuse</code> controls whether the container is reused across test runs, which affects isolation vs. startup performance.</li>
</ul>
<p>See [Configuration Properties Reference] in the main README for how <code>exposedProperties</code> are mapped to Spring properties.</p>
<hr />
<h2>Redis Initial Data</h2>
<h3>YAML Format</h3>
<p>Redis initial data is defined in YAML files like <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/scripts/redis_initial_data.yml"><code>src/test/resources/scripts/redis_initial_data.yml</code></a> (referenced from <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L80"><code>README.md:60-80</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/RedisDataProviderFIT.kt#L13-L25"><code>RedisDataProviderFIT.kt:13-25</code></a>).</p>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L40-L60"><code>README.md:40-60</code></a>:</p>
<pre><code class="language-yaml">- entry:
    type: &quot;string&quot;
    data:
        key: &quot;stringKey&quot;
        value: &quot;stringValue&quot;
- entry:
    type: &quot;hash&quot;
    data:
        key: &quot;hashKey&quot;
        fields:
            field1: &quot;value1&quot;
            field2: &quot;value2&quot;
</code></pre>
<p>Supported Redis types (see <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L67"><code>README.md:60-67</code></a>):</p>
<ul>
<li><code>string</code></li>
<li><code>hash</code></li>
<li><code>list</code></li>
<li><code>set</code></li>
<li><code>sortedset</code></li>
<li><code>bitmap</code></li>
<li><code>hyperloglog</code></li>
<li><code>geospatial</code></li>
<li><code>stream</code></li>
</ul>
<p>Each type has a specific structure defined in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/scripts/redis_initial_data.yml"><code>src/test/resources/scripts/redis_initial_data.yml</code></a>.</p>
<h3>Parsing Redis YAML: <code>RedisDataProvider</code></h3>
<p><code>RedisDataProvider</code> is responsible for parsing the YAML into an internal representation (<code>RedisData</code> and friends). See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/testcontainers/RedisDataProvider.kt#L1-L40"><code>src/main/kotlin/org/fit4j/testcontainers/RedisDataProvider.kt:1-40</code></a>.</p>
<p>Core behavior:</p>
<ul>
<li>Loads YAML file if the <code>Resource</code> exists.</li>
<li>Uses SnakeYAML (<code>org.yaml.snakeyaml.Yaml</code>) to parse the content.</li>
<li>Splits entries by <code>type</code> into type-specific collections:</li>
<li><code>strings: List&lt;RedisString&gt;</code></li>
<li><code>hashes: List&lt;RedisHash&gt;</code></li>
<li><code>lists: List&lt;RedisList&gt;</code></li>
<li><code>sets: List&lt;RedisSet&gt;</code></li>
<li>(and similarly for other supported types, not fully shown in the snippet)</li>
</ul>
<p>Snippet (simplified):</p>
<pre><code class="language-kotlin">// src/main/kotlin/org/fit4j/testcontainers/RedisDataProvider.kt:9-23
init {
    if (resource.exists()) {
        logger.debug(&quot;Loading Redis data from ${resource.filename}&quot;)
        val yaml = Yaml()
        val entries = yaml.load(resource.inputStream) as List&lt;Map&lt;String, Any&gt;&gt;
        val stringEntries = mutableListOf&lt;RedisString&gt;()
        val hashEntries = mutableListOf&lt;RedisHash&gt;()
        val listEntries = mutableListOf&lt;RedisList&gt;()
        val setEntries = mutableListOf&lt;RedisSet&gt;()
        // ... map entries into RedisData
    }
}
</code></pre>
<p>Test coverage:</p>
<pre><code class="language-kotlin">// src/test/kotlin/org/fit4j/testcontainers/RedisDataProviderFIT.kt:13-25
@Test
fun `it should load redis data from yaml file`() {
    val redisDataProvider = RedisDataProvider(
        resourceLoader.getResource(&quot;classpath:scripts/redis_initial_data.yml&quot;)
    )
    val redisData = redisDataProvider.getRedisData()

    MatcherAssert.assertThat(
        redisData.strings,
        Matchers.contains(RedisString(&quot;stringKey&quot;, &quot;stringValue&quot;))
    )
}
</code></pre>
<p>This ensures the YAML schema remains stable and that changes are caught by tests.</p>
<h3>Writing to Redis: <code>RedisDataPopulator</code></h3>
<p><code>RedisDataPopulator</code> performs the actual write operations against Redis using Jedis. See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/testcontainers/RedisDataPopulator.kt#L1-L40"><code>src/main/kotlin/org/fit4j/testcontainers/RedisDataPopulator.kt:1-40</code></a>.</p>
<p>Construction:</p>
<pre><code class="language-kotlin">// src/main/kotlin/org/fit4j/testcontainers/RedisDataPopulator.kt:5-11
class RedisDataPopulator(redisConnectionProperties: RedisConnectionProperties)
    : TestContainerDataPopulator {

    private var jedis: Jedis = Jedis(
        redisConnectionProperties.host,
        redisConnectionProperties.port
    )
</code></pre>
<p>Population logic (excerpt):</p>
<pre><code class="language-kotlin">// src/main/kotlin/org/fit4j/testcontainers/RedisDataPopulator.kt:13-26
override fun populateData(resource: Resource) {
    val dataProvider = RedisDataProvider(resource)
    val redisData = dataProvider.getRedisData()

    redisData.strings.forEach {
        jedis.set(it.key, it.value)
    }
    redisData.hashes.forEach {
        jedis.hmset(it.key, it.fields)
    }
    redisData.lists.forEach {
        jedis.lpush(it.key, *it.values.toTypedArray())
    }
    // ... similar for sets, sortedsets, streams, etc.
}
</code></pre>
<p>Typical usage in tests:</p>
<ul>
<li>For <strong>embedded Redis</strong>: create a <code>RedisDataPopulator</code> with embedded host/port and call <code>populateData</code> manually.</li>
<li>For <strong>Testcontainers Redis</strong>: FIT4J calls <code>populateData</code> automatically using the <code>initScript</code> from container definition.</li>
</ul>
<p>A simple usage pattern (embedded example):</p>
<pre><code class="language-kotlin">// fit4j-examples/example-redis-embedded/src/test/kotlin/.../RedisEmbeddedExampleFIT.kt:15-25
val redisConnectionProperties = RedisConnectionProperties(&quot;localhost&quot;, redisPort.toInt())
val redisDataPopulator = RedisDataPopulator(redisConnectionProperties)
val jedis: Jedis = redisDataPopulator.getJedis()
jedis.set(&quot;stringKey&quot;, &quot;stringValue&quot;)
val value = jedis.get(&quot;stringKey&quot;)
Assertions.assertEquals(&quot;stringValue&quot;, value)
</code></pre>
<h3>Performance and Isolation Considerations for Redis</h3>
<ul>
<li><strong>Startup cost</strong> is proportional to the size of <a href="https://github.com/harezmi/fit4j/blob/main/redis_initial_data.yml"><code>redis_initial_data.yml</code></a>. Large lists/sets/streams will slow container startup.</li>
<li><strong>Isolation</strong>:</li>
<li>When <code>reuse: false</code> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>, each test suite starts with a fresh Redis instance populated from the YAML file.</li>
<li>When <code>reuse: true</code>, all test suites share the same Redis state; tests must either avoid mutation or clean up their changes.</li>
<li><strong>Best practice</strong>:</li>
<li>For deterministic tests, always assume initial state is the YAML file plus test-specific writes.</li>
<li>Keep initial data small and generic; put scenario-specific data into test setup code.</li>
</ul>
<hr />
<h2>Elasticsearch Initial Data</h2>
<h3>YAML Format</h3>
<p>Elasticsearch initial data is defined in YAML files such as <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/scripts/elasticsearch_initial_data.yml"><code>src/test/resources/scripts/elasticsearch_initial_data.yml</code></a>, referenced in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/README.md#L90-L110"><code>README.md:90-110</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L30-L40"><code>src/test/resources/fit4j-test-containers.yml:30-40</code></a></li>
</ul>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L90-L104"><code>README.md:90-104</code></a>:</p>
<pre><code class="language-yaml">- document:
    index: &quot;test&quot;
    id: &quot;1&quot;
    body:
      name: &quot;John Doe&quot;
      age: 25
      email: &quot;john.doe@example.com&quot;
- document:
    index: &quot;test&quot;
    id: &quot;2&quot;
    body:
      name: &quot;Jane Doe&quot;
      age: 30
      email: &quot;jane.doe@example.com&quot;
</code></pre>
<p>Each <code>document</code> entry corresponds to an Elasticsearch <code>CreateRequest</code>:</p>
<ul>
<li><code>index</code>: index name.</li>
<li><code>id</code>: document ID.</li>
<li><code>body</code>: arbitrary JSON payload, represented as nested YAML.</li>
</ul>
<p>The transformation from YAML to <code>CreateRequest</code> is handled by <code>ElasticsearchDocumentProvider</code> (not shown in snippets but used in <code>ElasticsearchDataPopulator</code>).</p>
<h3>Writing to Elasticsearch: <code>ElasticsearchDataPopulator</code></h3>
<p><code>ElasticsearchDataPopulator</code> connects to the container and issues create requests for each document defined in the YAML file. See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulator.kt#L1-L40"><code>src/main/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulator.kt:1-40</code></a>.</p>
<p>Initialization:</p>
<pre><code class="language-kotlin">// src/main/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulator.kt:7-18
class ElasticsearchDataPopulator(connectionProperties: ElasticsearchConnectionProperties)
    : TestContainerDataPopulator {

    private var client: ElasticsearchClient

    init {
        client = getElasticSearchClient(connectionProperties)
    }
</code></pre>
<p>Data population:</p>
<pre><code class="language-kotlin">// src/main/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulator.kt:20-26
override fun populateData(resource: Resource) {
    val documentProvider = ElasticsearchDocumentProvider(resource)
    val createRequests = documentProvider.getCreateRequests()
    createRequests.forEach {
        client.create(it)
    }
}
</code></pre>
<p>Client creation (excerpt):</p>
<pre><code class="language-kotlin">// src/main/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulator.kt:28-45
private fun getLowLevelClientBuilder(
    elasticsearchConnectionProperties: ElasticsearchConnectionProperties
): RestClientBuilder {
    val host = HttpHost(
        elasticsearchConnectionProperties.host,
        elasticsearchConnectionProperties.port,
        &quot;http&quot;
    )
    val credentialsProvider = BasicCredentialsProvider()
    credentialsProvider.setCredentials(
        AuthScope.ANY,
        UsernamePasswordCredentials(
            elasticsearchConnectionProperties.username,
            &quot;********&quot;
        )
    )
    // ...
}
</code></pre>
<p>The client is built using:</p>
<ul>
<li><code>RestClient</code> / <code>RestClientTransport</code></li>
<li><code>ElasticsearchClient</code></li>
<li>Jackson JSON mapper.</li>
</ul>
<h3>Example: Reading Pre-Loaded Data in Tests</h3>
<p><code>ElasticsearchDataPopulatorFIT</code> demonstrates validating that YAML-defined documents are available. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulatorFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulatorFIT.kt:1-40</code></a>.</p>
<p>Snippet:</p>
<pre><code class="language-kotlin">// src/test/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulatorFIT.kt:29-41
@Test
fun `it should load documents from yaml file into the elasticsearch`() {
    val connectionProperties = ElasticsearchConnectionProperties(
        elastisSearchHost,
        elasticSearchPort.toInt(),
        &quot;root&quot;,
        &quot;********&quot;
    )
    val dataPopulator = ElasticsearchDataPopulator(connectionProperties)
    val client = dataPopulator.getElasticSearchClient()
    val getRequest = GetRequest.Builder()
        .id(&quot;3&quot;)
        .index(&quot;test&quot;)
        .build()
    val getResponse = client.get(getRequest, Object::class.java)

    Assertions.assertEquals(&quot;3&quot;, getResponse.id())
}
</code></pre>
<p>This validates both:</p>
<ul>
<li>The YAML → <code>CreateRequest</code> conversion.</li>
<li>The presence of the document in the underlying Elasticsearch container.</li>
</ul>
<h3>Performance and Isolation Considerations for Elasticsearch</h3>
<ul>
<li><strong>Index creation + document ingestion</strong> happen at container startup or when <code>populateData</code> is first called.</li>
<li>Large YAML files or complex <code>body</code> structures will:</li>
<li>Increase startup time.</li>
<li>Potentially increase memory footprint.</li>
<li><strong>Index naming</strong>:</li>
<li>Use test-specific index names (<code>test_myfeature_x</code>) to avoid collisions when multiple suites run against the same container (with <code>reuse: true</code>).</li>
<li><strong>Isolation</strong>:</li>
<li>With <code>reuse: false</code>, each test suite gets a clean Elasticsearch instance with only YAML-defined documents.</li>
<li>With <code>reuse: true</code>, tests share indices and must either:<ul>
<li>Use unique index names.</li>
<li>Use unique IDs and clean up documents they create.</li>
</ul>
</li>
</ul>
<hr />
<h2>Initialization Flow Overview</h2>
<p>The initialization chain for Redis/Elasticsearch with Testcontainers can be summarized as:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test start"] --> step2["Start containers"]
 step2 --> step3["Load initScript YAML"]
 step3 --> step4["Populate Redis/ES data"]
 step4 --> step5["Run tests"]
</div></div>
<p>Implementation-wise:</p>
<ol>
<li>
<p><strong>Test start</strong><br />
   FIT4J detects <code>@Testcontainers</code> annotated test classes and reads <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>.</p>
</li>
<li>
<p><strong>Start containers</strong><br />
   Testcontainers spins up Redis and Elasticsearch containers based on the definitions.</p>
</li>
<li>
<p><strong>Load initScript YAML</strong><br />
   For each container with <code>initScript</code>, FIT4J resolves the resource (e.g., <a href="https://github.com/harezmi/fit4j/blob/main/scripts/redis_initial_data.yml"><code>scripts/redis_initial_data.yml</code></a>).</p>
</li>
<li>
<p><strong>Populate data</strong>  </p>
</li>
<li>Redis: <code>RedisDataPopulator.populateData(resource)</code> (<a href="https://github.com/harezmi/fit4j/blob/main/RedisDataPopulator.kt#L13-L26"><code>RedisDataPopulator.kt:13-26</code></a>).</li>
<li>
<p>Elasticsearch: <code>ElasticsearchDataPopulator.populateData(resource)</code> (<a href="https://github.com/harezmi/fit4j/blob/main/ElasticsearchDataPopulator.kt#L20-L26"><code>ElasticsearchDataPopulator.kt:20-26</code></a>).</p>
</li>
<li>
<p><strong>Run tests</strong><br />
   Tests assume that both Redis and Elasticsearch contain the baseline data from the YAML files.</p>
</li>
</ol>
<hr />
<h2>Test Performance Considerations</h2>
<h3>Container Reuse</h3>
<p><code>reuse</code> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L40"><code>src/test/resources/fit4j-test-containers.yml:1-40</code></a>) directly affects performance:</p>
<ul>
<li><code>reuse: true</code></li>
<li>Pros: Faster subsequent test runs; containers are not recreated.</li>
<li>Cons: Shared state; less isolation; tests can interfere with each other.</li>
<li><code>reuse: false</code></li>
<li>Pros: Clean state per run; strong isolation guarantees.</li>
<li>Cons: Higher startup cost; slower builds, especially with heavy initialization.</li>
</ul>
<p>Recommended strategy:</p>
<ul>
<li>Use <code>reuse: false</code> for CI environments to maximize determinism.</li>
<li>For local development, <code>reuse: true</code> may be acceptable when you are aware of state sharing.</li>
</ul>
<h3>Size and Shape of Initial Data</h3>
<ul>
<li>Keep YAML initial data <strong>small and generic</strong>; do not encode entire scenarios.</li>
<li>Use test setup code (or per-test factories) for scenario-specific data.</li>
<li>Avoid:</li>
<li>Very large lists/sets,</li>
<li>Deeply nested document bodies,</li>
<li>High cardinality streams for Redis,
  unless you are explicitly testing performance/scale.</li>
</ul>
<h3>Embedded vs Testcontainers</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L15"><code>fit4j-examples/README.md:1-15</code></a>:</p>
<ul>
<li><code>example-redis/</code>: Redis with Testcontainers.</li>
<li><code>example-redis-embedded/</code>: Embedded Redis.</li>
<li><code>example-mysql/</code>, <code>example-h2/</code>, <code>example-dynamodb/</code>: other data stores.</li>
</ul>
<p>Performance trade-offs:</p>
<ul>
<li><strong>Embedded</strong>:</li>
<li>Very fast startup.</li>
<li>Good for unit-level tests.</li>
<li>Limited feature parity vs. real services.</li>
<li><strong>Testcontainers</strong>:</li>
<li>Slower startup, but closer to production.</li>
<li>Better for integration and contract tests.</li>
</ul>
<p>Choose based on the level of fidelity you need.</p>
<hr />
<h2>Test Isolation Patterns</h2>
<p>To maintain test isolation while still benefiting from data initialization:</p>
<ul>
<li>Use <strong>immutable baseline data</strong> in YAML (no test should modify baseline keys/ids).</li>
<li>For per-test data:</li>
<li>Use unique keys/ids (e.g., <code>user_${UUID.randomUUID()}</code>).</li>
<li>Or clean up after each test (delete keys/docs created).</li>
<li>Prefer <strong>suite-level initial data</strong>:</li>
<li>Keep <a href="https://github.com/harezmi/fit4j/blob/main/elasticsearch_initial_data.yml"><code>elasticsearch_initial_data.yml</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/redis_initial_data.yml"><code>redis_initial_data.yml</code></a> as the “seed data”.</li>
<li>Avoid encoding test-specific details there.</li>
</ul>
<p><code>ElasticsearchDataPopulatorFIT</code> also contains a <code>TestConfiguration</code> to close the application context after tests (<a href="https://github.com/harezmi/fit4j/blob/main/ElasticsearchDataPopulatorFIT.kt#L17-L27"><code>ElasticsearchDataPopulatorFIT.kt:17-27</code></a>), demonstrating how suites can cleanly tear down resources to avoid cross-suite interference.</p>
<hr />
<h2>Configuration Summary</h2>
<p>Key configuration knobs impacting indexing, initialization, and performance:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a></li>
<li><code>initScript</code><ul>
<li>Controls which YAML file is used for baseline data.</li>
</ul>
</li>
<li><code>reuse</code><ul>
<li>Controls container reuse between runs.</li>
</ul>
</li>
<li>
<p><code>env</code>, <code>exposedProperties</code></p>
<ul>
<li>Indirectly affect connection properties used by data populators.</li>
</ul>
</li>
<li>
<p>Spring property usage</p>
</li>
<li>Example in <a href="https://github.com/harezmi/fit4j/blob/main/ElasticsearchDataPopulatorFIT.kt#L13-L16"><code>ElasticsearchDataPopulatorFIT.kt:13-16</code></a>:
    <code>kotlin
    @Value("\${fit4j.elasticSearchContainerDefinition.host}")
    private lateinit var elastisSearchHost: String
    @Value("\${fit4j.elasticSearchContainerDefinition.port}")
    private lateinit var elasticSearchPort: Integer</code></li>
<li>These values are resolved from the Testcontainers definition and passed into <code>ElasticsearchConnectionProperties</code>.</li>
</ul>
<p>Mask any credentials in configs:</p>
<pre><code class="language-yaml">env:
  - ELASTICSEARCH_USERNAME: root
  - ELASTICSEARCH_PASSWORD: ********
</code></pre>
<hr />
<h2>When to Adjust Data Initialization</h2>
<p>Consider modifying the initialization strategy when you see:</p>
<ul>
<li><strong>Slow tests</strong>:</li>
<li>Reduce YAML size (fewer docs/keys).</li>
<li>Switch from <code>reuse: false</code> to <code>reuse: true</code> for local runs.</li>
<li><strong>Flaky tests due to state leakage</strong>:</li>
<li>Switch to <code>reuse: false</code>.</li>
<li>Make baseline data immutable; ensure tests use unique keys/ids.</li>
<li><strong>Complex setup code duplicated across tests</strong>:</li>
<li>Promote common baseline data into <a href="https://github.com/harezmi/fit4j/blob/main/elasticsearch_initial_data.yml"><code>elasticsearch_initial_data.yml</code></a> or <a href="https://github.com/harezmi/fit4j/blob/main/redis_initial_data.yml"><code>redis_initial_data.yml</code></a>.</li>
<li>Keep them generic so they can be reused.</li>
</ul>
<p>For related concepts and terminology, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-data-lifecycle-and-cleanup" class="dw-section">
  <div class="dw-section-inner">
    <h1>Data Lifecycle &amp; Cleanup Strategy</h1>
<p>This page explains how test data is created, reused, and cleaned between tests. It focuses on the <code>DatabaseTestSupport</code> implementations for different databases, the <code>KafkaTopicCleaner</code> for Kafka topics, and how configuration and Testcontainers influence lifecycle behavior.</p>
<p>The goal is deterministic, isolated tests: each test can assume a known database and Kafka state without manually resetting them.</p>
<hr />
<h2>Overview</h2>
<p>At a high level, the data lifecycle strategy for tests consists of:</p>
<ul>
<li><strong>Database lifecycle</strong></li>
<li>Auto-configured <code>DatabaseTestSupport</code> bean picking H2, MySQL, or PostgreSQL.</li>
<li>Clearing tables and resetting identifiers (sequences / auto-increment) between tests.</li>
<li>Optional disabling of cleanup at configuration level.</li>
<li><strong>Kafka lifecycle</strong></li>
<li>Optional <code>KafkaTopicCleaner</code> bean that deletes topics after each test method.</li>
<li><strong>Testcontainers</strong></li>
<li>Externalized DBs via Testcontainers, combined with <code>DatabaseTestSupport</code> to keep per-test isolation even in shared containers.</li>
</ul>
<hr />
<h2>DatabaseTestSupport: Core Abstraction</h2>
<h3>Interface</h3>
<p><code>DatabaseTestSupport</code> defines the operations used by tests to control database state:</p>
<pre><code class="language-kotlin">interface DatabaseTestSupport {
    fun resetAllIdentifiers()
    fun clearAllTables()
    fun openDBConsole()
    fun connection() : Connection
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupport.kt#L3-L11"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupport.kt:3-11</code></a>.</p>
<p>Responsibilities:</p>
<ul>
<li>
<p><strong><code>resetAllIdentifiers()</code></strong><br />
  Reset identity / sequence values so primary key generation starts from a known baseline (typically 1) for each test.</p>
</li>
<li>
<p><strong><code>clearAllTables()</code></strong><br />
  Remove all data from test tables, ensuring no test leaks data to the next one.</p>
</li>
<li>
<p><strong><code>openDBConsole()</code></strong><br />
  Convenience method (mainly for H2) to inspect DB state while debugging tests.</p>
</li>
<li>
<p><strong><code>connection()</code></strong><br />
  Exposes a raw JDBC <code>Connection</code> if low-level DB operations are needed in tests (implemented by concrete classes).</p>
</li>
</ul>
<p>These methods are implemented by vendor-specific subclasses and orchestrated by <code>AbstractDatabaseTestSupport</code>.</p>
<hr />
<h2>AbstractDatabaseTestSupport: Shared Lifecycle Logic</h2>
<p><code>AbstractDatabaseTestSupport</code> holds shared behavior and wiring:</p>
<pre><code class="language-kotlin">abstract class AbstractDatabaseTestSupport(
    val dataSource: DataSource,
    val transactionManager: PlatformTransactionManager,
    val cleanupEnabled:Boolean = true
) : DatabaseTestSupport {

    override fun resetAllIdentifiers() {
        resetAllIdentifiers(dataSource, transactionManager, schemaName())
    }

    override fun clearAllTables() {
        // ...
    }

    // plus template methods like executeResetAllIdentifiers(...)
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/AbstractDatabaseTestSupport.kt#L8-L29"><code>src/main/kotlin/org/fit4j/dbcleanup/AbstractDatabaseTestSupport.kt:8-29</code></a>.</p>
<p>Key points:</p>
<ul>
<li>
<p><strong>Template Method pattern</strong><br />
  Concrete subclasses implement <code>executeResetAllIdentifiers(jdbcTemplate, schemaName)</code> and usually DB-specific table clearing logic. <code>AbstractDatabaseTestSupport</code> drives these operations and handles transactions.</p>
</li>
<li>
<p><strong><code>cleanupEnabled</code> flag</strong><br />
  All cleanup operations are conditional. If <code>cleanupEnabled == false</code>, <code>resetAllIdentifiers()</code> and <code>clearAllTables()</code> are effectively no-ops. This allows you to keep state across tests when useful (e.g., performance profiling).</p>
</li>
<li>
<p><strong>Transaction handling</strong><br />
  Uses <code>TransactionTemplate</code> (via <code>PlatformTransactionManager</code>) to ensure cleanup runs in a single transaction per operation, providing consistency and avoiding partial clears.</p>
</li>
<li>
<p><strong>Schema resolution</strong><br />
<code>schemaName()</code> (not shown in snippet) typically derives the current schema from JDBC metadata or configuration. Subclasses use the schema name in their SQL to scope cleanup.</p>
</li>
</ul>
<p>In most setups, this abstract class is <strong>not used directly</strong> by tests; instead, a concrete <code>DatabaseTestSupport</code> bean is injected.</p>
<hr />
<h2>Vendor-specific DatabaseTestSupport Implementations</h2>
<h3>H2: DatabaseTestSupportForH2</h3>
<p><code>DatabaseTestSupportForH2</code> is the default implementation for in-memory test setups:</p>
<pre><code class="language-kotlin">class DatabaseTestSupportForH2(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager,
    cleanupEnabled:Boolean = true
) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {

    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        val tablesWithPKColumns = jdbcTemplate.queryForList(&quot;&quot;&quot;
            SELECT 
                t.table_name,
                k.column_name,
                c.is_identity
            -- ...
        &quot;&quot;&quot;.trimIndent())
        // ...
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForH2.kt#L9-L25"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForH2.kt:9-25</code></a>.</p>
<p>Responsibilities:</p>
<ul>
<li><strong>Reset identity columns</strong><br />
  Queries H2 metadata to find primary key columns and their <code>is_identity</code> flag, then resets identity values so IDs start from 1 for every test. Tests like <code>DatabaseTestSupportCheckingTestSuite</code> verify this behavior:</li>
</ul>
<p><code>kotlin
  Assertions.assertEquals(1,
      jdbcTemplate.queryForObject&lt;Int&gt;("select id from my_foo where name = 'Foo'"))</code>
  See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportCheckingTestSuite.kt#L27-L33"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportCheckingTestSuite.kt:27-33</code></a>.</p>
<ul>
<li><strong>Clear tables</strong><br />
  While not shown in snippet, <code>AbstractDatabaseTestSupport</code> plus H2-specific SQL typically uses <code>TRUNCATE TABLE</code> or <code>DELETE</code> with constraints disabled.</li>
</ul>
<p>Usage in tests:</p>
<ul>
<li><code>DefaultDatabaseTestSupportFIT</code> verifies that H2 is the default DB support:</li>
</ul>
<p>```kotlin
  @FIT
  class DefaultDatabaseTestSupportFIT {
      @Autowired
      private lateinit var databaseTestSupport: DatabaseTestSupport</p>
<pre><code>  @Test
  fun `default database test support should be h2`() {
      Assertions.assertTrue(databaseTestSupport is DatabaseTestSupportForH2)
  }
</code></pre>
<p>}
  ```</p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DefaultDatabaseTestSupportFIT.kt#L5-L15"><code>src/test/kotlin/org/fit4j/helper/DefaultDatabaseTestSupportFIT.kt:5-15</code></a>.</p>
<h3>MySQL: DatabaseTestSupportForMysql</h3>
<p><code>DatabaseTestSupportForMysql</code> implements MySQL-specific logic:</p>
<pre><code class="language-kotlin">class DatabaseTestSupportForMysql(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager,
    cleanupEnabled:Boolean = true
) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {

    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        val tablesWithPKColumns = jdbcTemplate.queryForList(&quot;&quot;&quot;
            SELECT 
                t.table_name,
                k.column_name,
                c.extra
            FROM information_schema.tables t
            JOIN information_schema.table_constraints tc 
                ON t.table_name = tc.table_name
                AND t.table_schema = tc.table_schema
                AND tc.constraint_type = 'PRIMARY KEY'
            JOIN information_schema.key_column_usage k 
            -- ...
        &quot;&quot;&quot;.trimIndent())
        // ...
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForMySQL.kt#L13-L36"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForMySQL.kt:13-36</code></a>.</p>
<p>Behavior:</p>
<ul>
<li><strong>Auto-increment reset</strong><br />
  Reads <code>information_schema</code> to locate <code>AUTO_INCREMENT</code> columns, then resets these counters. The test suite confirms IDs are deterministic:</li>
</ul>
<p><code>kotlin
  Assertions.assertEquals(1,
      jdbcTemplate.queryForObject&lt;Int&gt;("SELECT id FROM my_foo WHERE name = 'Foo'"))
  Assertions.assertEquals(2,
      jdbcTemplate.queryForObject&lt;Int&gt;("SELECT id FROM my_foo WHERE name = 'Bar'"))</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt#L26-L32"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt:26-32</code></a>.</p>
<ul>
<li><strong>Table clearing</strong><br />
  Similar to H2, the class uses MySQL-friendly statements (<code>TRUNCATE TABLE</code> or <code>DELETE FROM</code>) to clear tables between tests.</li>
</ul>
<p>This implementation is particularly useful with Testcontainers-based MySQL instances; you get database reuse at container level, but per-test isolation via cleanup.</p>
<h3>PostgreSQL: DatabaseTestSupportForPostgreSQL</h3>
<p><code>DatabaseTestSupportForPostgreSQL</code> handles PostgreSQL-specific sequence logic:</p>
<pre><code class="language-kotlin">class DatabaseTestSupportForPostgreSQL(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager,
    cleanupEnabled:Boolean = true
) : AbstractDatabaseTestSupport(dataSource, transactionManager, cleanupEnabled) {

    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        val sequenceNames = jdbcTemplate.queryForList(
            &quot;&quot;&quot;
                SELECT sequence_name 
                FROM information_schema.sequences 
                -- plus pg_catalog scan
            &quot;&quot;&quot;.trimIndent(),
            String::class.java
        )
        // ...
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForPostgreSQL.kt#L8-L22"><code>src/main/kotlin/org/fit4j/dbcleanup/DatabaseTestSupportForPostgreSQL.kt:8-22</code></a>.</p>
<p>Behavior:</p>
<ul>
<li>
<p><strong>Sequence reset</strong><br />
  PostgreSQL uses sequences behind <code>SERIAL</code> or <code>IDENTITY</code> columns. This implementation:</p>
</li>
<li>
<p>Enumerates sequences in both <code>information_schema</code> and <code>pg_catalog</code> to ensure all relevant sequences are found.</p>
</li>
<li>Resets each sequence to a well-known starting value (typically 1).</li>
</ul>
<p>This is validated here:</p>
<p><code>kotlin
  Assertions.assertTrue(databaseTestSupport is DatabaseTestSupportForPostgreSQL)
  Assertions.assertEquals(0,
      jdbcTemplate.queryForObject&lt;Int&gt;("SELECT COUNT(*) FROM my_foo"))
  jdbcTemplate.update("INSERT INTO my_foo(name) VALUES ('Foo')")
  jdbcTemplate.update("INSERT INTO my_foo(name) VALUES ('Bar')")
  Assertions.assertEquals(1,
      jdbcTemplate.queryForObject&lt;Long&gt;("SELECT id FROM my_foo WHERE name = 'Foo'"))</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L26-L36"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:26-36</code></a>.</p>
<ul>
<li><strong>Table clearing</strong><br />
  Uses PostgreSQL-specific SQL (not shown here) to truncate or delete data while dealing with foreign keys.</li>
</ul>
<h3>NoopDatabaseTestSupport</h3>
<p>For scenarios where DB cleanup is entirely externalized (e.g., per-test containers or ephemeral DBs), <code>NoopDatabaseTestSupport</code> is available:</p>
<pre><code class="language-kotlin">class NoopDatabaseTestSupport : DatabaseTestSupport {
    override fun resetAllIdentifiers() { }
    override fun clearAllTables() { }
    override fun openDBConsole() { }
    override fun connection(): Connection {
        throw NotImplementedError()
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/dbcleanup/NoopDatabaseTestSupport.kt#L3-L14"><code>src/main/kotlin/org/fit4j/dbcleanup/NoopDatabaseTestSupport.kt:3-14</code></a>.</p>
<p>Use cases:</p>
<ul>
<li>
<p><strong>Full isolation at infrastructure level</strong><br />
  When each test method/class gets its own DB instance (e.g., Testcontainers per test), you may not want in-DB cleanup at all.</p>
</li>
<li>
<p><strong>Migration phases</strong><br />
  When incrementally adopting this library, you might temporarily supply <code>NoopDatabaseTestSupport</code> to keep behavior unchanged.</p>
</li>
</ul>
<p>Note: <code>TestHelperAutoConfiguration</code> currently does not auto-select <code>NoopDatabaseTestSupport</code>; you would define your own bean to use it.</p>
<hr />
<h2>Auto-configuration &amp; Database Vendor Detection</h2>
<p><code>TestHelperAutoConfiguration</code> wires the appropriate <code>DatabaseTestSupport</code> implementation based on the underlying database:</p>
<pre><code class="language-kotlin">@Bean
@ConditionalOnMissingBean
fun databaseTestSupport(
    dataSource: DataSource,
    transactionManager: PlatformTransactionManager
): DatabaseTestSupport {
    val dbVendorName = detectDatabaseVendor(dataSource)
    val dbCleanUpEnabled = this.dbCleanUpEnabled()
    return when (dbVendorName) {
        &quot;mysql&quot; -&gt; DatabaseTestSupportForMysql(dataSource, transactionManager, dbCleanUpEnabled)
        &quot;h2&quot; -&gt; DatabaseTestSupportForH2(dataSource, transactionManager, dbCleanUpEnabled)
        &quot;postgresql&quot; -&gt; DatabaseTestSupportForPostgreSQL(dataSource, transactionManager, dbCleanUpEnabled)
        else -&gt; throw IllegalStateException(&quot;There is test support strategy for db vendor $dbVendorName&quot;)
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt#L31-L44"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHelperAutoConfiguration.kt:31-44</code></a>.</p>
<p>Key behavior:</p>
<ul>
<li>
<p><strong>Vendor detection</strong><br />
<code>detectDatabaseVendor(dataSource)</code> inspects JDBC metadata (typically <code>DatabaseMetaData.databaseProductName</code>) to determine the vendor string.</p>
</li>
<li>
<p><strong>Cleanup toggle</strong><br />
<code>dbCleanUpEnabled()</code> inspects application properties (see below) to decide whether cleanup features are active.</p>
</li>
<li>
<p><strong>Conditional registration</strong><br />
<code>@ConditionalOnMissingBean</code> ensures you can override the auto-configured <code>DatabaseTestSupport</code> with your own implementation or a <code>NoopDatabaseTestSupport</code> bean.</p>
</li>
</ul>
<hr />
<h2>KafkaTopicCleaner: Topic Lifecycle for Tests</h2>
<p>Many tests send and consume Kafka messages. Residual topics and lingering messages can cause flakiness. The <code>KafkaTopicCleaner</code> solves this by deleting topics between test methods.</p>
<p>The behavior is documented in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<pre><code class="language-markdown">If you need to clean up the topics in between the tests or test classes, you can benefit from the `KafkaTopicCleaner` which
deletes topics after each test method execution. It is disabled by default, you can enable it by setting the property
`fit4j.kafka.topicCleaner.enabled=true` in your [`application-test.properties`](https://github.com/harezmi/fit4j/blob/main/application-test.properties) file.
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L104-L109"><code>README.md:104-109</code></a> (approximate).</p>
<h3>Enabling / Disabling KafkaTopicCleaner</h3>
<p>The test suite verifies conditional registration through Spring Boot properties:</p>
<pre><code class="language-kotlin">@Nested
@FIT
@TestPropertySource(
    properties = [
        &quot;fit4j.kafka.topicCleaner.enabled=true&quot;,
        &quot;spring.kafka.consumer.auto-offset-reset=earliest&quot;
    ]
)
@EmbeddedKafka
inner class KafkaTopicCleanerEnabledFIT {
    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `kafka topic cleaner bean should exist`() {
        applicationContext.getBeansOfType(KafkaTopicCleaner::class.java).let { beansMap -&gt;
            assert(beansMap.isNotEmpty()) { &quot;KafkaTopicCleaner bean should exist&quot; }
        }
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt#L9-L30"><code>src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt:9-30</code></a>.</p>
<p>A complementary test ensures that setting the property to <code>false</code> disables the bean:</p>
<pre><code class="language-kotlin">@Nested
@FIT
@TestPropertySource(
    properties = [
        &quot;fit4j.kafka.topicCleaner.enabled=false&quot;,
        &quot;spring.kafka.consumer.auto-offset-reset=earliest&quot;
    ]
)
@EmbeddedKafka
inner class KafkaTopicCleanerDisabledFIT {
    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `kafka topic cleaner bean should not exist`() {
        applicationContext.getBeansOfType(KafkaTopicCleaner::class.java).let { beansMap -&gt;
            assert(beansMap.isEmpty()) { &quot;KafkaTopicCleaner bean should not exist&quot; }
        }
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt#L32-L54"><code>src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt:32-54</code></a>.</p>
<p>In most setups:</p>
<ul>
<li><strong>Enabled</strong> when you want complete isolation between tests that use shared embedded Kafka.</li>
<li><strong>Disabled</strong> when tests intentionally share topics / messages across methods or when topic deletion is too expensive.</li>
</ul>
<hr />
<h2>Configuration Properties Affecting Data Lifecycle</h2>
<h3>Database Cleanup Enabling</h3>
<p>Though the implementation of <code>dbCleanUpEnabled()</code> is not shown, by convention it reads a property, typically:</p>
<pre><code class="language-properties"># application-test.properties
fit4j.db.cleanup.enabled=true
</code></pre>
<p>Likely behavior:</p>
<ul>
<li><code>true</code> (default): <code>cleanupEnabled = true</code> passed into <code>DatabaseTestSupportFor*</code> constructors; tables and identifiers are cleared between tests.</li>
<li><code>false</code>: All cleanup methods are no-op; DB state persists across tests.</li>
</ul>
<p>Actual property name and behavior should be confirmed in <code>TestHelperAutoConfiguration</code> implementation.</p>
<h3>Kafka Topic Cleanup</h3>
<p><code>KafkaTopicCleaner</code> is controlled through:</p>
<pre><code class="language-properties"># application-test.properties
fit4j.kafka.topicCleaner.enabled=true
spring.kafka.consumer.auto-offset-reset=earliest
</code></pre>
<ul>
<li><code>fit4j.kafka.topicCleaner.enabled</code>  </li>
<li><code>true</code>: Registers <code>KafkaTopicCleaner</code> bean; topics are deleted after each test method.</li>
<li>
<p><code>false</code> or absent: No cleaner bean; topics / offsets persist for subsequent tests.</p>
</li>
<li>
<p><code>spring.kafka.consumer.auto-offset-reset</code>  </p>
</li>
<li>Often set to <code>earliest</code> so that, after topic recreation or offset reset, test consumers see all messages from the start.</li>
</ul>
<hr />
<h2>Testcontainers and DB Lifecycle</h2>
<p>The repository uses Testcontainers for MySQL and PostgreSQL tests:</p>
<ul>
<li><code>DatabaseTestSupportForMySQLCheckingTestSuite</code> and <code>DatabaseTestSupportForPostgreSQLCheckingTestSuite</code> reference <code>org.fit4j.testcontainers.Testcontainers</code>, indicating containerized DBs:</li>
</ul>
<p><code>kotlin
  import org.fit4j.testcontainers.Testcontainers</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt#L5"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt:5</code></a> and<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L5"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:5</code></a>.</p>
<p>Lifecycle strategy with Testcontainers:</p>
<ul>
<li><strong>Container lifecycle</strong>  </li>
<li>Typically one container per test suite (JVM / class), reused across tests to reduce startup time.</li>
<li><strong>Data lifecycle</strong>  </li>
<li>Within the shared container, <code>DatabaseTestSupport</code> is responsible for clearing tables and resetting identifiers between tests.</li>
<li><strong>Why still cleanup with Testcontainers?</strong>  </li>
<li>Even though containers can be ephemeral, reusing them across tests is faster.</li>
<li>Without cleanup, earlier tests could interfere with later ones via leftover data.</li>
</ul>
<p>If you choose to run <strong>one container per test method</strong>, you may prefer:</p>
<ul>
<li>Disabling DB cleanup (<code>fit4j.db.cleanup.enabled=false</code>) and/or</li>
<li>Providing a <code>NoopDatabaseTestSupport</code> bean.</li>
</ul>
<hr />
<h2>Typical Test Data Lifecycle Flow</h2>
<p>The following flow describes a typical <strong>database + Kafka</strong> lifecycle in a FIT test:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Start test method"] --> step2["DB cleanup if enabled"]
 step2 --> step3["Test produces Kafka messages"]
 step3 --> step4["KafkaTopicCleaner deletes topics"]
</div></div>
<p>Explanation:</p>
<ol>
<li><strong>Start test method</strong></li>
<li>Spring test context is already initialized.</li>
<li>
<p>Test code uses repositories and services; DB may start in a clean state depending on previous cleanup.</p>
</li>
<li>
<p><strong>DB cleanup (before or after tests, depending on configuration)</strong></p>
</li>
<li><code>DatabaseTestSupport.clearAllTables()</code> and <code>resetAllIdentifiers()</code> are invoked at a lifecycle hook (typically after each test method).</li>
<li>
<p>Vendor-specific SQL ensures tables are empty and ID generation restarts from 1.</p>
</li>
<li>
<p><strong>Test produces Kafka messages</strong></p>
</li>
<li>Test Sends messages via <code>KafkaTemplate</code> to topics (e.g., <code>foo-create-topic</code>).</li>
<li>
<p>Application consumes and persists to DB. Example snippet in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<p><code>kotlin
 kafkaTemplate.send("foo-create-topic", message).get()
 val processedMessage = kafkaMessageTracker.waitForProcessing(message)</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L94-L103"><code>README.md:94-103</code></a> (approximate).</p>
</li>
<li>
<p><strong>KafkaTopicCleaner deletes topics</strong></p>
</li>
<li>If <code>fit4j.kafka.topicCleaner.enabled=true</code>, after the test completes, <code>KafkaTopicCleaner</code> deletes the used topics.</li>
<li>Next test starts with freshly re-created topics and no leftover messages.</li>
</ol>
<hr />
<h2>Practical Usage Patterns</h2>
<h3>Pattern 1: Default Local Testing (H2 + Embedded Kafka)</h3>
<ul>
<li><strong>Configuration</strong></li>
<li>H2 as default DB.</li>
<li><code>fit4j.kafka.topicCleaner.enabled=true</code> in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>.</li>
<li><strong>Behavior</strong></li>
<li><code>DatabaseTestSupportForH2</code> cleans DB between tests.</li>
<li><code>KafkaTopicCleaner</code> keeps Kafka topics clean.</li>
</ul>
<p>This is validated by:</p>
<ul>
<li><code>DefaultDatabaseTestSupportFIT</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DefaultDatabaseTestSupportFIT.kt#L5-L15"><code>src/test/kotlin/org/fit4j/helper/DefaultDatabaseTestSupportFIT.kt:5-15</code></a>).</li>
<li><code>KafkaTopicCleanerTestSuite</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt#L9-L54"><code>src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt:9-54</code></a>).</li>
</ul>
<h3>Pattern 2: MySQL/PostgreSQL with Testcontainers</h3>
<ul>
<li><strong>Configuration</strong></li>
<li>Testcontainers-managed MySQL/PostgreSQL.</li>
<li><code>fit4j.db.cleanup.enabled=true</code> (default).</li>
<li><code>fit4j.kafka.topicCleaner.enabled</code> as needed.</li>
<li><strong>Behavior</strong></li>
<li>Containers are reused across tests for performance.</li>
<li><code>DatabaseTestSupportForMysql</code> or <code>DatabaseTestSupportForPostgreSQL</code> keeps per-test isolation by clearing tables and resetting IDs.</li>
</ul>
<p>See:</p>
<ul>
<li><code>DatabaseTestSupportForMySQLCheckingTestSuite</code><br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt</code></a>.</li>
<li><code>DatabaseTestSupportForPostgreSQLCheckingTestSuite</code><br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt</code></a>.</li>
</ul>
<h3>Pattern 3: Fully Isolated DB Per Test (No Cleanup Needed)</h3>
<ul>
<li><strong>Configuration</strong></li>
<li>Each test method gets its own container or ephemeral DB.</li>
<li>
<p>Custom bean:</p>
<p><code>kotlin
@Bean
fun databaseTestSupport(): DatabaseTestSupport = NoopDatabaseTestSupport()</code></p>
</li>
<li>
<p><strong>Behavior</strong></p>
</li>
<li>No in-DB cleanup; DB is discarded with the container after each test.</li>
<li>Ideal when tests are few but DB initialization is lightweight.</li>
</ul>
<hr />
<h2>When to Adjust the Lifecycle Strategy</h2>
<p>Consider tuning the data lifecycle strategy when you encounter:</p>
<ul>
<li><strong>Flaky tests involving Kafka</strong></li>
<li>Enable <code>KafkaTopicCleaner</code> to remove cross-test topic state.</li>
<li>
<p>Ensure consumer offset reset (<code>spring.kafka.consumer.auto-offset-reset=earliest</code>).</p>
</li>
<li>
<p><strong>Non-deterministic ID values in assertions</strong></p>
</li>
<li>Use <code>DatabaseTestSupport.resetAllIdentifiers()</code> explicitly in tests if needed.</li>
<li>
<p>Or ensure <code>fit4j.db.cleanup.enabled=true</code> and rely on automatic hooks.</p>
</li>
<li>
<p><strong>Slow tests due to repeated container startup</strong></p>
</li>
<li>
<p>Reuse Testcontainers across tests and rely on DB cleanup instead.</p>
</li>
<li>
<p><strong>Performance issues from frequent cleanup</strong></p>
</li>
<li>For large schemas, consider:<ul>
<li>Disabling cleanup for a subset of tests.</li>
<li>Migrating those tests to per-test ephemeral DBs and using <code>NoopDatabaseTestSupport</code>.</li>
</ul>
</li>
</ul>
<hr />
<p>For explanations of terms like FIT, Testcontainers, or the internal helper utilities, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-critical-execution-flows" class="dw-section">
  <div class="dw-section-inner">
    <h1>Critical Execution Flows</h1>
<p>This page explains how FIT4J drives a test from the moment you annotate it with <code>@FIT</code> or <code>@IT</code> through Spring context bootstrapping, fixture loading, embedded service startup, request/response mocking, and final verification. The goal is to clarify what happens when, which annotations participate, and where to hook in for custom behavior.</p>
<p>See the <em>Glossary</em> section for definitions of terms like “fixture”, “FIT”, “IT”, and “test scope”.</p>
<hr />
<h2>Overview of the FIT4J Test Lifecycle</h2>
<p>At a high level, a FIT test goes through the following phases when you run <code>@Test</code> methods inside a class annotated with <code>@FIT</code>:</p>
<ol>
<li><strong>Test discovery &amp; annotation processing</strong></li>
<li><strong>Spring context bootstrapping</strong></li>
<li><strong>Fit4J test extension initialization (<code>Fit4JTestExtension</code>)</strong></li>
<li><strong>Fixture loading (declarative YAML and/or programmatic via <code>@TestConfiguration</code>)</strong></li>
<li><strong>Embedded infrastructure startup &amp; mocking setup</strong></li>
<li><strong>Test method execution (Arrange → Act → Assert)</strong></li>
<li><strong>Verification &amp; tracking (HTTP/gRPC/Kafka calls, errors)</strong></li>
<li><strong>Context caching / cleanup and test-scoped bean lifecycle</strong></li>
</ol>
<p>The same general idea applies to <code>@IT</code> tests, but they do not enable the full FIT environment (e.g., automatic declarative request/response training).</p>
<hr />
<h2>Entry Point: <code>@FIT</code> and <code>@IT</code> Annotations</h2>
<h3><code>@FIT</code> annotation</h3>
<p>The <code>@FIT</code> annotation is the main entry point for functional integration tests:</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/annotation/FIT.kt:1-18
package org.fit4j.annotation

import org.fit4j.context.Fit4JTestExtension
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource
import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target


@IT
@TestPropertySource(properties = [&quot;fit4j.testClass.isFunctionalIntegrationTest=true&quot;])
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(Fit4JTestExtension::class)
annotation class FIT(
    val fixtureFilePath: String = &quot;&quot;,
    val webEnvironment: SpringBootTest.WebEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
</code></pre>
<p>Key points:</p>
<ul>
<li><strong>Builds on <code>@IT</code></strong>: <code>@FIT</code> inherits from <code>@IT</code>, so it automatically enables the base integration infrastructure. See the <em>Introduction / @IT</em> section for details on what <code>@IT</code> does.</li>
<li><strong>Sets a marker property</strong>: <code>fit4j.testClass.isFunctionalIntegrationTest=true</code> is added via <code>@TestPropertySource</code>. This property is typically used by FIT4J internals to distinguish FITs from plain integration tests.</li>
<li><strong>Registers the JUnit extension</strong>: <code>@ExtendWith(Fit4JTestExtension::class)</code> wires all FIT-specific lifecycle behavior into JUnit.</li>
<li><strong>Parameters</strong>:</li>
<li><code>fixtureFilePath</code>: custom YAML fixture file location; empty means “use default <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> on classpath”.</li>
<li><code>webEnvironment</code>: passed through to the underlying <code>@SpringBootTest</code> configuration to control the web server environment (e.g. <code>RANDOM_PORT</code>).</li>
</ul>
<p>Execution-wise, once JUnit discovers a test class annotated with <code>@FIT</code>, it:</p>
<ol>
<li>Applies <code>@IT</code> configuration (enabling integration infrastructure).</li>
<li>Adds <code>fit4j.testClass.isFunctionalIntegrationTest=true</code> to the test property set.</li>
<li>Registers <code>Fit4JTestExtension</code> callbacks for this test class.</li>
<li>Delegates to Spring Test to bootstrap, cache, or reuse an <code>ApplicationContext</code>.</li>
</ol>
<h3><code>@IT</code> annotation</h3>
<p>The <code>@IT</code> annotation is the base integration test annotation; <code>@FIT</code> is built on top of it:</p>
<ul>
<li>Enables common integration test infrastructure like:</li>
<li>in-process gRPC server</li>
<li>declarative Testcontainers support</li>
<li>standard Spring Boot test configuration</li>
<li>Intended for “normal” integration tests that verify component interaction, without the full FIT fixture and tracking capabilities.</li>
</ul>
<p>From the README (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md"><code>/tmp/repo_fun8n87l/README.md</code></a>):</p>
<ul>
<li><code>@IT</code> tests verify interactions among internal components such as gRPC controllers, service layer, and repositories.</li>
<li><code>@FIT</code> tests additionally activate:</li>
<li>programmatic and declarative request/response training</li>
<li>sync call and async message tracking</li>
<li>extended verification support.</li>
</ul>
<hr />
<h2>Spring Context Bootstrapping &amp; Caching</h2>
<h3>FIT vs non-FIT context reuse</h3>
<p>Spring’s <code>ApplicationContext</code> caching behavior is central to execution performance. FIT4J makes this explicit with two test suites.</p>
<h4>FIT context caching</h4>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt:1-40
@Nested
@Order(1)
@FIT
inner class FirstFIT {
    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `initialize static application context`() {
        Assertions.assertNull(applicationContextStatic)
        applicationContextStatic = applicationContext
    }
}

@Nested
@Order(2)
@FIT
inner class SecondFIT {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `check if application contexts are the same`() {
        Assertions.assertNotNull(applicationContextStatic)
        Assertions.assertSame(applicationContextStatic, applicationContext)
    }
}
</code></pre>
<p>Execution flow here:</p>
<ol>
<li>The <strong>first nested <code>@FIT</code> class</strong> starts a Spring <code>ApplicationContext</code> via <code>@SpringBootTest</code> semantics.</li>
<li>The static reference <code>applicationContextStatic</code> is set to the autowired context.</li>
<li>The <strong>second nested <code>@FIT</code> class</strong> runs afterward; Spring reuses the same cached context.</li>
<li>The assertion verifies that both contexts are the same instance.</li>
</ol>
<p>Implication: FIT tests purposely reuse the same <code>ApplicationContext</code> across multiple FIT classes (sharing test-level infrastructure) when their configuration is compatible. Declarative fixtures are loaded once and reused, which greatly speeds up execution.</p>
<h4>Non-FIT context behavior</h4>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/context/ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt:1-36
@Nested
@Order(1)
@SpringBootTest
@ActiveProfiles(&quot;test&quot;)
inner class FirstFIT {
    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `initialize static application context`() {
        Assertions.assertNull(applicationContextStatic)
        applicationContextStatic = applicationContext
    }
}

@Nested
@Order(2)
@SpringBootTest
@ActiveProfiles(&quot;test&quot;)
inner class SecondFIT {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @AfterEach
    fun `reset static context`() {
            applicationContextStatic = null
    }

    @Test
    fun `some test`() {
        // ...
    }
}
</code></pre>
<p>Here, the tests show the default behavior with <code>@SpringBootTest</code> and demonstrate that you control the static state yourself (in this example, they reset <code>applicationContextStatic</code> after each test). FIT4J’s FIT tests rely instead on Spring’s context caching plus internal static state managed by the library itself.</p>
<hr />
<h2>Fixture Loading and Execution</h2>
<p>Fit4J supports two ways of defining fixtures for FIT tests:</p>
<ol>
<li><strong>Declarative fixtures</strong> via YAML files</li>
<li><strong>Programmatic fixtures</strong> via <code>@TestConfiguration</code> beans</li>
</ol>
<h3>Declarative fixtures (YAML)</h3>
<p>By default, FIT4J loads declarative fixtures from <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> on the test classpath, but you can override the path using <code>@FIT(fixtureFilePath="...")</code>.</p>
<p>Example fragment:</p>
<pre><code class="language-yaml"># See src/test/resources/fit4j-fixtures.yml:1-40
tests:
  - name: HttpMockServiceResponseFactoryFIT
    fixtures:
      - request:
          protocol: http
          path: &quot;/test/foo/&quot;
          response:
            status: 401
            headers:
              Content-Type: &quot;application/json&quot;

      - request:
          protocol: http
          path: &quot;/foo/#{@testFixtureData.variables.fooId}&quot;
          response:
            status: 200

      - request:
          protocol: http
          path: &quot;/foo?id=#{@testFixtureData.variables.fooId}&quot;
          response:
            status: 200

      - request:
          protocol: http
          path: &quot;/bar&quot;
          method: POST
          predicate: &quot;#request.body == 'withBody'&quot;
          response:
            status: 200
            body: ...
</code></pre>
<p>Execution flow:</p>
<ol>
<li><strong>Before any FIT test class executes</strong>, <code>Fit4JTestExtension</code> resolves the fixture file path:</li>
<li>If <code>@FIT.fixtureFilePath</code> is non-empty, it uses that.</li>
<li>Otherwise it defaults to <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> from the classpath.</li>
<li>The YAML file is parsed and loaded <strong>once per JVM execution</strong>, not per test.</li>
<li>For each <code>tests[*].name</code> entry, FIT4J matches the name:</li>
<li>Typically against the test class name.</li>
<li>Or using explicit mapping when available.</li>
<li>Matching fixtures are registered in the central mock/fixture infrastructure (e.g., <code>MockResponseFactory</code>).</li>
</ol>
<p>Because declarative fixtures are shared across tests and contexts are cached, these definitions are both <strong>fast</strong> and <strong>memory-efficient</strong>. The README emphasizes that:</p>
<blockquote>
<p>“the Spring ApplicationContext is not recreated for each test class, and the test execution is faster and more memory efficient. Therefore, it is recommended to use declarative fixture definitions whenever possible.”<br />
(See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md"><code>/tmp/repo_fun8n87l/README.md</code></a>).</p>
</blockquote>
<h3>Programmatic fixtures via <code>@TestConfiguration</code></h3>
<p>You can also define fixtures programmatically inside your FIT test class:</p>
<pre><code class="language-kotlin">// See README example in /tmp/repo_fun8n87l/README.md
import org.fit4j.annotation.FIT
import org.springframework.boot.test.context.TestConfiguration
import org.junit.jupiter.api.Test

@FIT
class SampleFIT {

    @TestConfiguration
    class TestConfig {
        // define beans used by fixtures/test
    }

    @Test
    fun `test something`() {
        // Arrange-Act-Assert
    }
}
</code></pre>
<p>Execution flow:</p>
<ol>
<li>Spring processes the inner <code>@TestConfiguration</code> class as part of the <strong>Arrange</strong> phase.</li>
<li>Any beans declared here are available in:</li>
<li>the main application context for the test, and</li>
<li>SpEL expressions in YAML fixtures.</li>
</ol>
<p>A typical pattern is to provide fixture creator beans and reference them from YAML using SpEL:</p>
<pre><code class="language-yaml"># See README example in /tmp/repo_fun8n87l/README.md
tests:
  - name: RestExampleFIT
    fixtures:
      - request:
          protocol: http
          path: &quot;/hello&quot;
          response:
            status: 200
            body: &quot;#{@testFixtureCreator.EXAMPLE_RESPONSE}&quot;
</code></pre>
<pre><code class="language-kotlin">// See README example in /tmp/repo_fun8n87l/README.md
@FIT
class RestExampleFIT {
    @TestConfiguration
    class TestConfig {
        @Bean
        fun testFixtureCreator(): TestFixtureCreator {
            return TestFixtureCreator()
        }
    }
}
</code></pre>
<p>This allows very flexible fixture composition while still benefiting from declarative YAML definitions.</p>
<h3>Per-test fixture groups and reset</h3>
<p>FIT4J supports grouping fixtures and resetting state between tests using annotations like <code>@FixtureForFIT</code>. For example:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-40
class TestFixtureGroupStateCleanupFIT {
    @Autowired
    lateinit var mockResponseFactory: MockResponseFactory

    @Test
    @FixtureForFIT(&quot;test-fixture-1&quot;)
    fun `should reset http fixtures and return a list of test fixtures 1`() {
        val request = createWebRequest(&quot;/test-1&quot;)
        val actualResponse1 = mockResponseFactory.getResponseFor(request) as HttpResponse
        val actualResponse2 = mockResponseFactory.getResponseFor(request) as HttpResponse
        val actualResponse3 = mockResponseFactory.getResponseFor(request) as HttpResponse
        val actualResponse4 = mockResponseFactory.getResponseFor(request) as HttpResponse

        verifyWebResponse(
            actualResponse = actualResponse1,
            expectedBody = &quot;Internal Server Error&quot;,
            // ...
        )
        // ...
    }
}
</code></pre>
<p>Execution flow:</p>
<ol>
<li><code>@FixtureForFIT("test-fixture-1")</code> tells FIT4J to <strong>activate a particular fixture group</strong> for this test method.</li>
<li>Before the method runs, the corresponding fixtures are applied in the <code>MockResponseFactory</code>.</li>
<li>Calls to <code>MockResponseFactory.getResponseFor(request)</code> return responses according to that group, in order.</li>
<li>After the test method completes, FIT4J resets the group state to guarantee isolation between tests.</li>
</ol>
<hr />
<h2>Embedded Services and Infrastructure</h2>
<p>FIT4J tests often need external infrastructure like Kafka, databases, or other network services. FIT4J integrates with Spring’s mechanisms for this, and the execution flows are:</p>
<h3>Embedded Kafka with <code>@EmbeddedKafka</code></h3>
<p>Example:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-28
@FIT
@EmbeddedKafka(partitions = 1)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class YetAnotherSampleFIT {

    @Autowired
    private lateinit var mockServiceCallTracker: MockServiceCallTracker

    @Test
    fun `test something`() {
        // Given
        // When
        // Then
        Assertions.assertNotNull(mockServiceCallTracker)
    }
}
</code></pre>
<p>Execution flow:</p>
<ol>
<li><code>@FIT</code> triggers <code>Fit4JTestExtension</code> and a Spring Boot test context.</li>
<li><code>@EmbeddedKafka(partitions = 1)</code> starts an embedded Kafka broker for this test context.</li>
<li>Your application’s Kafka consumers/producers connect to this embedded broker.</li>
<li><code>MockServiceCallTracker</code> is available to track Kafka-related calls and messages.</li>
<li><code>@DirtiesContext(AFTER_CLASS)</code> tells Spring to <strong>discard</strong> this <code>ApplicationContext</code> after the test class completes. This is useful if the embedded Kafka configuration should not be reused across tests.</li>
</ol>
<p>If you do not mark a FIT test with <code>@DirtiesContext</code>, the context (and its embedded services) may be reused across other compatible FIT tests.</p>
<hr />
<h2>Request/Response Mocking and Training</h2>
<h3>Declarative HTTP mocks</h3>
<p>From the YAML above, HTTP fixtures are declared per test name and path. The execution flow for an HTTP fixture is:</p>
<ol>
<li>During test initialization, FIT4J loads fixtures into a <code>MockResponseFactory</code> (or equivalent).</li>
<li>When your application under test issues an HTTP call through the registered client, the call is intercepted by the FIT4J mock infrastructure instead of going to a real external service.</li>
<li><code>MockResponseFactory.getResponseFor(request)</code> is used internally (and in tests) to map incoming requests to the declaratively defined response:</li>
<li>It matches protocol (<code>http</code>), <code>path</code>, HTTP method, and, optionally, the <code>predicate</code> expression.</li>
<li>It returns the configured status, headers, and body.</li>
<li>Each call can consume a separate “slot” in a fixture so that sequences of responses can be tested in order.</li>
</ol>
<p>Example internal use (simplified):</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-40
val request = createWebRequest(&quot;/test-1&quot;)
val actualResponse = mockResponseFactory.getResponseFor(request) as HttpResponse
</code></pre>
<h3>gRPC calls</h3>
<p>For gRPC, the typical execution flow in a FIT test:</p>
<pre><code class="language-kotlin">// See README example in /tmp/repo_fun8n87l/README.md
@FIT
class SampleFIT {
    @GrpcClient(&quot;inProcess&quot;)
    private lateinit var grpcClient: FooGrpcServiceGrpc.FooGrpcServiceBlockingStub

    @Test
    fun `test something`() {
        // Arrange
        val request = GetFooByIdRequest.newBuilder()
          .setId(123)
          .build()
        // Act
        val response = grpcClient.getFooByIdResponse(request)
        // Assert
        Assertions.assertNotNull(response)
    }
}
</code></pre>
<p>Flow:</p>
<ol>
<li><code>@IT</code> / <code>@FIT</code> infrastructure configures an <strong>in-process gRPC server</strong> for your service.</li>
<li><code>@GrpcClient("inProcess")</code> injects a stub pointing to this in-process channel.</li>
<li>When the test calls <code>grpcClient.getFooByIdResponse(...)</code>, the request goes straight into your service’s gRPC controller.</li>
<li>If there are outbound calls to other gRPC services from your service, FIT4J’s mocking infrastructure can intercept and respond using declarative fixtures (similar to HTTP).</li>
</ol>
<hr />
<h2>Verification and Tracking of External Calls</h2>
<p>A core part of critical flows is verifying what the system did:</p>
<h3><code>MockServiceCallTracker</code></h3>
<p>The <code>MockServiceCallTracker</code> bean allows tests to inspect what interactions happened with mocked external services:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-28
@FIT
class YetAnotherSampleFIT {

    @Autowired
    private lateinit var mockServiceCallTracker: MockServiceCallTracker

    @Test
    fun `test something`() {
        Assertions.assertNotNull(mockServiceCallTracker)
    }
}
</code></pre>
<p>From the README (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md"><code>/tmp/repo_fun8n87l/README.md</code></a>):</p>
<ul>
<li>Methods like:</li>
<li><code>getGrpcRequest(...)</code></li>
<li><code>getHttpRequest(...)</code></li>
<li>Error inspection API:</li>
<li><code>hasAnyError(...)</code></li>
<li><code>hasGrpcError(...)</code></li>
<li><code>hasHttpError(...)</code></li>
</ul>
<p>Execution flow:</p>
<ol>
<li>When the system under test performs outbound HTTP/gRPC/Kafka calls, the FIT4J mocks record them inside <code>MockServiceCallTracker</code>.</li>
<li>After the <strong>Act</strong> phase, your test uses <code>mockServiceCallTracker</code> to:</li>
<li>Assert that specific requests were made (e.g. correct path, payload, headers).</li>
<li>Assert that no errors occurred, or that specific error conditions occurred.</li>
<li>These assertions are part of the <strong>Assert</strong> phase of Arrange–Act–Assert.</li>
</ol>
<hr />
<h2>Test Scope and Per-Test Bean Lifecycle</h2>
<p>FIT4J introduces a <em>test-scoped</em> bean concept to isolate state between separate FIT executions while still sharing the global <code>ApplicationContext</code> where possible.</p>
<p>Example:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/scope/TestScopeCheckingTestSuite.kt:1-40
class TestScopeCheckingTestSuite {

    @Nested
    @Order(1)
    @FIT
    @Import(TestConfig::class)
    inner class FirstFIT {
        @Autowired
        private lateinit var testBean: TestBean

        @Test
        fun `put message into test bean`() {
            testBean.addMessage(&quot;First message&quot;)
        }
    }

    @Nested
    @Order(2)
    @FIT
    @Import(TestConfig::class)
    inner class SecondFIT {

        @Autowired
        private lateinit var testBean: TestBean

        @Test
        fun `check if test beans are not same`() {
            Assertions.assertTrue(
                testBean.getMessages().isEmpty(),
                &quot;Test bean should be empty&quot;
            )
        }
    }

    @TestConfiguration
    class TestConfig {
        @Bean
        @TestScoped
        fun testBean(): TestBean {
            return TestBean()
        }
    }

    open class TestBean {
        private val messages = mutableListOf&lt;String&gt;()
        fun addMessage(msg: String) = messages.add(msg)
        fun getMessages(): List&lt;String&gt; = messages
    }
}
</code></pre>
<p>Execution flow:</p>
<ol>
<li>The top-level test suite defines <code>TestConfig</code> with a <code>@TestScoped</code> bean <code>testBean</code>.</li>
<li>The <strong>first nested FIT</strong>:</li>
<li>Receives an instance of <code>TestBean</code>.</li>
<li>Adds <code>"First message"</code> to it.</li>
<li>When the <strong>second nested FIT</strong> runs:</li>
<li>FIT4J creates <strong>a new test-scoped instance</strong> of <code>TestBean</code>.</li>
<li>The assertion that <code>messages</code> is empty passes, proving the instances differ between FIT executions even though they share the same <code>ApplicationContext</code>.</li>
</ol>
<p>This pattern is critical to avoid leaking mutable state across FIT tests while still benefiting from context caching and shared infrastructure.</p>
<hr />
<h2>Execution Flow: Putting It All Together</h2>
<p>The following sequence diagram illustrates a typical FIT test run that uses declarative fixtures, embedded infrastructure, and tracking.</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
sequenceDiagram
 participant A as JUnit
 participant B as Fit4JExtension
 participant C as SpringContext
 participant D as ServiceUnderTest
 A->>B: Discover @FIT test
 B->>C: Bootstrap or reuse context
 B->>C: Load fixtures and mocks
 A->>D: Execute test method
 D->>C: Call outbound service
 C-->>D: Return mocked response
 D-->>A: Return test assertions
</div></div>
<p>Mapping to actual code &amp; concepts:</p>
<ul>
<li><strong>Discover @FIT test</strong>: <code>@FIT</code> annotation in <a href="https://github.com/harezmi/fit4j/blob/main/FIT.kt"><code>FIT.kt</code></a> (<a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/FIT.kt#L1-L18"><code>src/main/kotlin/org/fit4j/annotation/FIT.kt:1-18</code></a>).</li>
<li><strong>Bootstrap or reuse context</strong>: Verified by <code>ContextCachingForFitTestsShouldBeWorkingTestSuite</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt#L1-L40"><code>src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt:1-40</code></a>).</li>
<li><strong>Load fixtures and mocks</strong>: Declarative YAML in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L40"><code>src/test/resources/fit4j-fixtures.yml:1-40</code></a> plus programmatic <code>@TestConfiguration</code>s.</li>
<li><strong>Call outbound service</strong>: E.g., HTTP fixtures resolved via <code>MockResponseFactory</code> in <code>TestFixtureGroupStateCleanupFIT</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-40</code></a>), or gRPC stub calls in README example.</li>
<li><strong>Return mocked response</strong>: Driven by declarative fixture definitions.</li>
<li><strong>Return test assertions</strong>: Per-test logic in your <code>@Test</code> methods, optionally using <code>MockServiceCallTracker</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt#L1-L28"><code>src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-28</code></a>).</li>
</ul>
<hr />
<h2>Configuration and Limitations Impacting Execution</h2>
<h3>Sequential execution requirement</h3>
<p>From the README (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md"><code>/tmp/repo_fun8n87l/README.md</code></a>):</p>
<ul>
<li>FIT4J currently <strong>does not support parallel test execution</strong> for <code>@FIT</code> or <code>@IT</code> tests.</li>
<li>The main reason: use of <strong>shared static state</strong> in managing the global FIT context, fixture registry, and tracking.</li>
</ul>
<p>Implication on critical flows:</p>
<ul>
<li>All the cache and fixture behavior described here assumes <strong>sequential test execution</strong>.</li>
<li>Running tests in parallel may cause:</li>
<li>Fixtures from one test bleeding into another.</li>
<li>Shared trackers mixing calls.</li>
<li>Unpredictable failures.</li>
</ul>
<p>Build configuration must ensure sequential execution:</p>
<pre><code class="language-kotlin">// Gradle
tasks.test {
    maxParallelForks = 1
}
</code></pre>
<pre><code class="language-xml">&lt;!-- Maven --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;forkCount&gt;1&lt;/forkCount&gt;
        &lt;reuseForks&gt;true&lt;/reuseForks&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<h3>Kafka topic cleanup</h3>
<p>Kafka-related tests can optionally clean topics after each test method. From the README (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md"><code>/tmp/repo_fun8n87l/README.md</code></a>):</p>
<ul>
<li>Property: <code>fit4j.kafka.topicCleaner.enabled=true</code> (typically placed in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>).</li>
<li>When enabled, after each test method:</li>
<li>FIT4J iterates the used topics and purges messages, ensuring isolation between tests at the Kafka layer.</li>
</ul>
<p>This directly affects the <strong>post-test cleanup phase</strong> of the execution flow for tests using Kafka.</p>
<hr />
<h2>How to Reason About Your Own FIT Execution Flows</h2>
<p>When writing or debugging a FIT test, mentally walk through these steps:</p>
<ol>
<li><strong>Check the annotation</strong>:</li>
<li>Using <code>@FIT</code>? Then <code>Fit4JTestExtension</code> and declarative fixtures are in play.</li>
<li>Using <code>@IT</code> only? You have base integration infra but not full FIT features.</li>
<li><strong>Determine context sharing</strong>:</li>
<li>Are you using <code>@DirtiesContext</code> or configuration changes that force new contexts?</li>
<li>Are you relying on shared declarative fixtures loaded once per JVM?</li>
<li><strong>Identify fixtures</strong>:</li>
<li>Which YAML fixture group (<code>tests[*].name</code>) matches your test?</li>
<li>Any <code>@FixtureForFIT</code> annotations narrowing the group?</li>
<li><strong>Check mocking strategy</strong>:</li>
<li>Do you mock HTTP/gRPC externally via FIT4J fixtures?</li>
<li>Do you rely on embedded Kafka or other services?</li>
<li><strong>Track and verify</strong>:</li>
<li>Are you using <code>MockServiceCallTracker</code> to assert external calls?</li>
<li>Are there test-scoped beans or other state that must not leak between tests?</li>
</ol>
<p>Understanding these execution flows helps you design FIT tests that are deterministic, readable, and fast, and prevents subtle issues stemming from shared state or misconfigured fixtures.</p>
  </div>
</section>


<section id="section-http-testing-workflows" class="dw-section">
  <div class="dw-section-inner">
    <h1>HTTP Testing Workflows</h1>
<p>This page describes how HTTP integration tests are executed using Fit4J’s HTTP stack: <code>HttpTestFixture</code>, <code>HttpTestFixtureBuilder</code>, <code>MockWebServerProperties</code>, <code>HttpHeadersRegisteringRequestInterceptor</code>, programmatic fixture builders, and declarative <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> definitions. It focuses on the full request lifecycle in tests: from an outgoing HTTP call in your code, through the mock web server and fixture selection, to the generated response.</p>
<hr />
<h2>Overview of the HTTP Testing Stack</h2>
<p>Fit4J provides a layered mechanism for HTTP testing:</p>
<ul>
<li><strong>Declarative fixtures</strong>: YAML (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>) describing expected HTTP requests and mock responses.</li>
<li><strong>Fixture builders</strong>: <code>HttpTestFixtureBuilder</code> converts YAML maps into <code>HttpTestFixture</code> objects.</li>
<li><strong>Fixture runtime</strong>: <code>HttpTestFixture</code> chooses a response for a given <code>HttpRequest</code> and builds JSON response bodies.</li>
<li><strong>Mock response factory</strong>: <code>MockResponseFactory</code> looks up the right fixture based on the current test/group and request.</li>
<li><strong>Mock web server</strong>: <code>HttpServerWrapper</code> and <code>HttpServerDispatcher</code> expose fixtures as an HTTP server.</li>
<li><strong>Client-side integration</strong>: <code>RestTemplate</code>, Retrofit, or other clients talk to the mock server, with headers registered/inspected via <code>HttpHeadersRegisteringRequestInterceptor</code>.</li>
<li><strong>Auto-configuration</strong>: <code>TestHttpAutoConfiguration</code> wires these components for FIT tests.</li>
</ul>
<p>See [Glossary] for terminology like “Fixture Group”, “Predicate”, and “Expression Resolver”.</p>
<hr />
<h2>Declarative HTTP Fixtures (<code>fit4j-fixtures*.yml</code>)</h2>
<h3>YAML Structure and Semantics</h3>
<p>The core entry point for declarative HTTP workflows is the fixtures YAML. Typical files:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures-sample.yml"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures-sample.yml</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/group-state-cleanup-fixtures.yml"><code>/tmp/repo_fun8n87l/src/test/resources/group-state-cleanup-fixtures.yml</code></a></li>
</ul>
<p>Basic shape (simplified):</p>
<pre><code class="language-yaml">tests:
  - name: RestExampleFIT
    fixtures:
      - request:
          protocol: http
          path: &quot;/hello&quot;
          # optional: method, predicate, responses (multi), headers, etc.
          response:              # or 'responses:' for multiple sequential responses
            status: 200
            body:
              message: &quot;Hello, John!&quot;
</code></pre>
<p>Key concepts:</p>
<ul>
<li>
<p><code>tests[].name</code><br />
  Test/group name. It is matched against the current FIT test class or <code>@FixtureForFIT</code> annotation.<br />
  Example: in <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/group-state-cleanup-fixtures.yml#L1-L15"><code>/tmp/repo_fun8n87l/src/test/resources/group-state-cleanup-fixtures.yml:1-15</code></a> the group <code>"test-fixture-1"</code> is used.</p>
</li>
<li>
<p><code>fixtures[].request.protocol</code><br />
  Must be <code>http</code> for HTTP workflows. Other protocols (<code>grpc</code>) are supported by separate components (not covered here).</p>
</li>
<li>
<p><code>fixtures[].request.path</code><br />
  Path component of the expected request, e.g. <code>/foo</code>, <code>/foo/123</code>, <code>/foo?id=1</code>. Examples:</p>
</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures-sample.yml#L8-L21"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures-sample.yml:8-21</code></a></li>
<li>
<p><a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml#L33-L56"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml:33-56</code></a></p>
</li>
<li>
<p><code>fixtures[].request.method</code> (optional)<br />
  HTTP method, default is usually <code>GET</code> if omitted. Example with <code>POST</code>:
  <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml#L57-L66"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml:57-66</code></a></p>
</li>
<li>
<p><code>fixtures[].request.predicate</code> (optional)<br />
  A SpEL expression evaluated against the incoming request object. It lets you branch on:</p>
</li>
<li>
<p>HTTP body:<br />
<code>predicate: "#request.body == 'withBody'"</code><br />
    See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml#L57-L66"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml:57-66</code></a>.</p>
</li>
<li>
<p>HTTP method, query params, etc.:<br />
<code>predicate: "#request.method == 'GET'"</code><br />
    In <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures-sample.yml#L22-L35"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures-sample.yml:22-35</code></a>.</p>
</li>
<li>
<p><code>fixtures[].request.response</code> / <code>fixtures[].request.responses</code><br />
  Response definition(s).  </p>
</li>
<li>Single response: <code>response: { status, headers, body }</code>  </li>
<li>
<p>Sequential responses: <code>responses: - { status, body } - { … }</code> used to model stateful interactions:</p>
<p>```yaml</p>
<h1>/tmp/repo_fun8n87l/src/test/resources/group-state-cleanup-fixtures.yml:3-16</h1>
<ul>
<li>request:
    protocol: http
    path: "/test-1"
    responses:<ul>
<li>status: 500
    body: "Internal Server Error"</li>
<li>status: 404
    body: "Not Found"</li>
<li>status: 200
    body: "Success"
```</li>
</ul>
</li>
</ul>
<p>This sequence is verified in <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L9-L27"><code>/tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:9-27</code></a>.</p>
</li>
</ul>
<h3>Expression-Based Values (SpEL)</h3>
<p>YAML can contain SpEL expressions that reference Spring beans or fixture variables:</p>
<ul>
<li>
<p>Bean-based expressions:<br />
<code>id: "#{@testFixtureData.variables.fooId}"</code><br />
  See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml#L1-L20"><code>/tmp/repo_fun8n87l/src/test/resources/fit4j-fixtures.yml:1-20</code></a>.</p>
</li>
<li>
<p>In README example (<a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L40-L67"><code>/tmp/repo_fun8n87l/README.md:40-67</code></a>):</p>
</li>
</ul>
<p><code>yaml
  body: "#{@testFixtureCreator.EXAMPLE_RESPONSE}"</code></p>
<p>Here <code>testFixtureCreator</code> is a bean defined in the test config:<br />
<a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L68-L90"><code>/tmp/repo_fun8n87l/README.md:68-90</code></a>.</p>
<p>These expressions are evaluated via <code>ExpressionResolver</code> (see below) at runtime when building responses.</p>
<hr />
<h2><code>HttpTestFixtureBuilder</code>: Building Fixtures from YAML</h2>
<p><code>HttpTestFixtureBuilder</code> is responsible for transforming the YAML map into an executable <code>HttpTestFixture</code>:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/main/kotlin/org/fit4j/http/HttpTestFixtureBuilder.kt:1-22
class HttpTestFixtureBuilder(
    private val objectMapper: ObjectMapper,
    private val predicateEvaluator: PredicateEvaluator,
    private val expressionResolver: ExpressionResolver,
) : DeclarativeTestFixtureBuilder {

    override fun protocol(): String {
        return &quot;HTTP&quot;
    }

    override fun build(requestMap: Map&lt;String, Any&gt;): TestFixture {
        val requestPath : String? = requestMap[&quot;path&quot;]?.toString()
        // ...
    }
}
</code></pre>
<p>Key responsibilities:</p>
<ul>
<li>
<p><strong>Protocol identification</strong><br />
<code>protocol()</code> returns <code>"HTTP"</code>, so the declarative engine routes HTTP entries to this builder.</p>
</li>
<li>
<p><strong>Mapping requestMap → HttpTestFixture</strong>  </p>
</li>
<li>Reads <code>path</code>, <code>method</code>, <code>predicate</code>, <code>response</code>/<code>responses</code> from <code>requestMap</code>.</li>
<li>Creates a <code>TestFixturePredicate</code> with <code>PredicateEvaluator</code> (from <code>org.fit4j.mock.declarative.PredicateEvaluator</code>).</li>
<li>
<p>Builds <code>HttpTestFixtureResponse</code> instances from the <code>response(s)</code> field, potentially using <code>ObjectMapper</code> to handle body objects.</p>
</li>
<li>
<p><strong>ExpressionResolver injection</strong><br />
  The <code>expressionResolver</code> is passed into <code>HttpTestFixture</code> so SpEL expressions in bodies/headers can be resolved when the response is built.</p>
</li>
</ul>
<p>For details on <code>TestFixture</code> and <code>TestFixturePredicate</code>, see [Declarative Fixture Engine] (not this section).</p>
<hr />
<h2><code>HttpTestFixture</code>: Selecting and Building HTTP Responses</h2>
<p><code>HttpTestFixture</code> represents a single HTTP fixture instance:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/main/kotlin/org/fit4j/http/HttpTestFixture.kt:1-22
data class HttpTestFixture(
    val requestPath: String? = null,
    val method: String? = null,
    val predicate: TestFixturePredicate? = null,
    val expressionResolver: ExpressionResolver,
    val responses: List&lt;HttpTestFixtureResponse&gt; = listOf(HttpTestFixtureResponse(200))
) : TestFixture(predicate), HttpResponseJsonBuilder {

    override fun build(request: HttpRequest): String? {
        val response: HttpTestFixtureResponse = obtainResponse(request, responses) as HttpTestFixtureResponse

        return &quot;&quot;&quot;
                {
                &quot;status&quot;: ${response.statusCode},
                ...
        &quot;&quot;&quot;.trimIndent()
    }
}
</code></pre>
<p>Responsibilities:</p>
<ul>
<li><strong>Matching logic</strong>  </li>
<li><code>requestPath</code> is compared to the incoming <code>HttpRequest</code> path.</li>
<li><code>method</code> is compared to HTTP method.</li>
<li>
<p><code>predicate</code> (SpEL or similar) is evaluated using the incoming request as <code>#request</code> context.</p>
</li>
<li>
<p><strong>Sequential responses</strong><br />
  If <code>responses</code> contains multiple entries (as in the <a href="https://github.com/harezmi/fit4j/blob/main/group-state-cleanup-fixtures.yml"><code>group-state-cleanup-fixtures.yml</code></a> case), <code>obtainResponse</code> yields the next one in sequence on each call. This allows modeling stateful behaviour from a stateless server.</p>
</li>
<li>
<p><strong>Response body construction</strong><br />
  By implementing <code>HttpResponseJsonBuilder</code>, it returns JSON as <code>String</code>. The returned JSON usually looks like:</p>
</li>
</ul>
<p><code>json
  {
    "status": 200,
    "body": { ... },
    "headers": { ... }
  }</code></p>
<p>Internally, <code>expressionResolver</code> is used to evaluate any SpEL expressions inside <code>HttpTestFixtureResponse.responseBody</code>.</p>
<h3>Programmatic Fixture Creation</h3>
<p>In some cases, fixtures are not read from YAML but constructed programmatically:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt:39-57
val tf3 = HttpTestFixture(
    requestPath = &quot;/foo&quot;,
    expressionResolver = expressionResolver,
    responses = listOf(
        HttpTestFixtureResponse(statusCode = 200)
    )
)
val tf4 = HttpTestFixture(
    requestPath = &quot;/foo/123&quot;,
    expressionResolver = expressionResolver,
    responses = listOf(
        HttpTestFixtureResponse(
            statusCode = 200,
            responseBody = &quot;&quot;&quot;
                {
                   &quot;id&quot;: 123,
                   &quot;name&quot;: &quot;Foo&quot;
                }
            &quot;&quot;&quot;.trimIndent()
        )
    )
)
</code></pre>
<p>This is useful when:</p>
<ul>
<li>Response logic is complex and easier to express in Kotlin than YAML.</li>
<li>You want to reuse helper methods, constants, or data builders from your test code.</li>
</ul>
<hr />
<h2>Test HTTP Auto-Configuration and Mock Web Server</h2>
<h3><code>TestHttpAutoConfiguration</code></h3>
<p><code>TestHttpAutoConfiguration</code> wires together the HTTP testing components in a Spring Boot environment:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:1-40
@AutoConfiguration
@EnableOnFIT
class TestHttpAutoConfiguration {

    @Bean
    fun httpTestFixtureBuilder(
        objectMapper: ObjectMapper,
        predicateEvaluator: PredicateEvaluator,
        expressionResolver: ExpressionResolver
    ): HttpTestFixtureBuilder {
        // creates HttpTestFixtureBuilder
    }

    @Bean
    fun httpServerWrapper(
        mockWebServerProperties: MockWebServerProperties,
        dispatcher: HttpServerDispatcher
    ): HttpServerWrapper {
        // sets up embedded HTTP mock server
    }

    @Bean
    fun mockWebServerProperties(env: ConfigurableEnvironment): MockWebServerProperties {
        // reads properties like fit4j.mock.http.*
    }

    @Bean
    fun httpHeadersRegisteringRequestInterceptor(
        httpCallTraceFactory: HttpCallTraceFactory,
        headersSource: HttpHeadersSource
    ): HttpHeadersRegisteringRequestInterceptor {
        // interceptor bean for outgoing calls
    }

    // plus beans for DefaultHttpMockResponseProvider, JsonToHttpResponseConverter, etc.
}
</code></pre>
<p>Key pieces:</p>
<ul>
<li><strong><code>MockWebServerProperties</code></strong> (<code>org.fit4j.http.MockWebServerProperties</code>)<br />
  Holds configuration for the embedded mock server: host, port, base path, etc. Values are loaded from Spring <code>Environment</code> (e.g. <a href="https://github.com/harezmi/fit4j/blob/main/application.yml"><code>application.yml</code></a>) via <code>ConfigurableEnvironment.getProperty</code>. If you set:</li>
</ul>
<p><code>yaml
  fit4j.mock.http.port: 18080
  fit4j.mock.http.hostname: "localhost"</code></p>
<p>the mock server will listen there. Always ensure ports are not conflicting with your main app server.</p>
<ul>
<li>
<p><strong><code>HttpServerWrapper</code> and <code>HttpServerDispatcher</code></strong><br />
<code>HttpServerWrapper</code> manages server lifecycle (start/stop) and delegates to <code>HttpServerDispatcher</code> to route incoming requests to the correct <code>HttpTestFixture</code> via the <code>MockResponseFactory</code> / <code>DefaultHttpMockResponseProvider</code>.</p>
</li>
<li>
<p><strong><code>DefaultHttpMockResponseProvider</code> and <code>JsonToHttpResponseConverter</code></strong>  </p>
</li>
<li><code>DefaultHttpMockResponseProvider</code> fetches fixture data and builds intermediate response JSON using <code>HttpResponseJsonBuilder</code>.</li>
<li><code>JsonToHttpResponseConverter</code> converts this JSON to the wire-level HTTP response (status, headers, body).</li>
</ul>
<h3>Client-Side Setup and Use</h3>
<p>Your application under test usually uses HTTP clients like <code>RestTemplate</code> or Retrofit. In the README snippet (<a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L39"><code>/tmp/repo_fun8n87l/README.md:1-39</code></a>), external service configuration is:</p>
<pre><code class="language-kotlin">@ConfigurationProperties(&quot;externalService&quot;)
data class HttpProperties(
    val protocol: String = &quot;http&quot;,
    val hostname: String = &quot;localhost&quot;,
    val port: Int = 8080
)
</code></pre>
<p>For tests, you typically point this to the mock server (configured by <code>MockWebServerProperties</code>) so all outgoing calls are intercepted.</p>
<p><code>EmbeddedWebServerCreatingFIT</code> ensures that <code>TestRestTemplate</code> is available and that the embedded server is running:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/http/EmbeddedWebServerCreatingFIT.kt:1-23
@FIT
class EmbeddedWebServerCreatingFIT {
    @Autowired
    private lateinit var restTemplate: TestRestTemplate

    @Test
    fun `testRestTemplate should be available in environment running embedded server`() {
        val response = restTemplate.getForObject(&quot;/sayHello&quot;, String::class.java)
        Assertions.assertEquals(&quot;Hello World!&quot;, response)
    }
}
</code></pre>
<p>This test verifies that the test environment is properly bootstrapped with an HTTP server — usually your Spring Boot test application, distinct from the FIT mock HTTP server, but both can coexist.</p>
<hr />
<h2>Header Tracking: <code>HttpHeadersRegisteringRequestInterceptor</code></h2>
<p><code>HttpHeadersRegisteringRequestInterceptor</code> plays a role on the <strong>client side</strong> by recording outgoing HTTP headers:</p>
<ul>
<li>
<p>Declared as a bean in <code>TestHttpAutoConfiguration</code><br />
<a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt#L23-L40"><code>/tmp/repo_fun8n87l/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:23-40</code></a>.</p>
</li>
<li>
<p>Injects:</p>
</li>
<li><code>HttpCallTraceFactory</code> – builds call traces representing the HTTP call.</li>
<li><code>HttpHeadersSource</code> – registry of relevant headers to capture.</li>
</ul>
<p>On each outgoing HTTP request, this interceptor:</p>
<ol>
<li>Reads headers from the request (e.g., auth tokens, correlation IDs).</li>
<li>Registers them in the header source / call trace.</li>
<li>Optionally, exposes them to other parts of the testing stack (for assertions, logging, or fixture predicates).</li>
</ol>
<p>The behaviour is exercised indirectly in tests like <code>HttpHeadersRegistrationFIT</code>:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/http/HttpHeadersRegistrationFIT.kt:1-27
@FIT
class HttpHeadersRegistrationFIT {
    @Autowired
    private lateinit var testRestTemplate: TestRestTemplate

    @Test
    fun `headers should be captured`() {
        // testRestTemplate performs HTTP calls; interceptor captures headers
    }
}
</code></pre>
<p>This allows advanced test scenarios such as:</p>
<ul>
<li>Asserting that a downstream call included the right auth header.</li>
<li>Using headers in fixture predicates (<code>#request.headers[...]</code>) if supported by the <code>PredicateEvaluator</code>.</li>
</ul>
<hr />
<h2>Mock Response Factory and Group State</h2>
<p><code>MockResponseFactory</code> is central to finding and returning the right fixture for a request.</p>
<p>Usage example:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-27
class TestFixtureGroupStateCleanupFIT {
    @Autowired
    lateinit var mockResponseFactory: MockResponseFactory

    @Test
    @FixtureForFIT(&quot;test-fixture-1&quot;)
    fun `should should reset http fixtures and return a list of test fixtures 1`() {
        val request = createWebRequest(&quot;/test-1&quot;)
        val actualResponse1 = mockResponseFactory.getResponseFor(request) as HttpResponse
        val actualResponse2 = mockResponseFactory.getResponseFor(request) as HttpResponse
        val actualResponse3 = mockResponseFactory.getResponseFor(request) as HttpResponse
        val actualResponse4 = mockResponseFactory.getResponseFor(request) as HttpResponse

        // responses will be 500, 404, 200, then 200 again (after reset)
    }
}
</code></pre>
<p>How it works:</p>
<ol>
<li><code>@FixtureForFIT("test-fixture-1")</code> instructs Fit4J to use the fixture group called <code>"test-fixture-1"</code> from <a href="https://github.com/harezmi/fit4j/blob/main/group-state-cleanup-fixtures.yml"><code>group-state-cleanup-fixtures.yml</code></a>.</li>
<li><code>MockResponseFactory.getResponseFor(request)</code>:</li>
<li>Determines the current test group.</li>
<li>Finds the matching <code>HttpTestFixture</code> by path/method/predicate.</li>
<li>Delegates to the fixture to get the next response in the sequence.</li>
<li>After the sequence is exhausted, group state is reset so subsequent calls start over (verified by the 4th call in the test).</li>
</ol>
<p>This stateful behaviour is particularly useful for simulating:</p>
<ul>
<li>Retries (500 then 200).</li>
<li>Progressive resource creation flows (404 then 201).</li>
<li>Pagination or cursor-based endpoints with changing responses.</li>
</ul>
<hr />
<h2>Request Lifecycle: End-to-End Flow</h2>
<p>The HTTP testing workflow from your code’s perspective looks like this:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
sequenceDiagram
 participant A as Test code
 participant B as HTTP client
 participant C as Mock server
 participant D as Fixture engine
 A->>B: Invoke service call
 B->>C: Send HTTP request
 C->>D: Resolve fixture
 D-->>C: Build mock response
 C-->>B: Return HTTP response
 B-->>A: Return result
</div></div>
<p>Detailed steps:</p>
<ol>
<li><strong>Test code triggers HTTP call</strong>  </li>
<li>Using <code>TestRestTemplate</code>, Retrofit, or any HTTP client configured with <code>externalService.*</code> properties (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L39"><code>/tmp/repo_fun8n87l/README.md:1-39</code></a>).</li>
<li>
<p>Calls target the mock HTTP server address (from <code>MockWebServerProperties</code>).</p>
</li>
<li>
<p><strong>Request interception and header registration</strong>  </p>
</li>
<li>
<p><code>HttpHeadersRegisteringRequestInterceptor</code> (configured in <code>TestHttpAutoConfiguration</code>) records headers and traces the call.</p>
</li>
<li>
<p><strong>Mock server dispatch</strong>  </p>
</li>
<li>
<p><code>HttpServerWrapper</code> receives the HTTP request and delegates to <code>HttpServerDispatcher</code>.</p>
</li>
<li>
<p><strong>Fixture lookup</strong>  </p>
</li>
<li>
<p>Dispatcher uses <code>MockResponseFactory</code> (with <code>DeclarativeTestFixtureProvider</code>) to find <code>HttpTestFixture</code> matching:</p>
<ul>
<li>current test/group name (<code>tests[].name</code> or <code>@FixtureForFIT</code>),</li>
<li><code>protocol: http</code>,</li>
<li><code>path</code>, <code>method</code>, and <code>predicate</code>.</li>
</ul>
</li>
<li>
<p><strong>Response selection and creation</strong>  </p>
</li>
<li>Selected <code>HttpTestFixture</code> chooses the appropriate <code>HttpTestFixtureResponse</code>:<ul>
<li>first in list, or next in sequence for multi-response fixtures.</li>
</ul>
</li>
<li>
<p><code>HttpTestFixture.build(request)</code> uses <code>expressionResolver</code> and <code>ObjectMapper</code> to produce response JSON.</p>
</li>
<li>
<p><strong>HTTP response generation</strong>  </p>
</li>
<li><code>JsonToHttpResponseConverter</code> and <code>DefaultHttpMockResponseProvider</code> map the JSON to an actual HTTP status, headers, and body.</li>
<li>
<p>Mock server writes this back to the HTTP client.</p>
</li>
<li>
<p><strong>Test assertion</strong>  </p>
</li>
<li>Client returns the response to the test (<code>TestRestTemplate</code>, Retrofit, etc.).</li>
<li>Test asserts on status, body, headers, or side effects, using standard assertion libraries.</li>
</ol>
<hr />
<h2>Using Fixtures in Your Own HTTP Integration Tests</h2>
<h3>1. Basic Declarative HTTP Test</h3>
<p>Define fixtures in YAML:</p>
<pre><code class="language-yaml"># src/test/resources/fit4j-fixtures.yml
tests:
  - name: RestExampleFIT
    fixtures:
      - request:
          protocol: http
          path: &quot;/hello&quot;
          response:
            status: 200
            body:
              message: &quot;Hello, John!&quot;
</code></pre>
<p>Write a test:</p>
<pre><code class="language-kotlin">// src/test/kotlin/org/example/RestExampleFIT.kt
@FIT
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class RestExampleFIT(
    @Autowired private val restTemplate: TestRestTemplate
) {
    @Test
    fun `should get hello response`() {
        val response = restTemplate.getForObject(&quot;/hello&quot;, String::class.java)
        Assertions.assertEquals(&quot;&quot;&quot;{&quot;message&quot;:&quot;Hello, John!&quot;}&quot;&quot;&quot;, response)
    }
}
</code></pre>
<p>The <code>RestExampleFIT</code> name matches the YAML <code>tests[].name</code>, so the fixtures apply to this test.</p>
<h3>2. SpEL-Driven Variables</h3>
<p>Use test fixture data:</p>
<pre><code class="language-yaml"># src/test/resources/fit4j-fixtures.yml
tests:
  - name: HttpMockServiceResponseFactoryFIT
    fixtures:
      - request:
          protocol: http
          path: &quot;/foo/#{@testFixtureData.variables.fooId}&quot;
          response:
            status: 200
</code></pre>
<p>And define the bean in your test:</p>
<pre><code class="language-kotlin">// /tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/http/HttpMockServiceResponseFactoryFIT.kt:1-31
@FIT
class HttpMockServiceResponseFactoryFIT {
    @Autowired
    private lateinit var testFixture: TestFixtureData

    data class TestFixtureData(val variables: Variables)
    data class Variables(val fooId: Int)

    @TestConfiguration
    class TestConfig {
        @Bean
        fun testFixtureData() = TestFixtureData(Variables(fooId = 123))
    }

    @Test
    fun `should resolve fooId in path`() {
        // call /foo/123; fixture will match via SpEL
    }
}
</code></pre>
<p><code>ExpressionResolver</code> resolves <code>#{@testFixtureData.variables.fooId}</code> at runtime to <code>123</code>.</p>
<h3>3. Sequential Responses and Reset</h3>
<p>Use <code>responses</code> to model changing behaviour:</p>
<pre><code class="language-yaml"># src/test/resources/group-state-cleanup-fixtures.yml
tests:
  - name: &quot;test-fixture-1&quot;
    fixtures:
      - request:
          protocol: http
          path: &quot;/test-1&quot;
          responses:
            - status: 500
              body: &quot;Internal Server Error&quot;
            - status: 404
              body: &quot;Not Found&quot;
            - status: 200
              body: &quot;Success&quot;
</code></pre>
<p>In <code>TestFixtureGroupStateCleanupFIT</code><br />
(<a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L1-L27"><code>/tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-27</code></a>), repeated calls confirm the stateful sequence and subsequent reset.</p>
<hr />
<h2>Configuration Reference</h2>
<h3>Properties Affecting HTTP Test Behaviour</h3>
<p>While many details are auto-configured, the following properties typically matter:</p>
<ul>
<li><strong>Mock server configuration</strong> (via <code>MockWebServerProperties</code> in <code>TestHttpAutoConfiguration</code>):</li>
</ul>
<p><code>yaml
  fit4j.mock.http.hostname: "localhost"
  fit4j.mock.http.port: 18080
  fit4j.mock.http.base-path: "/"</code></p>
<p>These control where the mock HTTP server listens. Make sure your app’s HTTP client points to this host:port.</p>
<ul>
<li><strong>External client configuration</strong> (consumer application under test):</li>
</ul>
<p><code>yaml
  externalService:
    protocol: http
    hostname: localhost
    port: 18080</code></p>
<p>As shown in <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L39"><code>/tmp/repo_fun8n87l/README.md:1-39</code></a>, <code>HttpProperties</code> uses <code>@ConfigurationProperties("externalService")</code> to build the base URL (<code>http://localhost:18080</code>).</p>
<ul>
<li><strong>General FIT configuration</strong><br />
  Some properties may control fixture file locations or default group names. See the project’s configuration guide (not this section) for full details.</li>
</ul>
<p>No secrets or credentials should be stored in these properties; if you must specify tokens in tests, always mask them in shared docs, e.g.:</p>
<pre><code class="language-yaml">auth:
  token: &quot;token-****&quot;
</code></pre>
<hr />
<h2>When to Use Declarative vs Programmatic Workflows</h2>
<ul>
<li><strong>Declarative YAML</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures-sample.yml"><code>fit4j-fixtures-sample.yml</code></a>):</li>
<li>Best for simple static responses.</li>
<li>Easy to review and share with non-developers.</li>
<li>
<p>Supports SpEL for modest dynamic behaviour.</p>
</li>
<li>
<p><strong>Programmatic fixtures</strong> (<code>HttpTestFixture</code> instances, custom <code>HttpResponseJsonBuilder</code>):</p>
</li>
<li>Preferable when:<ul>
<li>Response logic depends on complex conditions.</li>
<li>You need loops, randomization, or heavy reuse of test utilities.</li>
</ul>
</li>
<li>Example: implement <code>HttpResponseJsonBuilder</code> in your test <code>@TestConfiguration</code> (see README snippet around <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L91-L132"><code>/tmp/repo_fun8n87l/README.md:91-132</code></a>).</li>
</ul>
<p>In most setups you mix both: use YAML for most endpoints and programmatic builders for complex cases.</p>
<hr />
<p>By understanding <code>HttpTestFixture</code>, <code>HttpTestFixtureBuilder</code>, the mock server (<code>HttpServerWrapper</code> / <code>HttpServerDispatcher</code>), and supporting components like <code>MockWebServerProperties</code> and <code>HttpHeadersRegisteringRequestInterceptor</code>, you can design robust, repeatable HTTP integration tests that fully simulate external services without hitting real networks.</p>
  </div>
</section>


<section id="section-grpc-testing-workflows" class="dw-section">
  <div class="dw-section-inner">
    <h1>gRPC Testing Workflows</h1>
<p>This page explains how Fit4J supports gRPC-based tests. It covers the auto-configuration that wires an in‑process gRPC server, how <code>GrpcTestFixture</code> and declarative fixtures drive mock responses, how JSON is converted to protobuf messages, how type descriptors are resolved, and how calls are intercepted, traced, and validated.</p>
<p>The intended reader is an engineer writing or extending gRPC integration/functional tests using Fit4J’s <code>@FIT</code> / <code>@IT</code> support.</p>
<hr />
<h2>Overview of gRPC Testing Support</h2>
<p>At a high level:</p>
<ul>
<li>An in‑process gRPC server is auto‑configured for integration/functional tests.</li>
<li>All gRPC services are wrapped by a <code>TestGrpcServiceConfigurer</code> that:</li>
<li>tracks calls (<code>MockServiceCallTracker</code>)</li>
<li>delegates response resolution to <code>MockResponseFactory</code>.</li>
<li>Responses are produced by:</li>
<li>declarative YAML fixtures (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>)</li>
<li>optional custom <code>GrpcResponseJsonBuilder</code> beans</li>
<li>default gRPC mock response provider.</li>
<li>JSON payloads in fixtures are converted to protobuf messages via <code>JsonToGrpcResponseConverter</code>.</li>
<li><code>GrpcTypeDescriptorsProvider</code> and user‑provided descriptor beans provide type information needed by <code>JsonFormat.TypeRegistry</code>.</li>
</ul>
<p>The rest of this document decomposes each of these pieces and how they work together in a typical test.</p>
<hr />
<h2>Auto-Configuration for gRPC Tests</h2>
<h3>IntegrationTestGrpcAutoConfiguration</h3>
<p><code>IntegrationTestGrpcAutoConfiguration</code> is a minimal auto‑configuration that activates on integration tests (<code>@EnableOnIT</code>) when an in‑process gRPC server factory is present:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/IntegrationTestGrpcAutoConfiguration.kt#L1-L16"><code>src/main/kotlin/org/fit4j/autoconfigure/IntegrationTestGrpcAutoConfiguration.kt:1-16</code></a></p>
<pre><code class="language-kotlin">@AutoConfiguration
@AutoConfigureAfter(GrpcServerFactoryAutoConfiguration::class)
@ConditionalOnBean(InProcessGrpcServerFactory::class)
@EnableOnIT
class IntegrationTestGrpcAutoConfiguration {
}
</code></pre>
<p>Key points:</p>
<ul>
<li>Depends on <code>GrpcServerFactoryAutoConfiguration</code> from <code>net.devh.boot.grpc.server</code>.</li>
<li>Only active when <code>InProcessGrpcServerFactory</code> is available.</li>
<li>Provides the base prerequisite for setting up gRPC tests (the server factory), while the real test wiring is done by <code>TestGrpcAutoConfiguration</code>.</li>
</ul>
<h3>TestGrpcAutoConfiguration</h3>
<p><code>TestGrpcAutoConfiguration</code> is the core piece for gRPC testing in FIT-style tests (<code>@EnableOnFIT</code>):</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L1-L80"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:1-80</code></a> (multiple fragments in context)</p>
<p>Important beans:</p>
<ul>
<li><strong>DefaultGrpcMockResponseProvider</strong></li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L40-L52"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:40-52</code></a></p>
<p><code>kotlin
  @Bean
  fun defaultGrpcServiceResponseProvider(
      jsonToGrpcResponseConverter: JsonToGrpcResponseConverter,
      declarativeTestFixtureProvider: DeclarativeTestFixtureProvider,
      grpcResponseJsonBuilders: List&lt;GrpcResponseJsonBuilder&lt;*&gt;&gt;
  ): DefaultGrpcMockResponseProvider {
      return DefaultGrpcMockResponseProvider(
          declarativeTestFixtureProvider,
          jsonToGrpcResponseConverter,
          grpcResponseJsonBuilders
      )
  }</code></p>
<ul>
<li>Aggregates:<ul>
<li>declarative fixtures (<code>DeclarativeTestFixtureProvider</code>),</li>
<li>JSON → protobuf conversion (<code>JsonToGrpcResponseConverter</code>),</li>
<li>any custom <code>GrpcResponseJsonBuilder</code> beans provided in the test.</li>
</ul>
</li>
<li>
<p>Implements a <code>MockResponseProvider</code> for gRPC calls.</p>
</li>
<li>
<p><strong>GrpcResponseBuilderRegistry</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L54-L57"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:54-57</code></a></p>
<p><code>kotlin
  @Bean
  fun grpcResponseBuilderRegistry(
      testGrpcServiceDefinitionProvider: TestGrpcServiceDefinitionProvider
  ): GrpcResponseBuilderRegistry {
      return GrpcResponseBuilderRegistry(testGrpcServiceDefinitionProvider)
  }</code></p>
<ul>
<li>Maintains mapping between gRPC methods and response builders.</li>
<li>
<p>Uses <code>TestGrpcServiceDefinitionProvider</code> to know which services/methods exist.</p>
</li>
<li>
<p><strong>JsonToGrpcResponseConverter</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L59-L66"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:59-66</code></a></p>
<p><code>kotlin
  @Bean
  fun rawJsonContentToGrpcResponseConverter(
      jsonContentExpressionResolver: JsonContentExpressionResolver,
      grpcResponseBuilderRegistry: GrpcResponseBuilderRegistry,
      jsonProtoParser: JsonFormat.Parser,
      objectMapper: ObjectMapper
  ): JsonToGrpcResponseConverter {
      return JsonToGrpcResponseConverter(
          jsonContentExpressionResolver,
          grpcResponseBuilderRegistry,
          jsonProtoParser,
          objectMapper
      )
  }</code></p>
<ul>
<li>Converts JSON content (possibly containing expressions) to concrete protobuf messages.</li>
<li>
<p>Uses:</p>
<ul>
<li><code>JsonContentExpressionResolver</code> for expression evaluation,</li>
<li><code>JsonFormat.Parser</code> for protobuf JSON parsing,</li>
<li><code>GrpcResponseBuilderRegistry</code> for mapping type/method to builders,</li>
<li>Jackson <code>ObjectMapper</code> for intermediate JSON handling.</li>
</ul>
</li>
<li>
<p><strong>GrpcTestFixtureBuilder</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L68-L75"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:68-75</code></a></p>
<p><code>kotlin
  @Bean
  fun grpcTestFixtureBuilder(
      objectMapper: ObjectMapper,
      predicateEvaluator: PredicateEvaluator,
  ): GrpcTestFixtureBuilder {
      return GrpcTestFixtureBuilder(objectMapper = objectMapper, predicateEvaluator = predicateEvaluator)
  }</code></p>
<ul>
<li>Builds <code>GrpcTestFixture</code> instances from declarative YAML definitions.</li>
<li>
<p>Uses <code>PredicateEvaluator</code> for SpEL-like predicates on requests.</p>
</li>
<li>
<p><strong>GrpcCallTraceFactory</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L77-L79"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:77-79</code></a></p>
<p><code>kotlin
  @Bean
  fun mockGrpcCallTraceFactory(): GrpcCallTraceFactory {
      return GrpcCallTraceFactory()
  }</code></p>
<ul>
<li>
<p>Factory that creates <code>GrpcCallTrace</code> instances to record each gRPC invocation.</p>
</li>
<li>
<p><strong>GrpcClassScanner &amp; TestGrpcServiceDefinitionProvider</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L81-L93"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:81-93</code></a></p>
<p>```kotlin
  @Bean
  fun grpcClassScanner(
      applicationContext: ApplicationContext,
      classScanner: ClassScanner
  ): GrpcClassScanner {
      return GrpcClassScanner(applicationContext.environment, classScanner)
  }</p>
<p>@Bean
  fun testGrpcServiceDefinitionProvider(
      grpcClassScanner: GrpcClassScanner,
      applicationContext: ApplicationContext
  ): TestGrpcServiceDefinitionProvider {
      return TestGrpcServiceDefinitionProvider(
          grpcClassScanner,
          applicationContext.environment
      )
  }
  ```</p>
<ul>
<li><code>GrpcClassScanner</code> discovers gRPC services/messages from the classpath and environment.</li>
<li>
<p><code>TestGrpcServiceDefinitionProvider</code> introspects these services to build <code>ServerServiceDefinition</code> data used for mocking.</p>
</li>
<li>
<p><strong>TestGrpcServiceConfigurer</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L95-L107"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:95-107</code></a></p>
<p><code>kotlin
  @Bean
  fun testGrpcServiceConfigurer(
      mockServiceCallTracker: MockServiceCallTracker,
      mockResponseFactory: MockResponseFactory,
      inProcessGrpcServerFactory: InProcessGrpcServerFactory,
      testGrpcServiceDefinitionProvider: TestGrpcServiceDefinitionProvider
  ): TestGrpcServiceConfigurer {
      return TestGrpcServiceConfigurer(
          mockServiceCallTracker,
          mockResponseFactory,
          inProcessGrpcServerFactory,
          testGrpcServiceDefinitionProvider
      )
  }</code></p>
<ul>
<li>Configures the in‑process server with wrappers around each gRPC method.</li>
<li>Delegates every incoming gRPC call to <code>MockResponseFactory</code> to obtain a mock response.</li>
<li>
<p>Tracks all calls via <code>MockServiceCallTracker</code> (used for validation/inspection).</p>
</li>
<li>
<p><strong>GrpcTypeDescriptorsProvider</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L109-L114"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:109-114</code></a></p>
<p><code>kotlin
  @Bean
  fun grpcTypeDescriptorsProvider(
      applicationContext: ApplicationContext,
      grpcClassScanner: GrpcClassScanner
  ): GrpcTypeDescriptorsProvider {
      return GrpcTypeDescriptorsProvider(applicationContext, grpcClassScanner)
  }</code></p>
<ul>
<li>Provides protobuf <code>Descriptors.Descriptor</code> instances used to build a <code>JsonFormat.TypeRegistry</code>.</li>
<li>
<p>Feeds into protobuf JSON parsing (<code>TestProtobufAutoConfiguration</code>).</p>
</li>
<li>
<p><strong>TestGrpcChannelConfigurer (companion object bean)</strong></p>
</li>
</ul>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L116-L121"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:116-121</code></a></p>
<p><code>kotlin
  companion object {
      @Bean
      fun testGrpcChannelNameConfigurer(
          genericApplicationContext: GenericApplicationContext
      ): TestGrpcChannelConfigurer {
          return TestGrpcChannelConfigurer(genericApplicationContext)
      }
  }</code></p>
<ul>
<li>Configures client channels to talk to the in‑process server.</li>
<li>Typically sets <code>grpc.client.inProcess.address</code> and similar properties (see README).</li>
</ul>
<hr />
<h2>Protobuf JSON &amp; Type Registry Auto-Configuration</h2>
<h3>TestProtobufAutoConfiguration</h3>
<p><code>TestProtobufAutoConfiguration</code> wires protobuf JSON support on FIT tests:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestProtobufAutoConfiguration.kt#L1-L24"><code>src/main/kotlin/org/fit4j/autoconfigure/TestProtobufAutoConfiguration.kt:1-24</code></a></p>
<pre><code class="language-kotlin">@AutoConfiguration
@ConditionalOnClass(JsonFormat::class)
@EnableOnFIT
class TestProtobufAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    fun jsonProtoParser(typeRegistry: JsonFormat.TypeRegistry): JsonFormat.Parser {
        return JsonFormat.parser().usingTypeRegistry(typeRegistry)
    }

    @Bean
    // (TypeRegistry bean likely defined here based on GrpcTypeDescriptorsProvider)
}
</code></pre>
<ul>
<li>Activated only if <code>JsonFormat</code> (protobuf util) is on the classpath.</li>
<li>Exposes a <code>JsonFormat.Parser</code> configured with a <code>TypeRegistry</code>.</li>
<li>The <code>TypeRegistry</code> is typically assembled from:</li>
<li><code>GrpcTypeDescriptorsProvider</code> (auto discovery),</li>
<li>and/or user‑defined descriptor beans (see below).</li>
</ul>
<h3>Providing Type Descriptors in Tests</h3>
<p><code>GrpcTypeDescriptorsFIT</code> shows how a test can explicitly provide descriptors:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/grpc/GrpcTypeDescriptorsFIT.kt#L1-L35"><code>src/test/kotlin/org/fit4j/grpc/GrpcTypeDescriptorsFIT.kt:1-35</code></a></p>
<pre><code class="language-kotlin">@FIT
class GrpcTypeDescriptorsFIT {

    @Autowired
    private lateinit var jsonHelper: JsonHelper

    @TestConfiguration
    class TestConfig {
        @Bean
        fun grpcTypeDescriptors1(): List&lt;Descriptors.Descriptor&gt; {
            return listOf(TestGrpc.GetFooListGrpcRequest.getDescriptor())
        }

        @Bean
        // additional descriptor beans can be declared here
    }
}
</code></pre>
<ul>
<li><code>GrpcTypeDescriptorsProvider</code> will pick up beans of type <code>List&lt;Descriptors.Descriptor&gt;</code>.</li>
<li>These descriptors augment the type registry used by JSON parsing.</li>
<li>This is essential when:</li>
<li>Your fixture JSON contains nested message types that are not auto-detected.</li>
<li>You want to cover dynamic or envelope message types (e.g., <code>google.protobuf.Any</code>).</li>
</ul>
<hr />
<h2>Declarative gRPC Fixtures (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>)</h2>
<p>Fit4J’s core workflow for gRPC testing is fixture-driven. You declare test-specific gRPC request/response templates in YAML, which are read by <code>DeclarativeTestFixtureProvider</code> and transformed into <code>GrpcTestFixture</code> instances.</p>
<h3>Basic Fixture Structure</h3>
<p>Example global and named gRPC fixtures:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L28"><code>src/test/resources/fit4j-fixtures.yml:1-28</code></a></p>
<pre><code class="language-yaml">tests:
  - name: &quot;*&quot;
    fixtures:
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.TestGrpc$PingRequest
          response:
            status: &quot;OK&quot;

  - name: AnotherSampleGrpcFIT
    fixtures:
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.TestGrpc$GetFooByIdRequest
          response:
            body:
              foo:
                id: 123
                name: &quot;Foo&quot;

  - name: SampleGrpcFIT
    fixtures:
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.TestGrpc$GetAgeRequest
          predicate: &quot;#request.name == 'Foo' &amp;&amp; #request.surname == 'Bar'&quot;
          response:
            body:
              age: 10
</code></pre>
<p>Concepts:</p>
<ul>
<li><code>tests[].name</code>:</li>
<li><code>*</code> acts as a wildcard (applies to all tests unless overridden).</li>
<li>Specific test names (e.g., <code>SampleGrpcFIT</code>) override or extend global fixtures.</li>
<li><code>fixtures[].request.protocol: grpc</code> indicates this fixture targets gRPC calls.</li>
<li><code>fixtures[].request.type</code> is a fully-qualified protobuf request class, including nested <code>$</code> naming.</li>
<li><code>fixtures[].request.predicate</code> (optional) is a SpEL-like expression evaluated against the actual request.</li>
<li><code>fixtures[].response</code>:</li>
<li><code>status</code>: maps to gRPC <code>Status</code> code names (e.g., <code>"OK"</code>, <code>"PERMISSION_DENIED"</code>).</li>
<li><code>body</code>: JSON structure matching the expected protobuf response type.</li>
</ul>
<p>An additional example from the example module:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-grpc/src/test/resources/fit4j-fixtures.yml#L1-L22"><code>fit4j-examples/example-grpc/src/test/resources/fit4j-fixtures.yml:1-22</code></a></p>
<pre><code class="language-yaml">tests:
  - name: GrpcExampleWithDeclarativeFixtureFIT
    fixtures:
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.FooGrpcService$GetFooByIdRequest
          predicate: &quot;#request.id == 123&quot;
          response:
            body:
              foo:
                id: 123
                name: &quot;Foo1&quot;
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.FooGrpcService$GetFooByIdRequest
          predicate: &quot;#request.id == 456&quot;
          response:
            body:
              foo:
                id: 456
                name: &quot;Foo2&quot;
  - name: &quot;*&quot;
    fixtures:
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.FooGrpcService$GetFooNameByIdRequest
          predicate: &quot;#request.id == 123&quot;
</code></pre>
<p>Here:</p>
<ul>
<li>Multiple fixtures exist for the same request type, discriminated by <code>predicate</code> on <code>request.id</code>.</li>
<li>A wildcard fixture covers calls not matched by more specific fixtures.</li>
</ul>
<hr />
<h2>GrpcTestFixture and Response Selection</h2>
<h3>GrpcTestFixture</h3>
<p><code>GrpcTestFixture</code> represents an in-memory fixture definition for a gRPC request:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/GrpcTestFixture.kt#L1-L20"><code>src/main/kotlin/org/fit4j/grpc/GrpcTestFixture.kt:1-20</code></a></p>
<pre><code class="language-kotlin">data class GrpcTestFixture(
    val requestType: Class&lt;*&gt; = Message::class.java,
    val predicate: TestFixturePredicate? = null,
    val responses: List&lt;GrpcTestFixtureResponse&gt; = listOf(GrpcTestFixtureResponse(statusCode = 0))
) : TestFixture(predicate), GrpcResponseJsonBuilder&lt;Message&gt; {

    override fun build(request: Message): String? {
        val response: GrpcTestFixtureResponse =
            obtainResponse(request, responses) as GrpcTestFixtureResponse
        return if (response.statusCode &gt; 0) {
            &quot;&quot;&quot;
                throw {
                    &quot;status&quot;: &quot;${io.grpc.Status.fromCodeValue(response.statusCode).code.name}&quot;
        &quot;&quot;&quot;.trimIndent()
        } else {
            // JSON body serialization is handled by JsonToGrpcResponseConverter
            // (implementation not fully shown in snippet)
        }
    }
}
</code></pre>
<p>Key behaviors:</p>
<ul>
<li><code>requestType</code>: the protobuf request class this fixture applies to.</li>
<li><code>predicate</code>: optional test fixture predicate (wrapping the predicate expression provided in YAML).</li>
<li><code>responses</code>: list of potential responses; <code>obtainResponse</code> selects based on call count etc. (see <code>TestFixture</code> semantics).</li>
<li>Implements <code>GrpcResponseJsonBuilder&lt;Message&gt;</code>:</li>
<li><code>build(request)</code> returns JSON describing either:<ul>
<li>a “throw” directive for gRPC errors, or</li>
<li>a JSON body for successful responses.</li>
</ul>
</li>
</ul>
<p>The <code>throw</code> JSON is a convention understood by <code>JsonToGrpcResponseConverter</code> to generate a <code>StatusRuntimeException</code> (see below).</p>
<h3>Custom GrpcResponseJsonBuilder</h3>
<p>In addition to declarative fixtures, you can provide custom response logic by declaring a <code>GrpcResponseJsonBuilder</code> bean in your test:</p>
<p><code>README.md:Sample FIT snippet</code></p>
<pre><code class="language-kotlin">@FIT
class SampleFIT {

    @TestConfiguration
    class TestConfig {
        @Bean
        fun grpcResponseJsonBuilder(): GrpcResponseJsonBuilder&lt;Message&gt; {
            return GrpcResponseJsonBuilder { request -&gt;
                if (request is GetFooByIdRequest) {
                    &quot;&quot;&quot;
                        throw {
                            &quot;status&quot;: &quot;PERMISSION_DENIED&quot;
                        }
                    &quot;&quot;&quot;.trimIndent()
                } else {
                    null
                }
            }
        }
    }

    @Test
    fun `test something`() {
        // perform your test here
    }
}
</code></pre>
<p>Notes:</p>
<ul>
<li>Returning <code>null</code> means “no opinion”; other providers (fixtures, default provider) may still supply a response.</li>
<li>Returning a <code>throw</code> JSON instructs the pipeline to return a gRPC error instead of a message.</li>
<li>This is the right tool when:</li>
<li>your mock behavior is too dynamic to express declaratively in YAML, or</li>
<li>you want to override specific edge cases for certain tests.</li>
</ul>
<hr />
<h2>JsonToGrpcResponseConverter and Error Handling</h2>
<p><code>JsonToGrpcResponseConverter</code> is responsible for turning JSON (plain or with expressions) into actual gRPC responses or errors:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/JsonToGrpcResponseConverter.kt#L1-L24"><code>src/main/kotlin/org/fit4j/grpc/JsonToGrpcResponseConverter.kt:1-24</code></a></p>
<pre><code class="language-kotlin">class JsonToGrpcResponseConverter(
    private val jsonContentExpressionResolver: JsonContentExpressionResolver,
    private val grpcResponseBuilderRegistry: GrpcResponseBuilderRegistry,
    private val jsonProtoParser: JsonFormat.Parser,
    private val objectMapper: ObjectMapper
) : JsonToMockResponseConverter {
    // implementation not fully shown
}
</code></pre>
<p>Core responsibilities (based on usage):</p>
<ol>
<li>
<p><strong>Resolve content expressions</strong><br />
   Uses <code>JsonContentExpressionResolver</code> to evaluate any expressions in JSON (e.g., referencing request fields, test variables).</p>
</li>
<li>
<p><strong>Interpret "throw" JSON</strong><br />
   For JSON like:</p>
</li>
</ol>
<p><code>json
   {
     "throw": {
       "status": "PERMISSION_DENIED"
     }
   }</code></p>
<p>or the shorthand in <code>GrpcTestFixture.build</code>:</p>
<p><code>json
   throw {
     "status": "PERMISSION_DENIED"
   }</code></p>
<p>the converter produces a <code>StatusRuntimeException</code>:</p>
<ul>
<li>Maps <code>status</code> string to <code>io.grpc.Status.Code</code>.</li>
<li>
<p>Constructs <code>StatusRuntimeException(Status.PERMISSION_DENIED)</code>.</p>
</li>
<li>
<p><strong>Build concrete protobuf responses</strong><br />
   For JSON response bodies, it:</p>
</li>
<li>
<p>Looks up relevant <code>GrpcResponseBuilder</code> from <code>GrpcResponseBuilderRegistry</code> for the request method.</p>
</li>
<li>Uses <code>jsonProtoParser</code> (with type registry) to merge JSON into a protobuf builder.</li>
<li>Returns a concrete <code>Message</code> instance to be sent by the server stub.</li>
</ul>
<p>Error path mapping is explicit in tests:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/grpc/GrpcMockServiceResponseFactoryFIT.kt#L1-L40"><code>src/test/kotlin/org/fit4j/grpc/GrpcMockServiceResponseFactoryFIT.kt:1-40</code></a></p>
<pre><code class="language-kotlin">@FIT
class GrpcMockServiceResponseFactoryFIT {

    @Autowired
    private lateinit var mockResponseFactory: MockResponseFactory

    // tests assert that gRPC error statuses (e.g. NOT_FOUND, PERMISSION_DENIED)
    // are mapped correctly to StatusRuntimeException
}
</code></pre>
<p>This FIT verifies that when fixtures or builders specify <code>status</code>, clients receive the corresponding <code>StatusRuntimeException</code> (e.g., <code>Status.NOT_FOUND</code>).</p>
<hr />
<h2>TestGrpcServiceConfigurer and Call Interception</h2>
<p><code>TestGrpcServiceConfigurer</code> is the glue between the in‑process gRPC server and Fit4J’s mock response system:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt#L1-L30"><code>src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt:1-30</code></a></p>
<pre><code class="language-kotlin">class TestGrpcServiceConfigurer(
    private val mockServiceCallTracker: MockServiceCallTracker,
    private val mockResponseFactory: MockResponseFactory,
    private val inProcessGrpcServerFactory: InProcessGrpcServerFactory,
    private val testGrpcServiceDefinitionProvider: TestGrpcServiceDefinitionProvider
) {

    @PostConstruct
    fun init() {
        // Typically:
        // - obtain ServerServiceDefinitions from testGrpcServiceDefinitionProvider
        // - wrap each method with ServerCalls.asyncUnaryCall or similar
        // - register them on inProcessGrpcServerFactory
        // - record calls into mockServiceCallTracker
        // (exact implementation is not in snippet but can be inferred)
    }
}
</code></pre>
<p>Conceptually, for each gRPC method:</p>
<ol>
<li>Wrap the method handler with a generic unary method:</li>
</ol>
<p>```kotlin
   val unary: UnaryMethod<ReqT, RespT> = UnaryMethod { request, responseObserver -&gt;
       val trace = grpcCallTraceFactory.createTrace(methodDescriptor, request)
       mockServiceCallTracker.track(trace)</p>
<pre><code>   val response = mockResponseFactory.createResponse(trace)
   when (response) {
       is StatusRuntimeException -&gt; responseObserver.onError(response)
       is Message              -&gt; {
           responseObserver.onNext(response as RespT)
           responseObserver.onCompleted()
       }
   }
</code></pre>
<p>}
   ```</p>
<ol>
<li>Replace the original method definition in <code>ServerServiceDefinition</code> with this wrapper.</li>
<li>Register the modified service definition with <code>InProcessGrpcServerFactory</code>.</li>
</ol>
<p>The result:</p>
<ul>
<li>Every gRPC call is intercepted in-process.</li>
<li>No real server implementation is required for tests.</li>
<li>Behavior is entirely controlled by fixtures and builders.</li>
</ul>
<hr />
<h2>GrpcCallTrace: Capturing and Validating Calls</h2>
<p><code>GrpcCallTraceFactory</code> (see above) creates <code>GrpcCallTrace</code> objects to represent each intercepted call. While the snippet for <code>GrpcCallTrace</code> itself is not shown, its typical responsibilities include:</p>
<ul>
<li>Method identifier (service + method name).</li>
<li>Request type and serialized content.</li>
<li>Selected response or error.</li>
<li>Timestamps, call index.</li>
</ul>
<p><code>MockServiceCallTracker</code> keeps track of these traces:</p>
<ul>
<li>Allows tests to assert:</li>
<li>“Method X was called N times.”</li>
<li>“The second call to <code>GetFooById</code> had <code>id == 123</code>.”</li>
<li>Fits naturally into FIT validations and assertions.</li>
</ul>
<p>For example, an integration‑style test:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDrivenResponseGenerationFIT.kt#L1-L25"><code>src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDrivenResponseGenerationFIT.kt:1-25</code></a></p>
<pre><code class="language-kotlin">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FIT(&quot;classpath:declarative-response-generation-fixture.yml&quot;)
@TestPropertySource(properties = [
    // Additional properties here, e.g., host/port for HTTP components
])
class DeclarativeTestFixtureDrivenResponseGenerationFIT {

    @GrpcClient(&quot;inProcess&quot;)
    lateinit var fooClient: FooGrpcServiceGrpc.FooGrpcServiceBlockingStub

    @Autowired
    lateinit var mockServiceCallTracker: MockServiceCallTracker

    @Test
    fun `validates gRPC interactions`() {
        // Exercise gRPC client calls via fooClient
        // Assert mockServiceCallTracker state to verify calls and payloads
    }
}
</code></pre>
<p>Though the call-trace specific API is not shown in the snippets, this is the typical usage pattern: exercise gRPC calls and validate via <code>mockServiceCallTracker</code>.</p>
<hr />
<h2>gRPC Type Descriptors Resolution</h2>
<p><code>GrpcTypeDescriptorsProvider</code> is central to mapping between JSON and protobuf types:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L109-L114"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:109-114</code></a></p>
<pre><code class="language-kotlin">@Bean
fun grpcTypeDescriptorsProvider(
    applicationContext: ApplicationContext,
    grpcClassScanner: GrpcClassScanner
): GrpcTypeDescriptorsProvider {
    return GrpcTypeDescriptorsProvider(applicationContext, grpcClassScanner)
}
</code></pre>
<p>Responsibilities (based on tests and configuration):</p>
<ol>
<li><strong>Scan for descriptor providers</strong></li>
<li>Uses <code>GrpcClassScanner</code> to discover:<ul>
<li>Generated gRPC/protobuf types (e.g., <code>TestGrpc</code>, <code>FooGrpcService</code>).</li>
<li>Beans of type <code>List&lt;Descriptors.Descriptor&gt;</code> (as in <code>GrpcTypeDescriptorsFIT</code>).</li>
</ul>
</li>
<li><strong>Produce descriptors list</strong></li>
<li>Aggregates descriptors into a list for building a protobuf <code>TypeRegistry</code>.</li>
<li><strong>Integrate with <code>TestProtobufAutoConfiguration</code></strong></li>
<li>The resulting type registry is bound to <code>JsonFormat.Parser</code> via <code>TestProtobufAutoConfiguration</code>.</li>
<li><strong>Support dynamic messages</strong></li>
<li>Typically required for:<ul>
<li><code>Any</code> fields (<code>com.google.protobuf.Any</code>).</li>
<li>Nested messages referenced only in JSON.</li>
</ul>
</li>
</ol>
<p>When adding new gRPC services to your tests, ensure that:</p>
<ul>
<li>Their descriptors are discoverable (usually automatic for standard generated code), or</li>
<li>You provide explicit descriptor beans as shown in <code>GrpcTypeDescriptorsFIT</code>.</li>
</ul>
<hr />
<h2>End-to-End Flow of a gRPC Test Call</h2>
<p>The following diagram summarizes the runtime flow when a gRPC client call is made in a FIT test:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
sequenceDiagram
 participant A as TestClient
 participant B as InProcessServer
 participant C as MockResponseFactory
 participant D as JsonToGrpcConverter
 A->>B: gRPC request
 B->>C: Build mock response
 C->>D: Convert JSON to proto
 D-->>C: Proto or error
 C-->>B: Response or exception
 B-->>A: gRPC reply
</div></div>
<p>Narrative description:</p>
<ol>
<li>
<p><strong>TestCode → gRPC client</strong><br />
   In your test, you use a <code>@GrpcClient</code> stub (e.g., <code>FooGrpcServiceBlockingStub</code>) to call a method.</p>
</li>
<li>
<p><strong>Client → InProcessServer</strong><br />
   The client talks to the in‑process server created by <code>InProcessGrpcServerFactory</code> and wired by <code>TestGrpcServiceConfigurer</code>.</p>
</li>
<li>
<p><strong>Server → MockResponseFactory</strong><br />
   The wrapper method built by <code>TestGrpcServiceConfigurer</code> constructs a <code>GrpcCallTrace</code>, tracks it, and asks <code>MockResponseFactory</code> for a response.</p>
</li>
<li>
<p><strong>MockResponseFactory → DefaultGrpcMockResponseProvider</strong><br />
   Internally, <code>MockResponseFactory</code> delegates to providers such as <code>DefaultGrpcMockResponseProvider</code> which:</p>
</li>
<li>collects all candidate <code>GrpcResponseJsonBuilder</code> sources (fixtures, custom builders),</li>
<li>selects the appropriate one (predicate evaluation etc.),</li>
<li>
<p>obtains a JSON response description.</p>
</li>
<li>
<p><strong>JSON → JsonToGrpcResponseConverter</strong><br />
   The JSON description is passed to <code>JsonToGrpcResponseConverter</code> to:</p>
</li>
<li>resolve expressions,</li>
<li>decide if it is an error or a normal response,</li>
<li>
<p>for normal responses, use <code>JsonFormat.Parser</code> with TypeRegistry to build a protobuf message.</p>
</li>
<li>
<p><strong>Return path</strong><br />
   The server either:</p>
</li>
<li>calls <code>onNext</code> + <code>onCompleted</code> with the protobuf response, or</li>
<li>
<p>calls <code>onError</code> with a <code>StatusRuntimeException</code>.</p>
</li>
<li>
<p><strong>Validation</strong><br />
   After the test interactions, you can:</p>
</li>
<li>verify client-returned results,</li>
<li>inspect <code>MockServiceCallTracker</code> for call traces.</li>
</ol>
<hr />
<h2>How to Use These Workflows in Your Tests</h2>
<h3>1. Enable FIT/IT and Include gRPC Services</h3>
<ul>
<li>Annotate your test with <code>@FIT</code> or use a FIT configuration.</li>
<li>Ensure your gRPC service stubs and protobuf messages are in the test classpath.</li>
<li>Ensure <code>net.devh.boot.grpc.server</code> and <code>net.devh.boot.grpc.client</code> dependencies are present.</li>
</ul>
<h3>2. Provide Declarative Fixtures</h3>
<ul>
<li>Create a <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> in your test resources.</li>
<li>Define gRPC fixtures as shown above (<code>protocol: grpc</code>, <code>type: &lt;RequestClass&gt;</code>, <code>predicate</code>, <code>response</code>).</li>
<li>Map test names in <code>tests[].name</code> to your test classes.</li>
</ul>
<h3>3. (Optional) Add Custom GrpcResponseJsonBuilder</h3>
<ul>
<li>For complex or dynamic behaviors, define a <code>GrpcResponseJsonBuilder&lt;Message&gt;</code> bean in a <code>@TestConfiguration</code> inside your test class.</li>
<li>Use <code>throw { "status": "..." }</code> to simulate error responses.</li>
</ul>
<h3>4. (Optional) Provide Additional Descriptors</h3>
<ul>
<li>If your messages use dynamic/nested types not discovered by default, define beans returning <code>List&lt;Descriptors.Descriptor&gt;</code> as in <code>GrpcTypeDescriptorsFIT</code>.</li>
</ul>
<h3>5. Validate Calls</h3>
<ul>
<li>Autowire <code>MockServiceCallTracker</code> to inspect <code>GrpcCallTrace</code> entries and assert call counts and request payloads.</li>
<li>Use standard JUnit assertions to verify behavior.</li>
</ul>
<hr />
<h2>Configuration and Properties</h2>
<p>While not all properties appear in the snippets, the system typically relies on:</p>
<ul>
<li>
<p><strong>gRPC in‑process server address</strong><br />
  Automatically configured by <code>TestGrpcChannelConfigurer</code> so that <code>@GrpcClient</code> stubs work without manual configuration.<br />
  If you need to override it, you can rely on standard <code>grpc.client.*</code> Spring Boot properties, masking any credentials (<code>password=********</code>).</p>
</li>
<li>
<p><strong>Fixture location</strong><br />
  Set by <code>@FIT("classpath:...")</code> as shown in <code>DeclarativeTestFixtureDrivenResponseGenerationFIT</code>.</p>
</li>
</ul>
<p>For general configuration patterns and property naming, see the main project README and the Configuration Guide section of the wiki.</p>
<hr />
<p>By understanding these components—auto‑configuration, fixtures, response conversion, type descriptors, and call tracing—you can write expressive, maintainable gRPC tests that rely entirely on Fit4J’s declarative and programmatic mocking facilities, with minimal boilerplate and no real service implementations.</p>
  </div>
</section>


<section id="section-kafka-messaging-workflows" class="dw-section">
  <div class="dw-section-inner">
    <h1>Kafka Messaging Workflows</h1>
<p>This page describes how FIT4J orchestrates Kafka-based integration tests: how embedded Kafka is enabled, how test consumers are defined declaratively in YAML, how messages are tracked via <code>KafkaMessageTracker</code> and <code>KafkaMessageTrackerAspect</code>, and how tests assert on produced and consumed messages. It focuses on the Kafka-related auto-configuration and test patterns used throughout the repository.</p>
<hr />
<h2>Overview of Kafka Testing in FIT4J</h2>
<p>Kafka support in FIT4J is built around four main elements:</p>
<ul>
<li><strong>Embedded Kafka broker</strong> – provided either by FIT4J’s <code>@EnableEmbeddedKafka</code> or Spring Kafka’s <code>@EmbeddedKafka</code>.</li>
<li><strong>Declarative consumer definitions</strong> – YAML file (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-kafka-consumers.yml"><code>fit4j-kafka-consumers.yml</code></a>) describing test Kafka consumers.</li>
<li><strong>Message tracking</strong> – <code>KafkaMessageTracker</code> and <code>KafkaMessageTrackerAspect</code> to await and assert processing of messages.</li>
<li><strong>Auto-configuration</strong> – <code>TestKafkaAutoConfiguration</code> wires everything together when Kafka is enabled in the environment.</li>
</ul>
<p>At a high level, a typical workflow is:</p>
<ol>
<li>A test class enables FIT4J and embedded Kafka.</li>
<li>FIT4J auto-configuration reads consumer definitions from YAML and registers <code>TestMessageListener</code> containers.</li>
<li>The test publishes messages via <code>KafkaTemplate</code>.</li>
<li>Service code and/or test listeners consume these messages; <code>KafkaMessageTrackerAspect</code> intercepts <code>@KafkaListener</code> methods.</li>
<li>The test uses <code>KafkaMessageTracker</code> or a helper to wait for and verify message processing.</li>
</ol>
<hr />
<h2>Enabling Embedded Kafka</h2>
<h3>Annotations and When to Use Them</h3>
<p>Two approaches are supported:</p>
<ol>
<li><strong>FIT4J embedded Kafka</strong></li>
</ol>
<p>```kotlin
   import org.fit4j.kafka.EnableEmbeddedKafka
   import org.fit4j.annotation.FIT</p>
<p>@EnableEmbeddedKafka
   @FIT
   class SampleFIT {
       // Your test code
   }
   <code>``
   See [</code>src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt:7-19<code>](https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt#L7-L19) and [</code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt:7-21`](https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L7-L21).</p>
<ol>
<li><strong>Spring Kafka embedded Kafka</strong></li>
</ol>
<p>```kotlin
   import org.springframework.kafka.test.context.EmbeddedKafka
   import org.fit4j.annotation.FIT</p>
<p>@EmbeddedKafka
   @FIT
   class SampleFIT {
       // Your test code
   }
   <code>``
   See [</code>src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspectFIT.kt:7-18<code>](https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspectFIT.kt#L7-L18) and [</code>src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt:7-22`](https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt#L7-L22).</p>
<p>When using Spring’s <code>@EmbeddedKafka</code>, the Spring docs recommend adding <code>@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)</code> to avoid race conditions and to ensure the embedded broker is shut down properly. See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L9-L20"><code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt:9-20</code></a>.</p>
<h3>Auto-configuration Trigger</h3>
<p><code>TestKafkaAutoConfiguration</code> activates only when:</p>
<ul>
<li>The test is annotated with <code>@FIT</code> (via <code>@EnableOnFIT</code> meta-annotation).</li>
<li><code>spring.kafka.bootstrap-servers</code> is present in the environment.</li>
</ul>
<p>This is verified by:</p>
<ul>
<li>Enabled case: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt#L7-L22"><code>src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt:7-22</code></a></li>
<li>Disabled case: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationDisabledFIT.kt#L7-L22"><code>src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationDisabledFIT.kt:7-22</code></a></li>
</ul>
<p>In the enabled case, a <code>TestMessageListener</code> bean must be present, and Kafka bootstrap servers must be configured.</p>
<hr />
<h2>Declarative Test Consumers from YAML</h2>
<h3>Defining Consumers</h3>
<p>Test Kafka consumers are defined declaratively in a YAML file located on the test classpath, usually named <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-kafka-consumers.yml"><code>fit4j-kafka-consumers.yml</code></a> (default), but can be overridden per test class.</p>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L10-L24"><code>README.md:10-24</code></a>:</p>
<pre><code class="language-yml">- consumer:
    topic: sample-topic-1
    containerFactory:
      consumerFactory:
        configs:
          - key.deserializer: org.apache.kafka.common.serialization.StringDeserializer
          - value.deserializer: org.apache.kafka.common.serialization.StringDeserializer
      containerProperties:
        ackMode: MANUAL_IMMEDIATE
        groupId: sample-consumer-group
</code></pre>
<p>Key fields:</p>
<ul>
<li><code>topic</code> – the Kafka topic to consume from; this can be resolved dynamically using <code>TopicNameExpressionResolver</code>.</li>
<li><code>containerFactory.consumerFactory.configs</code> – low-level consumer configs such as deserializers.</li>
<li><code>containerProperties.ackMode</code> – acknowledgment strategy (<code>MANUAL_IMMEDIATE</code>, etc.).</li>
<li><code>containerProperties.groupId</code> – consumer group id used by the test consumer.</li>
</ul>
<p>For each consumer definition, the library registers a <code>TestMessageListener</code> that will track messages for verification. See <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L24-L32"><code>README.md:24-32</code></a>.</p>
<h3>Loading Consumer Definitions</h3>
<p><code>TestKafkaAutoConfiguration</code> wires a <code>TestKafkaConsumerDefinitionProvider</code> which reads YAML and registers consumers:</p>
<pre><code class="language-kotlin">@Bean
fun testKafkaConsumerDefinitionProvider(
    applicationContext: GenericApplicationContext,
    topicNameExpressionResolver: TopicNameExpressionResolver
): TestKafkaConsumerDefinitionProvider {
    val ymlFile = applicationContext.environment.getProperty(
        &quot;fit4j.kafka.consumers.file&quot;,
        &quot;classpath:fit4j-kafka-consumers.yml&quot;
    )
    return TestKafkaConsumerDefinitionProvider(topicNameExpressionResolver, applicationContext, ymlFile)
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt#L40-L49"><code>src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt:40-49</code></a>.</p>
<p>The YAML file location can be customized per test class via <code>@TestPropertySource</code>:</p>
<pre><code class="language-kotlin">@EnableEmbeddedKafka
@FIT
@TestPropertySource(
    properties = [
        &quot;kafka.topic.name=sample-topic-1&quot;,
        &quot;fit4j.kafka.consumers.file=classpath:fit4j-kafka-consumers-sample.yml&quot;
    ]
)
class KafkaConsumersYamlFileLoadFIT {
    // ...
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaConsumersYamlFileLoadFIT.kt#L7-L25"><code>src/test/kotlin/org/fit4j/kafka/KafkaConsumersYamlFileLoadFIT.kt:7-25</code></a>.</p>
<p>This test verifies that:</p>
<ul>
<li>The YAML is loaded correctly.</li>
<li><code>TestKafkaConsumerDefinitionProvider</code> exposes the definitions.</li>
<li><code>ConcurrentKafkaListenerContainerFactory</code> is configured according to the file.</li>
</ul>
<h3>How YAML Affects Runtime Behavior</h3>
<ul>
<li><strong><code>fit4j.kafka.consumers.file</code></strong> – defines which YAML file is used to create test consumers. Each entry leads to:</li>
<li>A <code>TestKafkaConsumerDefinition</code> instance.</li>
<li>A Spring Kafka listener container with specified topic, group id, ack mode, and deserializers.</li>
<li><strong>Missing/misconfigured YAML</strong> – results in no test consumers being registered or incorrect container configuration, which will surface as failing tests or missing tracked messages.</li>
</ul>
<hr />
<h2>Kafka Message Tracking</h2>
<h3>KafkaMessageTracker Bean</h3>
<p><code>KafkaMessageTracker</code> is the central component that tracks sent and processed messages. It is configured with two tuning parameters:</p>
<pre><code class="language-kotlin">@Bean
fun kafkaMessageTracker(env: ConfigurableEnvironment): KafkaMessageTracker {
    val waitTimeout = env.getProperty(&quot;fit4j.kafka.waitTimeout&quot;, Long::class.java, 1000L)
    val waitLoopCount = env.getProperty(&quot;fit4j.kafka.waitLoopCount&quot;, Int::class.java, 30)
    return KafkaMessageTracker(waitTimeout, waitLoopCount)
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt#L21-L29"><code>src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt:21-29</code></a>.</p>
<ul>
<li><code>fit4j.kafka.waitTimeout</code> – sleep duration between polling attempts (ms).</li>
<li><code>fit4j.kafka.waitLoopCount</code> – maximum number of polling attempts.</li>
</ul>
<p>Together they bound the maximum wait time when calling <code>waitForProcessing</code>-like methods.</p>
<h3>KafkaMessageTrackerAspect</h3>
<p><code>KafkaMessageTrackerAspect</code> intercepts methods annotated with <code>@KafkaListener</code> and marks consumed messages as processed. It is created via:</p>
<pre><code class="language-kotlin">@Bean
fun kafkaMessageTrackerAspect(
    kafkaMessageTracker: KafkaMessageTracker,
    env: ConfigurableEnvironment,
    topicNameExpressionResolver: TopicNameExpressionResolver
): KafkaMessageTrackerAspect {
    // ctor call, not fully shown in snippet
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt#L29-L40"><code>src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt:29-40</code></a>.</p>
<p>The aspect uses <code>TopicNameExpressionResolver</code> to determine the effective topic name for listeners whose <code>topics</code> or <code>topicPattern</code> attributes may use placeholders or expressions.</p>
<h4>What the Aspect Does</h4>
<p>Whenever a <code>@KafkaListener</code> method receives a message:</p>
<ol>
<li>The aspect intercepts before or after the method.</li>
<li>It extracts the message payload (and possibly headers).</li>
<li>It notifies <code>KafkaMessageTracker</code> to mark the message as processed for the relevant topic and key.</li>
<li>Test code waiting on this message is unblocked and can assert on it.</li>
</ol>
<p>This applies both to application listeners and test-only listeners defined within test configuration classes.</p>
<hr />
<h2>Publishing and Waiting for Messages in Tests</h2>
<h3>Basic Pattern</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L94"><code>README.md:60-94</code></a>:</p>
<pre><code class="language-kotlin">import org.fit4j.kafka.EnableEmbeddedKafka
import org.fit4j.annotation.FIT
import org.fit4j.kafka.KafkaMessageTracker
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.kafka.core.KafkaTemplate
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test

@EnableEmbeddedKafka
@FIT
class SampleFIT {

  @Autowired
  private lateinit var fooRepository: FooRepository

  @Autowired
  private lateinit var kafkaTemplate: KafkaTemplate&lt;String, Any&gt;

  @Autowired
  private lateinit var kafkaMessageTracker: KafkaMessageTracker

  @Test
  fun testFoo() {
      // Publish a message
      val message = Foo.newBuilder().setId(123).setName(&quot;Foo&quot;).build()
      kafkaTemplate.send(&quot;foo-create-topic&quot;, message).get()

      // Wait for the service to process the message
      val processedMessage = kafkaMessageTracker.waitForProcessing(message)

      // Assert domain effects
      Assertions.assertNotNull(processedMessage)
      // e.g. verify DB state using fooRepository
  }
}
</code></pre>
<p>Source reference: <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L102"><code>README.md:60-102</code></a>.</p>
<h4>Steps in Detail</h4>
<ol>
<li><strong>Enable FIT and Kafka</strong> – <code>@EnableEmbeddedKafka</code> + <code>@FIT</code>.</li>
<li><strong>Publish the message</strong> – use <code>KafkaTemplate.send(topic, payload).get()</code> to ensure send completion.</li>
<li><strong>Wait for processing</strong> – call a <code>KafkaMessageTracker</code> method (e.g. <code>waitForProcessing</code>) with the sent message or correlation data.</li>
<li><strong>Assert</strong> – on:</li>
<li>The returned processed message (payload, headers).</li>
<li>Side effects in the system (e.g. repository state).</li>
</ol>
<h3>Using KafkaMessageTracker in Test Classes</h3>
<p>Tests directly inject <code>KafkaMessageTracker</code>:</p>
<ul>
<li><code>KafkaMessageTrackerAspectFIT</code>: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspectFIT.kt#L19-L27"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspectFIT.kt:19-27</code></a></li>
<li><code>KafkaMessageTrackerAspect2FIT</code>: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspect2FIT.kt#L24-L34"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspect2FIT.kt:24-34</code></a></li>
<li><code>KafkaMessageWithHeadersFIT</code>: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt#L24-L32"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt:24-32</code></a></li>
</ul>
<p>The typical pattern:</p>
<pre><code class="language-kotlin">@Autowired
private lateinit var kafkaMessageTracker: KafkaMessageTracker

@Autowired
private lateinit var kafkaTemplate: KafkaTemplate&lt;String, String&gt;

@Autowired
private lateinit var verificationHelper: VerificationHelper

@Test
fun `should process Kafka message`() {
    // Given
    val topic = &quot;example-topic-1&quot;
    val payload = &quot;sample-payload&quot;

    // When
    kafkaTemplate.send(topic, payload).get()

    // Then – using VerificationHelper around KafkaMessageTracker
    val processed = verificationHelper.waitForProcessing(payload)
    Assertions.assertNotNull(processed)
}
</code></pre>
<p>(Structure based on <a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageTrackerAspect2FIT.kt#L24-L56"><code>KafkaMessageTrackerAspect2FIT.kt:24-56</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageTrackerAspectFIT.kt#L19-L40"><code>KafkaMessageTrackerAspectFIT.kt:19-40</code></a>.)</p>
<p><code>VerificationHelper</code> encapsulates common wait‑and‑assert patterns around <code>KafkaMessageTracker</code>.</p>
<hr />
<h2>Working with Headers and Complex Payloads</h2>
<h3>Message with Headers</h3>
<p><code>KafkaMessageWithHeadersFIT</code> shows how headers are preserved and asserted in tests:</p>
<pre><code class="language-kotlin">@EmbeddedKafka
@FIT
@TestPropertySource(
    properties = [
        &quot;fit4j.kafka.consumers.file=classpath:consumers/KafkaMessageWithHeadersFIT-consumers.yml&quot;,
        &quot;spring.kafka.consumer.auto-offset-reset=earliest&quot;
    ]
)
class KafkaMessageWithHeadersFIT {

    @Autowired
    private lateinit var kafkaMessageTracker: KafkaMessageTracker

    @Autowired
    private lateinit var kafkaTemplate: KafkaTemplate&lt;String, String&gt;

    @TestConfiguration
    class TestConfig {
        @Bean
        fun messageListener1(): MessageListener1 = MessageListener1()
    }

    @Test
    fun `should receive headers`() {
        val headers = RecordHeaders(
            listOf(
                RecordHeader(&quot;x-correlation-id&quot;, &quot;corr-123&quot;.toByteArray())
            )
        )
        val record = ProducerRecord(&quot;topic-with-headers&quot;, null, &quot;payload&quot;, headers)
        kafkaTemplate.send(record).get()

        // Wait and assert via KafkaMessageTracker
        val processed = kafkaMessageTracker.waitForProcessing(&quot;payload&quot;)
        Assertions.assertNotNull(processed)
        // Typically, you would assert headers here as well
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt#L7-L60"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt:7-60</code></a>.</p>
<p>Inside <code>TestConfig</code>, <code>MessageListener1</code> is a test listener with <code>@KafkaListener</code> and <code>@Headers</code> argument to access headers. The aspect sees these invocations and informs the tracker.</p>
<h3>Protobuf / gRPC Messages</h3>
<p><code>KafkaMessageTrackerAspectFIT</code> demonstrates tracking non‑String payloads (e.g. Protobuf):</p>
<pre><code class="language-kotlin">@EmbeddedKafka
@FIT
@TestPropertySource(
    properties = [
        &quot;spring.kafka.producer.value-serializer=org.fit4j.kafka.MessageSerializer&quot;,
        &quot;spring.kafka.consumer.auto-offset-reset=earliest&quot;
    ]
)
class KafkaMessageTrackerAspectFIT {

    @Autowired
    private lateinit var kafkaMessageTracker: KafkaMessageTracker

    @Autowired
    private lateinit var kafkaTemplate: KafkaTemplate&lt;String, Message&gt;

    @Autowired
    private lateinit var verificationHelper: VerificationHelper

    @Test
    fun `should process protobuf message`() {
        val request = TestGrpc.TestRequest.newBuilder()
            .setId(1)
            .setMessage(&quot;hello&quot;)
            .build()
        kafkaTemplate.send(&quot;grpc-topic&quot;, request).get()

        val processed = verificationHelper.waitForProcessing(request)
        Assertions.assertNotNull(processed)
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspectFIT.kt#L7-L50"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspectFIT.kt:7-50</code></a>.</p>
<p>Note the custom serializer <code>org.fit4j.kafka.MessageSerializer</code> configured via <code>spring.kafka.producer.value-serializer</code>, which allows raw Protobuf messages to be sent.</p>
<hr />
<h2>Auto-Configured Components</h2>
<p><code>TestKafkaAutoConfiguration</code> orchestrates several beans used in messaging workflows:</p>
<pre><code class="language-kotlin">@AutoConfiguration
@AutoConfigureAfter(KafkaAutoConfiguration::class)
@ConditionalOnBean(KafkaListenerEndpointRegistry::class)
@ConditionalOnProperty(name = [&quot;spring.kafka.bootstrap-servers&quot;])
@EnableOnFIT
class TestKafkaAutoConfiguration {

    @Bean
    fun kafkaMessageTracker(env: ConfigurableEnvironment): KafkaMessageTracker { ... }

    @Bean
    fun kafkaMessageTrackerAspect(
        kafkaMessageTracker: KafkaMessageTracker,
        env: ConfigurableEnvironment,
        topicNameExpressionResolver: TopicNameExpressionResolver
    ): KafkaMessageTrackerAspect { ... }

    @Bean
    fun topicNameExpressionResolver(applicationContext: ApplicationContext): TopicNameExpressionResolver {
        return TopicNameExpressionResolver(applicationContext)
    }

    @Bean
    fun testMessageListener(kafkaMessageTracker: KafkaMessageTracker): TestMessageListener {
        return TestMessageListener(kafkaMessageTracker)
    }

    @Bean
    fun testKafkaConsumerDefinitionProvider(
        applicationContext: GenericApplicationContext,
        topicNameExpressionResolver: TopicNameExpressionResolver
    ): TestKafkaConsumerDefinitionProvider { ... }

    @Bean
    fun testKafkaConsumerConfigurer(
        provider: TestKafkaConsumerDefinitionProvider,
        registry: KafkaListenerEndpointRegistry
    ): TestKafkaConsumerConfigurer { ... }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt#L7-L55"><code>src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt:7-55</code></a>.</p>
<p>Key beans:</p>
<ul>
<li><strong><code>KafkaMessageTracker</code></strong> – central tracking component.</li>
<li><strong><code>KafkaMessageTrackerAspect</code></strong> – AOP around <code>@KafkaListener</code>.</li>
<li><strong><code>TopicNameExpressionResolver</code></strong> – resolves topic placeholders (e.g. <code>${example.topic2}</code>).</li>
<li><strong><code>TestMessageListener</code></strong> – generic listener that forwards consumed messages to the tracker.</li>
<li><strong><code>TestKafkaConsumerDefinitionProvider</code></strong> – parses YAML and exposes <code>TestKafkaConsumerDefinition</code> instances.</li>
<li><strong><code>TestKafkaConsumerConfigurer</code></strong> – registers listener endpoints based on definitions (not shown, but implied by name).</li>
</ul>
<hr />
<h2>Configuration Properties Reference</h2>
<p>Below are the main Kafka-related properties used in tests and how they affect behavior.</p>
<h3>FIT4J Kafka Properties</h3>
<ul>
<li><strong><code>fit4j.kafka.consumers.file</code></strong></li>
<li>Scope: Tests</li>
<li>Default: <code>classpath:fit4j-kafka-consumers.yml</code></li>
<li>Description: Path to the YAML file describing test Kafka consumers.</li>
<li>Example override: <code>@TestPropertySource(properties = ["fit4j.kafka.consumers.file=classpath:consumers/KafkaMessageTrackerAspect2FIT-consumers.yml"])</code></li>
<li>
<p>Used in: <code>TestKafkaAutoConfiguration.testKafkaConsumerDefinitionProvider</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt#L40-L49"><code>src/main/kotlin/org/fit4j/autoconfigure/TestKafkaAutoConfiguration.kt:40-49</code></a>).</p>
</li>
<li>
<p><strong><code>fit4j.kafka.waitTimeout</code></strong></p>
</li>
<li>Type: <code>Long</code> (ms)</li>
<li>Default: <code>1000</code></li>
<li>
<p>Description: Sleep duration between polling attempts inside <code>KafkaMessageTracker</code>.</p>
</li>
<li>
<p><strong><code>fit4j.kafka.waitLoopCount</code></strong></p>
</li>
<li>Type: <code>Int</code></li>
<li>Default: <code>30</code></li>
<li>Description: Maximum number of polling attempts for a message.</li>
</ul>
<h3>Spring Kafka Properties in Tests</h3>
<ul>
<li><strong><code>spring.kafka.bootstrap-servers</code></strong></li>
<li>Description: Address of Kafka broker (embedded or external).</li>
<li>Required to enable <code>TestKafkaAutoConfiguration</code> due to <code>@ConditionalOnProperty</code>.</li>
<li>
<p>Verified in <code>KafkaAutoConfigurationEnabledFIT</code> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt#L14-L22"><code>src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt:14-22</code></a>).</p>
</li>
<li>
<p><strong><code>spring.kafka.consumer.auto-offset-reset</code></strong></p>
</li>
<li>Common value in tests: <code>earliest</code></li>
<li>Ensures test consumers read messages from the beginning of the topic if no offsets exist.</li>
<li>
<p>Used across tests:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageTrackerAspect2FIT.kt#L19-L27"><code>KafkaMessageTrackerAspect2FIT.kt:19-27</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageWithHeadersFIT.kt#L19-L27"><code>KafkaMessageWithHeadersFIT.kt:19-27</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageTrackerAspectFIT.kt#L15-L23"><code>KafkaMessageTrackerAspectFIT.kt:15-23</code></a></li>
</ul>
</li>
<li>
<p><strong><code>spring.kafka.producer.value-serializer</code></strong></p>
</li>
<li>Used to configure Protobuf serializer: <code>org.fit4j.kafka.MessageSerializer</code>.</li>
<li>
<p>Example: <a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageTrackerAspectFIT.kt#L15-L21"><code>KafkaMessageTrackerAspectFIT.kt:15-21</code></a>.</p>
</li>
<li>
<p><strong>Custom topic properties</strong></p>
</li>
<li>E.g. <code>example.topic2=example-topic-2</code> in <a href="https://github.com/harezmi/fit4j/blob/main/KafkaMessageTrackerAspect2FIT.kt#L18-L26"><code>KafkaMessageTrackerAspect2FIT.kt:18-26</code></a>.</li>
<li>These are usually resolved by <code>TopicNameExpressionResolver</code> in YAML-defined consumer topics or <code>@KafkaListener</code> attributes.</li>
</ul>
<p>All credentials or connection strings (if any) should be configured with passwords masked, e.g.:</p>
<pre><code class="language-properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;user&quot; password=&quot;********&quot;;
</code></pre>
<hr />
<h2>End-to-End Workflow Diagram</h2>
<p>The following diagram summarizes the end-to-end Kafka testing workflow:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test sends message"] --> step2["Kafka broker receives"]
 step2 --> step3["Test consumer listens"]
 step3 --> step4["Aspect tracks processed"]
 step4 --> step5["Tracker stores state"]
 step5 --> step6["Test asserts result"]
</div></div>
<p>Interpretation:</p>
<ol>
<li><strong>Test sends message</strong> – via <code>KafkaTemplate</code> from test (<code>SampleFIT</code>, <code>KafkaMessageTrackerAspectFIT</code>, etc.).</li>
<li><strong>Kafka broker receives</strong> – embedded or external Kafka broker.</li>
<li><strong>Test consumer listens</strong> – <code>TestMessageListener</code> and/or application <code>@KafkaListener</code>s.</li>
<li><strong>Aspect tracks processed</strong> – <code>KafkaMessageTrackerAspect</code> intercepts listener invocations.</li>
<li><strong>Tracker stores state</strong> – <code>KafkaMessageTracker</code> updates its internal storage.</li>
<li><strong>Test asserts result</strong> – waiting and assertions via <code>KafkaMessageTracker</code> or <code>VerificationHelper</code>.</li>
</ol>
<hr />
<h2>Practical Tips for Writing Kafka-based FIT Tests</h2>
<ul>
<li>Always enable either <code>@EnableEmbeddedKafka</code> (preferred) or <code>@EmbeddedKafka</code> with <code>@FIT</code>.</li>
<li>If you use <code>@EmbeddedKafka</code> directly, consider adding <code>@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)</code> to prevent race conditions (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L9-L20"><code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt:9-20</code></a>).</li>
<li>Place your consumer YAML under <code>src/test/resources</code> and point <code>fit4j.kafka.consumers.file</code> to it when you need topic-specific setups.</li>
<li>Use <code>spring.kafka.consumer.auto-offset-reset=earliest</code> to avoid missing messages in tests due to offsets.</li>
<li>For Protobuf or custom payloads, configure serializers/ deserializers via <code>spring.kafka.*.serializer</code>/<code>deserializer</code> properties.</li>
<li>Use <code>KafkaMessageTracker</code> directly for low-level control, or <code>VerificationHelper</code> where available for concise assertions over Kafka workflows.</li>
</ul>
<p>For terminology and class-level explanations, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-testcontainers-and-embedded-services" class="dw-section">
  <div class="dw-section-inner">
    <h1>Testcontainers &amp; Embedded Services Integration</h1>
<p>This section explains how FIT4J integrates Testcontainers and embedded services (Redis, DynamoDB, Elasticsearch, Kafka) into Spring Boot tests. It focuses on YAML-based <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> definitions, <code>TestContainerDefinition</code> implementations, and context customization via annotations so you can bring up only the infrastructure your tests need.</p>
<hr />
<h2>Overview</h2>
<p>FIT4J adds a thin abstraction on top of <a href="https://www.testcontainers.org/">Testcontainers</a> and embedded servers to:</p>
<ul>
<li>Define containers declaratively in YAML.</li>
<li>Selectively register and start containers per test class.</li>
<li>Expose container connection properties as Spring configuration.</li>
<li>Optionally populate containers with initial test data.</li>
<li>Provide embedded alternatives for some services (e.g. Redis, DynamoDB, H2).</li>
</ul>
<p>This integration is driven by:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> / sample YAML files in <code>src/test/resources</code>.</li>
<li><code>@org.fit4j.testcontainers.Testcontainers</code> and/or <code>@org.testcontainers.junit.jupiter.Testcontainers</code>.</li>
<li><code>TestContainerDefinition</code> and <code>DataPopulatingTestContainerDefinition</code> implementations (e.g. <code>RedisTestContainerDefinition</code>).</li>
<li>Spring TestContext customizers wired through the FIT4J <code>@FIT</code> annotation.</li>
</ul>
<hr />
<h2>Annotations and Activation Model</h2>
<h3><code>@FIT</code> as the entry point</h3>
<p>All Testcontainers integration in FIT4J is triggered from tests annotated with <code>@FIT</code>:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainersContextCustomizerWithoutAnnotationFIT.kt:5-18
@FIT
class TestContainersContextCustomizerWithoutAnnotationFIT {

    @Autowired(required = false)
    private var testContainerDefinitions: List&lt;TestContainerDefinition&gt;? = null

    @Test
    fun `it should not attempt to register test containers if no testcontainers annotation is present`() {
        Assertions.assertNull(testContainerDefinitions)
    }
}
</code></pre>
<p>Key behavior:</p>
<ul>
<li><code>@FIT</code> hooks into Spring Boot’s <code>TestContext</code> to add a context customizer.</li>
<li>If no Testcontainers annotation is present, <strong>no containers are registered</strong> and <code>testContainerDefinitions</code> remains <code>null</code>. This is enforced in <a href="https://github.com/harezmi/fit4j/blob/main/TestContainersContextCustomizerWithoutAnnotationFIT.kt#L5-L18"><code>TestContainersContextCustomizerWithoutAnnotationFIT.kt:5-18</code></a>.</li>
</ul>
<p>This avoids overhead when a test does not need infrastructure.</p>
<h3>Using vanilla <code>@org.testcontainers.junit.jupiter.Testcontainers</code></h3>
<p>You can rely on pure Testcontainers semantics and let FIT4J just <em>discover</em> definitions from YAML:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainersContextCustomizerWithAnnotationFIT.kt:5-21
@FIT
@org.testcontainers.junit.jupiter.Testcontainers
@Disabled
class TestContainersContextCustomizerWithAnnotationFIT {

    @Autowired(required = false)
    private var testContainerDefinitions: List&lt;TestContainerDefinition&gt;? = null

    @TestConfiguration
    class TestConfig {
        // Additional context configuration if needed
    }
}
</code></pre>
<p>In this mode:</p>
<ul>
<li>FIT4J sees <code>@org.testcontainers.junit.jupiter.Testcontainers</code> on the class.</li>
<li>It loads YAML definitions (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>) and instantiates matching <code>TestContainerDefinition</code>s.</li>
<li>Injection of <code>List&lt;TestContainerDefinition&gt;</code> becomes possible in the test context.</li>
</ul>
<h3>Using FIT4J’s <code>@org.fit4j.testcontainers.Testcontainers</code></h3>
<p>Most tests should use the FIT4J wrapper annotation to <strong>selectively register</strong> container definitions:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainersWithSelectiveRegistrationFIT.kt:5-23
@FIT
@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;redisContainerDefinition&quot;])
class TestContainersWithSelectiveRegistrationFIT {

    @Autowired(required = false)
    private var testContainerDefinitions: List&lt;TestContainerDefinition&gt;? = null

    @TestConfiguration
    class TestConfig {
        @EventListener
        fun afterTestClass(event: AfterTestClassEvent) {
            // Clean-up or assertions on definitions if needed
        }
    }

    @Test
    fun `test something`() {
        // Redis container is available, others defined in YAML are not started
    }
}
</code></pre>
<p>Behavior:</p>
<ul>
<li>The <code>definitions</code> attribute filters which container definitions from YAML are instantiated.</li>
<li>This annotation itself extends/leverages <code>@org.testcontainers.junit.jupiter.Testcontainers</code> (see explanation in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>).</li>
<li>Only containers listed in <code>definitions</code> are started, even if YAML contains more.</li>
</ul>
<p>Other examples:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt:5-25
@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;redisContainerDefinition&quot;])
@FIT
class RedisDataPopulatorFIT {
    // ...
}
</code></pre>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainerDefinitionInheritanceFIT.kt:5-24
@FIT
@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;mySQLContainerDefinition&quot;])
class TestContainerDefinitionInheritanceFIT : BaseTest() {

    @Autowired(required = false)
    private var testContainerDefinitions: List&lt;TestContainerDefinition&gt;? = null

    @TestConfiguration
    class TestConfig {
        @EventListener
        fun afterTestClass(event: AfterTestClassEvent) {
            // Validate inheritance behavior etc.
        }
    }

    @Test
    fun `some test`() {
        // mySQLContainerDefinition is available
    }
}
</code></pre>
<hr />
<h2>YAML-based Container Definitions</h2>
<h3><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> for project tests</h3>
<p>Place container definitions in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml"><code>src/test/resources/fit4j-test-containers.yml</code></a>. FIT4J will load this file automatically for tests annotated with <code>@FIT</code> and a Testcontainers annotation.</p>
<p>Example excerpt:</p>
<pre><code class="language-yaml"># See src/test/resources/fit4j-test-containers.yml:1-26
- container: org.testcontainers.containers.PostgreSQLContainer
  name: mySQLContainerDefinition
  image: postgres:15.0
  username: ********
  password: ********
  databaseName: testdb
  env:
    - TZ: &quot;UTC&quot;
    - POSTGRES_HOST_AUTH_METHOD: trust
  exposedProperties:
    - jdbcUrl
    - username
    - password
    - host
    - firstMappedPort
  reuse: false

- container: org.testcontainers.containers.GenericContainer
  name: redisContainerDefinition
  image: redis:6.2.1
  initScript: scripts/redis_initial_data.yml
  exposedPorts:
    - 6379
  exposedProperties:
    - host
    - firstMappedPort
  reuse: false

- container: org.testcontainers.elasticsearch.ElasticsearchContainer
  name: elasticSearchContainerDefinition
  image: docker.elastic.co/elasticsearch/elasticsearch:8.10.2
  initScript: scripts/elasticsearch_initial_data.yml
  exposedPorts:
    - 9200
    - 9300
  env:
    - ELASTICSEARCH_USERNAME: ********
    # ... other env vars
</code></pre>
<p>Supported/commonly used fields:</p>
<ul>
<li><code>container</code>: Fully qualified Testcontainers class.</li>
<li><code>name</code>: Logical name; used in <code>fit4j.&lt;name&gt;.*</code> property exposure.</li>
<li><code>image</code>: Docker image.</li>
<li><code>exposedPorts</code>: List of container ports to expose.</li>
<li><code>username</code>, <code>password</code>, <code>databaseName</code>: DB-specific settings (for <code>MySQLContainer</code>, <code>PostgreSQLContainer</code> etc.).</li>
<li><code>initScript</code>: Path under <code>src/test/resources</code> to data population script (SQL/YAML/JSON depending on container).</li>
<li><code>env</code>: List of key/value pairs to set as container environment variables.</li>
<li><code>urlParam</code>: Additional URL parameters for JDBC containers.</li>
<li><code>exposedProperties</code>: Which container attributes to expose as Spring properties.</li>
<li><code>reuse</code>: Whether Testcontainers should reuse container across runs.</li>
</ul>
<h4>Sample YAML in README</h4>
<p>The main README contains a richer example:</p>
<pre><code class="language-yaml"># See README.md: line ranges around the Testcontainers section
- container: org.testcontainers.containers.MySQLContainer
  name: mySQLContainerDefinition
  image: mysql:5.7.33
  exposedPorts:
    - 3306
  username: ********
  password: ********
  databaseName: v1
  initScript: scripts/v1_init.sql
  env:
    - TZ: &quot;America/Los_Angeles&quot;
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
    - useLegacyDatetimeCode: &quot;false&quot;
  exposedProperties:
    - jdbcUrl
    - username
    - password
  reuse: true
</code></pre>
<h3>Sample definition provider</h3>
<p>Loading definitions programmatically is shown in:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/TestContainersDefinitionProviderFIT.kt:5-22
@FIT
class TestContainersDefinitionProviderFIT {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `it should load given sample testcontainers yaml file`() {
        val provider = TestContainersDefinitionProvider(
            applicationContext,
            &quot;classpath:fit4j-test-containers-sample.yml&quot;
        )
        val containers = provider.getTestContainerDefinitions()
        // Assertions on containers
    }
}
</code></pre>
<p><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers-sample.yml"><code>fit4j-test-containers-sample.yml</code></a> (see <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L29"><code>src/test/resources/fit4j-test-containers-sample.yml:1-29</code></a>) demonstrates a MySQL, Redis, Elasticsearch mix similar to the main YAML.</p>
<hr />
<h2>Property Exposure into Spring Configuration</h2>
<h3><code>fit4j.&lt;container-name&gt;.&lt;property&gt;</code></h3>
<p>For each container definition, FIT4J exposes container attributes configured under <code>exposedProperties</code> as Spring properties using the pattern:</p>
<pre><code class="language-text">fit4j.&lt;container-name&gt;.&lt;exposed-property-name&gt;
</code></pre>
<p>Examples from the README:</p>
<pre><code class="language-properties"># See README.md around property injection examples
spring.datasource.url=${fit4j.mySQLContainerDefinition.jdbcUrl}
spring.datasource.username=${fit4j.mySQLContainerDefinition.username}
spring.datasource.password=${fit4j.mySQLContainerDefinition.password}
</code></pre>
<p>Redis/Elasticsearch usage in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>:</p>
<pre><code class="language-properties"># See src/test/resources/application-test.properties:1-7
redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}

elasticSearch.host=${fit4j.elasticSearchContainerDefinition.host}
elasticSearch.port=${fit4j.elasticSearchContainerDefinition.port}
</code></pre>
<p>Effect:</p>
<ul>
<li>When the test context starts, the container is created and started.</li>
<li>The container’s runtime values (host, mapped port, JDBC URL, etc.) are resolved and registered in the Spring <code>Environment</code>.</li>
<li>Placeholders in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> or <a href="https://github.com/harezmi/fit4j/blob/main/application-test.yml"><code>application-test.yml</code></a> resolve to those container values, allowing normal Spring Boot configuration (e.g. datasource, Redis clients, Elasticsearch clients).</li>
</ul>
<h3>Using exposed properties directly in tests</h3>
<p>You can also inject FIT4J properties directly via <code>@Value</code>:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt:5-22
@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;redisContainerDefinition&quot;])
@FIT
class RedisDataPopulatorFIT {

    @Value(&quot;\${fit4j.redisContainerDefinition.host}&quot;)
    private lateinit var redisHost: String

    @Value(&quot;\${fit4j.redisContainerDefinition.port}&quot;)
    private lateinit var redisPort: Integer

    @TestConfiguration
    class TestConfig {
        @EventListener
        fun afterTestClass(event: AfterTestClassEvent) {
            // optional cleanup or verification
        }
    }

    @Test
    fun `use redis properties`() {
        // Use redisHost and redisPort to connect with a client
    }
}
</code></pre>
<hr />
<h2>Data Population: <code>TestContainerDataPopulator</code> and Init Scripts</h2>
<h3>MySQL (and other JDBC containers)</h3>
<p>If the <code>container</code> type is <code>org.testcontainers.containers.MySQLContainer</code> (or other JDBC-like containers), Testcontainers natively supports an <code>initScript</code>:</p>
<pre><code class="language-yaml"># See README.md MySQL section and YAML example
- container: org.testcontainers.containers.MySQLContainer
  name: mySQLContainerDefinition
  initScript: scripts/v1_init.sql
</code></pre>
<p>Behavior:</p>
<ul>
<li>On container start, Testcontainers executes <a href="https://github.com/harezmi/fit4j/blob/main/scripts/v1_init.sql"><code>scripts/v1_init.sql</code></a> against the database.</li>
<li>This SQL file should live under <code>src/test/resources/scripts/</code> and contain DDL/DML statements required for your tests.</li>
</ul>
<p>This is described in the README under <em>Initial Data Population for MySQL Container</em>.</p>
<h3>Elasticsearch</h3>
<p>For Elasticsearch containers, FIT4J introduces a custom data population mechanism based on <code>TestContainerDataPopulator</code> implementations. YAML configuration:</p>
<pre><code class="language-yaml"># See src/test/resources/fit4j-test-containers.yml:20-33
- container: org.testcontainers.elasticsearch.ElasticsearchContainer
  name: elasticSearchContainerDefinition
  image: docker.elastic.co/elasticsearch/elasticsearch:8.10.2
  initScript: scripts/elasticsearch_initial_data.yml
  exposedPorts:
    - 9200
    - 9300
  env:
    - ELASTICSEARCH_USERNAME: ********
    # ...
</code></pre>
<p>Test-side usage:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/testcontainers/ElasticsearchDataPopulatorFIT.kt:5-24
@Disabled
@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;elasticSearchContainerDefinition&quot;])
@FIT
class ElasticsearchDataPopulatorFIT {

    @Value(&quot;\${fit4j.elasticSearchContainerDefinition.host}&quot;)
    private lateinit var elasticHost: String

    @Value(&quot;\${fit4j.elasticSearchContainerDefinition.port}&quot;)
    private lateinit var elasticPort: Integer

    @TestConfiguration
    class TestConfig {
        @EventListener
        fun afterTestClass(event: AfterTestClassEvent) {
            // Validate data population or perform cleanup
        }
    }

    @Test
    fun `should have initial elasticsearch data`() {
        // Use Elasticsearch client to verify documents from scripts/elasticsearch_initial_data.yml
    }
}
</code></pre>
<p>Internally, a <code>DataPopulatingTestContainerDefinition</code> subtype will:</p>
<ol>
<li>Start the <code>ElasticsearchContainer</code>.</li>
<li>Retrieve connection info.</li>
<li>Run a <code>TestContainerDataPopulator</code> that parses <a href="https://github.com/harezmi/fit4j/blob/main/elasticsearch_initial_data.yml"><code>elasticsearch_initial_data.yml</code></a> and sends bulk indexing requests.</li>
</ol>
<h3>Redis</h3>
<p>Redis is handled similarly via a specific <code>RedisTestContainerDefinition</code>.</p>
<pre><code class="language-kotlin">// See src/main/kotlin/org/fit4j/testcontainers/RedisTestContainerDefinition.kt:5-19
class RedisTestContainerDefinition(map: Map&lt;String, Any&gt;) : DataPopulatingTestContainerDefinition(map) {

    override fun dataPopulator(): TestContainerDataPopulator {
        val connectionProperties = redisConnectionProperties()
        return RedisDataPopulator(connectionProperties)
    }

    private fun redisConnectionProperties(): RedisConnectionProperties {
        val redisContainer = this.getContainer() as GenericContainer&lt;*&gt;
        val connectionProperties = RedisConnectionProperties(
            redisContainer.host,
            redisContainer.firstMappedPort
        )
        return connectionProperties
    }
}
</code></pre>
<p>Flow:</p>
<ul>
<li><code>RedisTestContainerDefinition</code> reads YAML parameters (<code>image</code>, <code>initScript</code>, ports, etc.).</li>
<li>It creates a <code>GenericContainer</code> with Redis and starts it.</li>
<li><code>dataPopulator()</code> creates a <code>RedisDataPopulator</code> using host + mapped port.</li>
<li><code>RedisDataPopulator</code> uses <code>initScript</code> (e.g. <a href="https://github.com/harezmi/fit4j/blob/main/scripts/redis_initial_data.yml"><code>scripts/redis_initial_data.yml</code></a>) to seed the Redis instance.</li>
</ul>
<p>Consumer test: <code>RedisDataPopulatorFIT</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt#L5-L25"><code>src/test/kotlin/org/fit4j/testcontainers/RedisDataPopulatorFIT.kt:5-25</code></a>) validates that data is present.</p>
<hr />
<h2>Container Reuse</h2>
<p>FIT4J exposes the Testcontainers reuse feature through the YAML’s <code>reuse</code> flag:</p>
<pre><code class="language-yaml"># See README.md Testcontainers section
- container: org.testcontainers.containers.GenericContainer
  name: redisContainerDefinition
  image: redis:6.2.1
  exposedPorts:
    - 6379
  exposedProperties:
    - host
    - firstMappedPort
  reuse: true
</code></pre>
<p>For reuse to function:</p>
<ol>
<li>Set <code>reuse: true</code> in the relevant YAML definition.</li>
<li>Add <a href="https://github.com/harezmi/fit4j/blob/main/.testcontainers.properties"><code>.testcontainers.properties</code></a> in your user home directory:</li>
</ol>
<pre><code class="language-properties"># ~/.testcontainers.properties
testcontainers.reuse.enable=true
</code></pre>
<p>This is described in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> near the Testcontainers section. Without the global property, the <code>reuse</code> flag in YAML is ignored.</p>
<hr />
<h2>Embedded Services (Redis, DynamoDB, H2)</h2>
<p>For some services it may be preferable to avoid Docker entirely and use embedded implementations instead.</p>
<h3>Embedded Redis</h3>
<p>As an alternative to Redis Testcontainers:</p>
<pre><code class="language-kotlin">// See README.md Embedded Redis example
@EmbeddedRedis  // Uses random port (default behavior)
@FIT
class SampleFIT {

    @Test
    fun `test with embedded redis`() {
        // Redis is available at port fit4j.embeddedRedisServer.port
    }
}
</code></pre>
<p><code>@EmbeddedRedis</code> parameters:</p>
<ul>
<li><code>port</code>: Fixed port (default: <code>6379</code>).</li>
<li><code>useRandomPort</code>: Choose random port (default: <code>true</code>).</li>
</ul>
<p>FIT4J exposes embedded Redis properties similarly:</p>
<ul>
<li><code>fit4j.embeddedRedisServer.port</code> — can be referenced in Spring configuration and <code>@Value</code>.</li>
</ul>
<p>Use this when Docker is unavailable or you want faster start times with a purely in-memory Redis.</p>
<h3>Other embedded examples</h3>
<p>The examples module documents several embedded options (see <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L15"><code>fit4j-examples/README.md:1-15</code></a>):</p>
<ul>
<li><code>example-redis-embedded</code> — embedded Redis.</li>
<li><code>example-h2</code> — H2 in-memory DB (embedded).</li>
<li><code>example-dynamodb</code> — embedded DynamoDB.</li>
</ul>
<p>These are stand-alone examples rather than core support classes but follow the same pattern: annotate your FIT test and configure properties to point at the embedded instance.</p>
<hr />
<h2>High-level Flow</h2>
<p>Below is a simplified flow of how a FIT test with Testcontainers is executed.</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test class with FIT"] --> step2["Detect Testcontainers annotations"]
 step2 --> step3["Load YAML definitions"]
 step3 --> step4["Create and start containers"]
 step4 --> step5["Expose fit4j.* properties"]
 step5 --> step6["Run tests using services"]
</div></div>
<p>Narrative:</p>
<ol>
<li>JUnit discovers a test class with <code>@FIT</code>.</li>
<li>FIT4J’s context customizer inspects annotations for Testcontainers.</li>
<li>Matching YAML definitions (global or selective) are loaded.</li>
<li><code>TestContainerDefinition</code> instances create and start containers (optionally populating data).</li>
<li>Container properties are exposed as <code>fit4j.&lt;name&gt;.*</code> entries in the Spring environment.</li>
<li>Your tests run, using configured datasources, Redis, or Elasticsearch clients.</li>
</ol>
<hr />
<h2>Practical Usage Patterns</h2>
<h3>1. Simple Testcontainers test</h3>
<pre><code class="language-kotlin">// See README.md simple usage snippet, and src/test/kotlin/org/fit4j/testcontainers/... for patterns
@org.testcontainers.junit.jupiter.Testcontainers
@FIT
class SampleFIT {

  @Test
  fun `test something`() {
      // Use containers defined in fit4j-test-containers.yml
  }
}
</code></pre>
<h3>2. Selective registration</h3>
<pre><code class="language-kotlin">// See README.md and TestContainersWithSelectiveRegistrationFIT.kt
@FIT
@org.fit4j.testcontainers.Testcontainers(definitions = [&quot;redisContainerDefinition&quot;])
class RedisOnlyFIT {

  @Test
  fun `redis based test`() {
      // Only Redis container is started
  }
}
</code></pre>
<h3>3. Use exposed properties in application configuration</h3>
<pre><code class="language-properties"># See README.md and application-test.properties
spring.datasource.url=${fit4j.mySQLContainerDefinition.jdbcUrl}
spring.datasource.username=${fit4j.mySQLContainerDefinition.username}
spring.datasource.password=${fit4j.mySQLContainerDefinition.password}
redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}
</code></pre>
<h3>4. Use embedded Redis instead of Testcontainers</h3>
<pre><code class="language-kotlin">// See README.md Embedded Redis section
@EmbeddedRedis(useRandomPort = true)
@FIT
class EmbeddedRedisFIT {

    @Test
    fun `test with embedded redis`() {
        // The port is available via fit4j.embeddedRedisServer.port
    }
}
</code></pre>
<hr />
<h2>When to Choose What</h2>
<ul>
<li><strong>YAML + Testcontainers</strong><br />
  Use when:</li>
<li>You need realistic infrastructure (exact versions of Redis/DB/Elasticsearch).</li>
<li>Tests should behave similarly to production.</li>
<li>
<p>You want declarative container configuration with reuse, environment, and init scripts.</p>
</li>
<li>
<p><strong>Embedded Services</strong><br />
  Use when:</p>
</li>
<li>Docker is not available or desirable (e.g. CI with strict constraints, developer laptops).</li>
<li>You are fine with differences from production behavior.</li>
<li>You want faster tests with fewer external dependencies.</li>
</ul>
<p>For details on FIT and test categorization, see the “Getting Started” or “Project Overview” sections in the main documentation.</p>
  </div>
</section>


<section id="section-external-integrations-and-data-flow" class="dw-section">
  <div class="dw-section-inner">
    <h1>External Integrations &amp; Data Flow</h1>
<p>This page explains how Fit4J drives and observes interactions between your service and external systems during Functional Integration Tests (FITs). It focuses on how HTTP/gRPC mocks, Kafka, Testcontainers-backed services (MySQL, PostgreSQL, Redis, DynamoDB, Elasticsearch, S3) and embedded components are wired together using YAML fixtures and container definitions.</p>
<p>The goal is to help you understand <em>where</em> external calls go in tests, <em>what data</em> flows through them, and <em>how</em> to configure those flows declaratively.</p>
<hr />
<h2>High-Level Integration Model</h2>
<p>In a FIT, your microservice runs as close to production as possible: real Spring context, real repositories, and real clients. Only external boundaries are replaced:</p>
<ul>
<li><strong>Synchronous external dependencies</strong> (REST/gRPC) are mocked via fixture files.</li>
<li><strong>Async/message dependencies</strong> (Kafka) run against an embedded or Testcontainers broker.</li>
<li><strong>Stateful dependencies</strong> (MySQL/PostgreSQL/Redis/DynamoDB/Elasticsearch/S3) run against Testcontainers or embedded servers with fixture-based initial data.</li>
</ul>
<p>At a high level:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
sequenceDiagram
 participant A as Test runner
 participant B as Your service
 participant C as External mock
 participant D as Testcontainers stack
 A->>B: Send HTTP/gRPC/Kafka request
 B->>C: Call external REST/gRPC
 C-->>B: Return fixture response
 B->>D: Read/write DB/cache/search
 D-->>B: Persisted test data visible
 B-->>A: Response / side effects
</div></div>
<ul>
<li>Fixture files: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L1-L60"><code>src/test/resources/fit4j-fixtures-sample.yml:1-60</code></a></li>
<li>Container definitions: <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L60"><code>src/test/resources/fit4j-test-containers.yml:1-60</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L60"><code>src/test/resources/fit4j-test-containers-sample.yml:1-60</code></a></li>
<li>Example scenarios: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L1-L60"><code>fit4j-examples/README.md:1-60</code></a></li>
</ul>
<hr />
<h2>Fixture-Driven External Service Mocks (HTTP &amp; gRPC)</h2>
<p>Fit4J lets you define external service behavior declaratively in a test classpath file (typically <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>).</p>
<h3>Structure of <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a></h3>
<p>Example from <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L1-L60"><code>src/test/resources/fit4j-fixtures-sample.yml:1-60</code></a>:</p>
<pre><code class="language-yaml">common_fixtures: &amp;common_fixtures
  - request:
      protocol: http
      path: &quot;/health&quot;
      response:
        status: 200

tests:
  - name: test1
    fixtures:
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.TestGrpc$GetAgeRequest
          response:
            body:
              age: 10
      - request:
          protocol: grpc
          type: com.example.fit4j.grpc.TestGrpc$GetFooByIdRequest
          response:
            body:
              foo:
                id: &quot;#{@testFixture.variables.fooId}&quot;
      - request:
          protocol: http
          path: &quot;/foo&quot;
          response:
            status: 200
      - request:
          protocol: http
          path: &quot;/foo/123&quot;
          response:
            status: 200
            body:
              id: 123
              name: &quot;Foo&quot;
      - &lt;&lt;: *common_fixtures
</code></pre>
<p>Key concepts:</p>
<ul>
<li>
<p><strong><code>tests[].name</code></strong><br />
  Binds fixtures to a specific test case name. <code>"*"</code> can be used as a wildcard default, see <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L60-L80"><code>src/test/resources/fit4j-fixtures-sample.yml:60-80</code></a>.</p>
</li>
<li>
<p><strong><code>fixtures[].request.protocol</code></strong>  </p>
</li>
<li><code>http</code>: Intercepts REST calls (typically via Spring MVC/WebClient/RestTemplate).</li>
<li>
<p><code>grpc</code>: Intercepts gRPC calls (via grpc-spring-boot starter).</p>
</li>
<li>
<p><strong>HTTP fixtures</strong>  </p>
</li>
<li>Keys: <code>method</code> (optional, defaults to any), <code>path</code>, optional <code>predicate</code> for advanced logic.</li>
<li>
<p>Response shape:</p>
<p><code>yaml
response:
  status: 200
  body:
    id: 123
    name: "Foo"</code></p>
</li>
<li>
<p><strong>gRPC fixtures</strong>  </p>
</li>
<li>Keys: <code>type</code> is the full Protobuf request class name.</li>
<li>
<p>Response body mimics the message structure:</p>
<p><code>yaml
response:
  body:
    id: 123
    name: "Foo1"</code></p>
<p>See example in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L120-L138"><code>README.md:120-138</code></a>:</p>
<p><code>yaml
tests:
  - name: SampleFIT
    fixtures:
      - request:
          protocol: grpc
          type: com.example.FooGrpcService$GetFooByIdRequest
          predicate: "#request.id == 123"
          response:
            body:
              id: 123
              name: "Foo1"</code></p>
</li>
<li>
<p><strong>Multiple responses</strong> for the same request (e.g., retries) using <code>responses</code>:</p>
</li>
</ul>
<p><code>yaml
  - request:
      protocol: grpc
      type: com.example.fit4j.grpc.TestGrpc$GetAgeRequest
      responses:
        - body:
            age: 10
        - status: "UNAVAILABLE"</code></p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L60-L80"><code>src/test/resources/fit4j-fixtures-sample.yml:60-80</code></a>.</p>
<h3>Data Flow: External HTTP / gRPC Calls</h3>
<p>Scenario: Your service calls an external gRPC service to fetch a Foo by id.</p>
<ol>
<li>Test sends a request to your service (HTTP/gRPC/Kafka).</li>
<li>Your service’s client issues a gRPC call <code>GetFooByIdRequest</code> with <code>id = 123</code>.</li>
<li>Fit4J inspects <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> and matches:</li>
<li><code>protocol: grpc</code></li>
<li><code>type: com.example.FooGrpcService$GetFooByIdRequest</code></li>
<li><code>predicate: "#request.id == 123"</code></li>
<li>Fit4J returns the configured response body instead of hitting a real external network.</li>
<li>Your service processes the response as if it came from the real service.</li>
</ol>
<p>Notes:</p>
<ul>
<li>Predicates and expressions (<code>#request.*</code>, <code>@testFixture.variables.*</code>) let you make fixtures dynamic.</li>
<li>See “[How to Define Request-Response Trainings for External Services?]” description in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L140-L170"><code>README.md:140-170</code></a> for conceptual background.</li>
</ul>
<hr />
<h2>Kafka Integration &amp; Message Tracing</h2>
<p>Fit4J supports two Kafka setups:</p>
<ul>
<li><strong>Embedded Kafka</strong> via Spring Kafka Test.</li>
<li><strong>Kafka via Testcontainers</strong> using <code>org.testcontainers.containers.GenericContainer</code>.</li>
</ul>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L100"><code>README.md:60-100</code></a>:</p>
<ul>
<li>“Declarative Kafka Consumer definitions for consuming Kafka messages to verify within the test method”</li>
<li>“Built-in Embedded Kafka broker configuration for Kafka message publishing and verification”</li>
<li>“Automatic tracing of Kafka messages published and consumed by your service”</li>
</ul>
<p>Typical flows:</p>
<ul>
<li><strong>Inbound Kafka</strong>: Test publishes messages to a topic → your service consumes and processes → side effects on DB/Elasticsearch/Redis.</li>
<li><strong>Outbound Kafka</strong>: Your service publishes messages → Fit4J traces them and exposes the consumed/published records for assertions.</li>
</ul>
<p>You define the Kafka container in YAML (see <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L40-L70"><code>src/test/resources/fit4j-test-containers-sample.yml:40-70</code></a>):</p>
<pre><code class="language-yaml">- container: org.testcontainers.containers.GenericContainer
  name: kafka-service-bus
  image: confluentinc/cp-kafka:5.4.3
  reuse: true
</code></pre>
<p>How this affects data flow:</p>
<ol>
<li>Fit4J starts the Kafka container with the specified image.</li>
<li>Connection properties (e.g., bootstrap servers) are exposed as Spring properties using <code>exposedProperties</code> (if configured).</li>
<li>Your Spring Kafka producers/consumers use these properties transparently.</li>
<li>Tests can:</li>
<li>Send messages into Kafka.</li>
<li>Assert consumed/published messages via Fit4J’s tracing support (see examples under <code>fit4j-examples/example-kafka/</code> and <code>fit4j-examples/example-kafka-testcontainers/</code>).</li>
</ol>
<hr />
<h2>Databases via Testcontainers (MySQL &amp; PostgreSQL)</h2>
<p>Fit4J uses Testcontainers to spin up real relational databases.</p>
<h3>MySQL Example</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L200-L235"><code>README.md:200-235</code></a>:</p>
<pre><code class="language-yaml">- container: org.testcontainers.containers.MySQLContainer
  name: mysqlContainerDefinition
  image: mysql:8.0.30
  ports:
    - 3306
  username: root
  password: ********
  databaseName: v1
  initScript: scripts/v1_init.sql
  env:
    - TZ: &quot;America/Los_Angeles&quot;
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
    - useLegacyDatetimeCode: &quot;false&quot;
  exposedProperties:
    - jdbcUrl
    - username
    - password
  reuse: true
</code></pre>
<p>Key behavior:</p>
<ul>
<li><strong><code>initScript</code></strong> is executed at container startup to preload schema/data.</li>
<li><strong><code>exposedProperties</code></strong> are mapped into Spring’s environment, letting your service inject JDBC URL, username and password dynamically.</li>
<li><strong><code>urlParam</code></strong> configures connection parameters (timezone, legacy date code) on the JDBC URL.</li>
<li>Tests read DB state directly or assert service behavior that depends on this data.</li>
</ul>
<p>See MySQL example tests: <code>fit4j-examples/example-mysql/</code> (referenced in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L10-L25"><code>fit4j-examples/README.md:10-25</code></a>).</p>
<h3>PostgreSQL Example</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L40"><code>src/test/resources/fit4j-test-containers.yml:1-40</code></a>:</p>
<pre><code class="language-yaml">- container: org.testcontainers.containers.PostgreSQLContainer
  name: postgresContainerDefinition
  image: postgres:13
  username: postgres
  password: ********
  databaseName: testdb
  env:
    - TZ: &quot;UTC&quot;
    - POSTGRES_HOST_AUTH_METHOD: trust
  exposedProperties:
    - jdbcUrl
    - username
    - password
    - host
    - firstMappedPort
  reuse: false
</code></pre>
<ul>
<li><strong><code>reuse: false</code></strong> ensures a clean container for each test run.</li>
<li><code>host</code> and <code>firstMappedPort</code> can be used if you configure a non-Spring client manually.</li>
</ul>
<p>Flow:</p>
<ol>
<li>On test startup, PostgreSQL container is launched.</li>
<li>Spring bootstraps repositories using container-provided JDBC URL.</li>
<li>Your service uses the DB as usual; tests can interrogate real relational state.</li>
</ol>
<hr />
<h2>Redis Integration (Testcontainers &amp; Embedded)</h2>
<p>Fit4J supports Redis both as a Testcontainers service and embedded server.</p>
<h3>Redis via Testcontainers</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L200-L235"><code>README.md:200-235</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L40-L70"><code>src/test/resources/fit4j-test-containers.yml:40-70</code></a>:</p>
<pre><code class="language-yaml">- container: org.testcontainers.containers.GenericContainer
  name: redisContainerDefinition
  image: redis:6.2.1
  initScript: scripts/redis_initial_data.yml
  exposedPorts:
    - 6379
  exposedProperties:
    - host
    - firstMappedPort
  reuse: false
</code></pre>
<ul>
<li><strong><code>initScript</code></strong> points to a YAML file used to populate Redis at startup.</li>
<li><strong><code>exposedProperties</code></strong> provide host/port to your service.</li>
</ul>
<p>Initial data shape (from <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L240-L265"><code>README.md:240-265</code></a>):</p>
<pre><code class="language-yaml">- entry:
    type: &quot;string&quot;
    data:
        key: &quot;stringKey&quot;
        value: &quot;stringValue&quot;
- entry:
    type: &quot;hash&quot;
    data:
        key: &quot;hashKey&quot;
        fields:
            field1: &quot;value1&quot;
            field2: &quot;value2&quot;
</code></pre>
<p>Supported types: <code>string</code>, <code>hash</code>, <code>list</code>, <code>set</code>, <code>sortedset</code>, <code>bitmap</code>, <code>hyperloglog</code>, <code>geospatial</code>, <code>stream</code><br />
(see <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L265-L275"><code>README.md:265-275</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/scripts/redis_initial_data.yml"><code>src/test/resources/scripts/redis_initial_data.yml</code></a> for full structure).</p>
<p>Data flow:</p>
<ol>
<li>Testcontainers Redis is started.</li>
<li>Fit4J parses <a href="https://github.com/harezmi/fit4j/blob/main/redis_initial_data.yml"><code>redis_initial_data.yml</code></a> and populates keys accordingly.</li>
<li>Your service interacts with Redis as usual; tests can assert side effects by reading keys or via service behavior.</li>
</ol>
<h3>Embedded Redis</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L275-L310"><code>README.md:275-310</code></a>:</p>
<ul>
<li>Fit4J can start an embedded Redis (powered by <code>com.github.codemonstur:embedded-redis</code>, see <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L20-L35"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:20-35</code></a>).</li>
<li>Activation is typically annotation-driven (e.g., <code>@EmbeddedRedis</code> on the test class) — see “[How to Work with Embedded Redis?]” section referenced in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L275-L310"><code>README.md:275-310</code></a>.</li>
</ul>
<p>Flow differences:</p>
<ul>
<li>No Docker dependency.</li>
<li>Good for fast unit-like FITs where container startup is too heavy.</li>
</ul>
<p>Examples: <code>fit4j-examples/example-redis-embedded/</code> (listed in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L20-L35"><code>fit4j-examples/README.md:20-35</code></a>).</p>
<hr />
<h2>DynamoDB Integration (Testcontainers &amp; Embedded)</h2>
<p>Fit4J supports DynamoDB both via Testcontainers and as an embedded local instance.</p>
<h3>DynamoDB via Testcontainers</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L70-L100"><code>src/test/resources/fit4j-test-containers-sample.yml:70-100</code></a>:</p>
<pre><code class="language-yaml">- container: org.testcontainers.containers.GenericContainer
  name: dynamodb
  image: amazon/dynamodb-local:1.13.6
  exposedPorts:
    - 8000
</code></pre>
<ul>
<li>Your AWS DynamoDB client in the service should be configured to point to this local endpoint.</li>
<li>Typical data flow:</li>
<li>Service issues DynamoDB operations (CreateTable, PutItem, Query, etc.).</li>
<li>All traffic goes to <code>dynamodb-local</code> running in Testcontainers.</li>
<li>Tests assert item presence or behavior via the service layer.</li>
</ul>
<p>Example scenarios: <code>fit4j-examples/example-dynamodb-testcontainers/</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L25-L40"><code>fit4j-examples/README.md:25-40</code></a>).</p>
<h3>Embedded DynamoDB</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L275-L310"><code>README.md:275-310</code></a>:</p>
<blockquote>
<p>“In order to enable this feature, all you need to add <code>@EmbeddedDynamoDB</code> annotation on top of your test class. That way the test library will start an embedded DynamoDB instance and override the AWS DynamoDB client bean definition in your service with the embedded DynamoDB client.”</p>
</blockquote>
<p>Flow:</p>
<ol>
<li>Test class is annotated with <code>@EmbeddedDynamoDB</code>.</li>
<li>Fit4J starts an embedded DynamoDB instance (version controlled via <code>dynamoDBLocalVersion</code> in <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L10-L20"><code>gradle.properties:10-20</code></a>).</li>
<li>The AWS DynamoDB client bean in your service context is replaced with a client pointing at the embedded DB.</li>
<li>Your service uses DynamoDB as normal; tests see real persistence semantics.</li>
</ol>
<p>Examples: <code>fit4j-examples/example-dynamodb/</code> as referenced in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L20-L40"><code>fit4j-examples/README.md:20-40</code></a>.</p>
<hr />
<h2>Elasticsearch Integration</h2>
<p>Elasticsearch is provided via <code>org.testcontainers.elasticsearch.ElasticsearchContainer</code>.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L200-L235"><code>README.md:200-235</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L70-L110"><code>src/test/resources/fit4j-test-containers.yml:70-110</code></a>:</p>
<pre><code class="language-yaml">- container: org.testcontainers.elasticsearch.ElasticsearchContainer
  name: elasticSearchContainerDefinition
  image: docker.elastic.co/elasticsearch/elasticsearch:8.10.2
  initScript: scripts/elasticsearch_initial_data.yml
  exposedPorts:
    - 9200
    - 9300
  env:
    - ELASTICSEARCH_USERNAME: root
    - ELASTICSEARCH_PASSWORD: ********
    - xpack.security.enabled: false
    - bootstrap.memory_lock: true
    - cluster.routing.allocation.disk.threshold_enabled: false
    - JAVA_TOOL_OPTIONS: -Xmx10G
</code></pre>
<p>Features (from <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L60-L100"><code>README.md:60-100</code></a>):</p>
<ul>
<li>“Initial data population for ElasticSearch containers”</li>
<li>Elasticsearch Java / REST clients are used (see <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L10-L25"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:10-25</code></a>).</li>
</ul>
<p>Data flow:</p>
<ol>
<li>Container is started with the given environment (security disabled when desired).</li>
<li><code>initScript</code> YAML is used to create indices and seed documents.</li>
<li>Your service queries or indexes documents.</li>
<li>Tests verify query results and indexing side effects.</li>
</ol>
<p>Examples: <code>fit4j-examples/example-elasticsearch/</code> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L15-L30"><code>fit4j-examples/README.md:15-30</code></a>).</p>
<hr />
<h2>S3 Integration via Localstack</h2>
<p>Fit4J supports S3 testing via Localstack + Testcontainers.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md#L35-L45"><code>fit4j-examples/README.md:35-45</code></a>:</p>
<ul>
<li>“<a href="example-s3">S3</a> contains test examples to demonstrate how to write FITs accessing AWS S3 using Localstack Testcontainers.”</li>
</ul>
<p>Typical setup (in the example module’s test container YAML, not shown in the root snippets):</p>
<ul>
<li>A Localstack container is defined exposing S3.</li>
<li>The AWS S3 client in your service is configured to point at Localstack, typically via:</li>
<li>Endpoint URL</li>
<li>Region</li>
<li>Fake credentials (masked in docs, e.g., <code>accessKey=****</code>, <code>secretKey=********</code>).</li>
</ul>
<p>Flow:</p>
<ol>
<li>Localstack container is started.</li>
<li>Buckets are created and optionally pre-populated (via startup scripts or test code).</li>
<li>Your service performs S3 operations (PutObject, GetObject, ListObjects).</li>
<li>Tests assert presence/content of objects independently or via service responses.</li>
</ol>
<hr />
<h2>Testcontainers Configuration YAML</h2>
<p>The central place to describe external dependencies is the Testcontainers YAML file(s):</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers.yml#L1-L110"><code>src/test/resources/fit4j-test-containers.yml:1-110</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-test-containers-sample.yml#L1-L100"><code>src/test/resources/fit4j-test-containers-sample.yml:1-100</code></a></li>
</ul>
<p>Common fields:</p>
<pre><code class="language-yaml">- container: &lt;FQCN of container type&gt;
  name: &lt;logicalName&gt;
  image: &lt;dockerImage:tag&gt;
  ports: [optional, for non-specialized containers]
  exposedPorts: [mapped ports]
  initScript: &lt;classpath:/scripts/file.ext&gt;
  env:
    - KEY: &quot;VALUE&quot;
  urlParam:
    - paramKey: &quot;value&quot;
  exposedProperties:
    - jdbcUrl
    - username
    - password
    - host
    - firstMappedPort
  reuse: true|false
</code></pre>
<p>Behavior:</p>
<ul>
<li><strong><code>container</code></strong> decides which Testcontainers class is used:</li>
<li><code>org.testcontainers.containers.MySQLContainer</code></li>
<li><code>org.testcontainers.containers.PostgreSQLContainer</code></li>
<li><code>org.testcontainers.elasticsearch.ElasticsearchContainer</code></li>
<li><code>org.testcontainers.containers.GenericContainer</code> (for Kafka, Redis, DynamoDB, Localstack, etc.).</li>
<li><strong><code>initScript</code></strong> is interpreted differently depending on container:</li>
<li>SQL for DBs.</li>
<li>YAML for Redis and Elasticsearch.</li>
<li><strong><code>exposedProperties</code></strong> are exported into Spring environment so your service can auto-wire configuration.</li>
</ul>
<p>These files are automatically discovered and applied when Fit4J’s Testcontainers support is enabled
(see “How to Work with TestContainers?” in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L100-L140"><code>README.md:100-140</code></a> for the mechanisms and annotations involved).</p>
<hr />
<h2>Data Flow Scenarios</h2>
<p>Below are common FIT scenarios illustrating cross-integration behavior.</p>
<h3>Scenario 1: REST Call → DB + Elasticsearch Side Effects</h3>
<ol>
<li>Test sends HTTP request to your service (endpoint covered in the REST example module, see <code>fit4j-examples/example-rest/</code>).</li>
<li>Service:</li>
<li>Reads MySQL/Postgres via containers (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml#L1-L40"><code>fit4j-test-containers.yml:1-40</code></a>).</li>
<li>Writes or updates records.</li>
<li>Indexes search data in Elasticsearch (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml#L70-L110"><code>fit4j-test-containers.yml:70-110</code></a>).</li>
<li>Test asserts:</li>
<li>HTTP response body.</li>
<li>Database state via repositories or service.</li>
<li>Elasticsearch documents via search queries.</li>
</ol>
<h3>Scenario 2: Kafka Message → External gRPC Mock → Redis Cache</h3>
<ol>
<li>Test publishes a Kafka message to the topic used by your service (Kafka setup in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers-sample.yml#L40-L70"><code>fit4j-test-containers-sample.yml:40-70</code></a>).</li>
<li>Service consumes message and:</li>
<li>Calls external gRPC service; response is served from <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures-sample.yml#L1-L60"><code>src/test/resources/fit4j-fixtures-sample.yml:1-60</code></a>).</li>
<li>Writes results to Redis (Redis container via <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml#L40-L70"><code>fit4j-test-containers.yml:40-70</code></a> with initial data YAML).</li>
<li>Test asserts:</li>
<li>Redis keys/values.</li>
<li>Possibly the outbound Kafka messages produced, using Fit4J’s Kafka tracing.</li>
</ol>
<h3>Scenario 3: HTTP Call → DynamoDB → S3</h3>
<ol>
<li>Test sends HTTP request to your service.</li>
<li>Service:</li>
<li>Stores a record in DynamoDB (either embedded or via Testcontainers as configured).</li>
<li>Uploads an associated object to S3 (Localstack-based container in the S3 example).</li>
<li>Test:</li>
<li>Queries DynamoDB to confirm item shape.</li>
<li>Fetches object from S3 to validate content.</li>
</ol>
<hr />
<h2>Version &amp; Dependency Notes</h2>
<p>Integration libraries used (see <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties#L1-L20"><code>gradle.properties:1-20</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/gradle.properties#L1-L15"><code>fit4j-examples/gradle.properties:1-15</code></a>):</p>
<ul>
<li>Spring Boot: <code>springBootVersion=3.3.7</code></li>
<li>gRPC: <code>grpcVersion=1.58.0</code> / <code>1.63.0</code></li>
<li>Protobuf: <code>protobufJavaVersion=3.21.2</code></li>
<li>Testcontainers: <code>testcontainersVersion=1.15.3</code></li>
<li>DynamoDB local: <code>dynamoDBLocalVersion=2.2.1</code></li>
<li>Elasticsearch: <code>elasticSearchVersion=8.9.1</code></li>
<li>Redis (Jedis): <code>redisVersion=4.2.3</code></li>
</ul>
<p>Third-party clients and infrastructure libraries are licence-checked in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L1-L40"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:1-40</code></a>.</p>
<hr />
<h2>Configuration Impact Summary</h2>
<ul>
<li><strong>Fixture files</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>):</li>
<li>Control <em>logical behavior</em> of external HTTP/gRPC mocks.</li>
<li>
<p>Affect what your service “sees” when calling other services.</p>
</li>
<li>
<p><strong>Testcontainers config</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers-sample.yml"><code>fit4j-test-containers-sample.yml</code></a>):</p>
</li>
<li>Control <em>physical environment</em> (databases, caches, message brokers).</li>
<li><code>initScript</code> and initial data YAML determine initial state.</li>
<li>
<p><code>reuse</code> impacts test isolation vs startup time.</p>
</li>
<li>
<p><strong>Annotations</strong> (described in <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L140-L190"><code>README.md:140-190</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L275-L310"><code>README.md:275-310</code></a>):</p>
</li>
<li><code>@Testcontainers</code> enables container bootstrap.</li>
<li><code>@EmbeddedDynamoDB</code> and embedded Redis annotation (name may vary) switch to embedded infrastructure.</li>
</ul>
<p>When modifying these configs, consider:</p>
<ul>
<li>Changing <code>initScript</code> or Redis/Elasticsearch data YAML changes baseline data for all tests using that environment.</li>
<li>Adding new fixtures or predicates changes behavior of external mocks and can impact multiple tests if they share fixture names or the wildcard test <code>"*"</code>.</li>
</ul>
<p>For terminology on FIT/IT and other concepts, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-configuration-and-property-management" class="dw-section">
  <div class="dw-section-inner">
    <h1>Configuration &amp; Property Management</h1>
<p>This page explains how FIT4J manages configuration and properties for tests. It focuses on <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> usage, FIT4J-specific <code>fit4j.*</code> properties, conditional auto-configuration via <code>@EnableOnFIT</code>, MockWebServer/Testcontainers-related properties, and environment-specific overrides.</p>
<p>The goal is to show how to wire your test infrastructure (HTTP mocks, containers, Kafka, etc.) into your Spring Boot test configuration in a predictable, profile‑driven way.</p>
<hr />
<h2>1. Profiles, <code>@FIT</code> and Test Property Loading</h2>
<h3>1.1 <code>@FIT</code> and the <code>test</code> profile</h3>
<p>FIT test classes are Spring Boot tests with additional wiring and conventions.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<blockquote>
<p>The <code>@FIT</code> annotation marks the test class as an FIT test class. FIT test classes are basically <code>@SpringBootTest</code> classes with some additional capability. It also activates <code>test</code> profile in your service and enables bean overriding capability of the Spring Container.</p>
</blockquote>
<p>Typical usage:</p>
<pre><code class="language-kotlin">// See README.md:~200-230 (approx)
@FIT(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleFIT {
    // ...
}
</code></pre>
<p>Key effects for configuration:</p>
<ul>
<li><strong>Spring profile <code>test</code> is activated</strong> automatically.</li>
<li>Spring Boot will load:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/application.properties"><code>application.properties</code></a> (or <a href="https://github.com/harezmi/fit4j/blob/main/application.yml"><code>application.yml</code></a>)</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> (or <a href="https://github.com/harezmi/fit4j/blob/main/application-test.yml"><code>application-test.yml</code></a>)</li>
<li>Bean overriding is allowed for test-specific wiring.</li>
</ul>
<p>You generally place your FIT4J-specific wiring in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/resources/application.properties"><code>src/main/resources/application.properties</code></a> – baseline defaults</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties"><code>src/test/resources/application-test.properties</code></a> – test-only overrides</li>
</ul>
<p>Example from examples module:<br />
<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-rest/src/test/resources/application-test.properties#L1-L2"><code>fit4j-examples/example-rest/src/test/resources/application-test.properties:1-2</code></a></p>
<pre><code class="language-properties">example-service.host=${fit4j.mockWebServer.host}
example-service.port=${fit4j.mockWebServer.port}
</code></pre>
<p>Example from main test resources:<br />
<a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties#L1-L13"><code>src/test/resources/application-test.properties:1-13</code></a></p>
<pre><code class="language-properties">redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}

elasticSearch.host=${fit4j.elasticSearchContainerDefinition.host}
elasticSearch.port=${fit4j.elasticSearchContainerDefinition.port}

logging.level.root=fatal
logging.level.org.fit4j=debug
logging.level.org.springframework.boot=debug

spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer

spring.kafka.template.default-topic=fit4j-test-topic
</code></pre>
<p>In both cases, FIT4J-generated <code>fit4j.*</code> properties are consumed by your app’s own properties.</p>
<hr />
<h2>2. FIT4J Property Model</h2>
<p>FIT4J exposes a number of properties under the <code>fit4j.</code> namespace, which are then consumed by your Spring configuration (e.g. <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>).</p>
<h3>2.1 Auto-set vs user-set properties</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ol>
<li><strong>Auto-set properties</strong> are created and managed by FIT4J, and should not be manually defined in your configuration. They are meant to be <em>consumed</em> in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>.</li>
<li><strong>Container properties</strong> follow <code>fit4j.&lt;container-name&gt;.&lt;property&gt;</code>, where <code>&lt;container-name&gt;</code> is defined in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>.</li>
</ol>
<p>Example usage (properties are <em>read</em> from <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>):<br />
<code>README.md:~350-370</code></p>
<pre><code class="language-properties"># Using MockWebServer properties
externalService.hostname=${fit4j.mockWebServer.host}
externalService.port=${fit4j.mockWebServer.port}

# Using TestContainer properties
spring.datasource.url=${fit4j.mySQLContainerDefinition.jdbcUrl}
spring.datasource.username=${fit4j.mySQLContainerDefinition.username}
spring.datasource.password=${fit4j.mySQLContainerDefinition.password}

# Configuring Kafka timeouts
fit4j.kafka.waitTimeout=2000
fit4j.kafka.waitLoopCount=50

# Enabling topic cleanup
fit4j.kafka.topicCleaner.enabled=true
</code></pre>
<p>Notes:</p>
<ul>
<li>Properties like <code>fit4j.mockWebServer.host</code> and <code>fit4j.mockWebServer.port</code> are <strong>auto-set</strong> by FIT4J.</li>
<li>Properties like <code>fit4j.kafka.waitTimeout</code> are <strong>user-set</strong> knobs that modify FIT4J’s behavior.</li>
</ul>
<hr />
<h2>3. Conditional Configuration with <code>@EnableOnFIT</code></h2>
<h3>3.1 <code>@EnableOnFIT</code> annotation</h3>
<p>The <code>@EnableOnFIT</code> meta-annotation is used to only enable certain auto-configurations when executing functional integration tests (FIT).</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/EnableOnFIT.kt#L1-L13"><code>src/main/kotlin/org/fit4j/autoconfigure/EnableOnFIT.kt:1-13</code></a></p>
<pre><code class="language-kotlin">package org.fit4j.autoconfigure

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ConditionalOnProperty(
    name = [&quot;fit4j.testClass.isFunctionalIntegrationTest&quot;],
    havingValue = &quot;true&quot;,
    matchIfMissing = false
)
annotation class EnableOnFIT
</code></pre>
<p>Behavior:</p>
<ul>
<li>Any configuration class annotated with <code>@EnableOnFIT</code> is only loaded when:</li>
<li><code>fit4j.testClass.isFunctionalIntegrationTest=true</code> is present in the <code>Environment</code>.</li>
<li>FIT4J automatically sets this property when you use the <code>@FIT</code> annotation on a test class.</li>
</ul>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> (properties table):  </p>
<ul>
<li><code>fit4j.testClass.name</code> – fully qualified test class name (auto-set).  </li>
<li><code>fit4j.testClass.simpleName</code> – simple test class name (auto-set).  </li>
<li><code>fit4j.testClass.isIntegrationTest</code> – set to <code>true</code> when using <code>@IT</code>.  </li>
<li><code>fit4j.testClass.isFunctionalIntegrationTest</code> – set to <code>true</code> when using <code>@FIT</code>.</li>
</ul>
<p>You <strong>never</strong> set <code>fit4j.testClass.isFunctionalIntegrationTest</code> yourself; it is driven by the annotation.</p>
<h3>3.2 Auto-configuration classes gated by <code>@EnableOnFIT</code></h3>
<p>Example: HTTP mocking auto-configuration.</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt#L1-L22"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:1-22</code></a></p>
<pre><code class="language-kotlin">package org.fit4j.autoconfigure

import org.fit4j.http.HttpServerDispatcher
import org.fit4j.http.HttpServerWrapper
import org.fit4j.mock.MockResponseFactory
import org.fit4j.mock.MockServiceCallTracker
import org.fit4j.properties.MockWebServerProperties
import org.springframework.boot.autoconfigure.AutoConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.core.env.ConfigurableEnvironment
import org.springframework.core.env.getProperty
import org.springframework.http.HttpHeaders

@AutoConfiguration
@EnableOnFIT
class TestHttpAutoConfiguration {

    @Bean
    fun mockWebServerProperties(env: ConfigurableEnvironment) : MockWebServerProperties {
        val hostName = env.getProperty(&quot;fit4j.mockWebServer.host&quot;,&quot;localhost&quot;)
        val port = env.getProperty(&quot;fit4j.mockWebServer.port&quot;,8080)
        return MockWebServerProperties(hostName,port)
    }

    @Bean
    fun httpServerDispatcher(
        httpServerWrapper: HttpServerWrapper,
        mockServiceCallTracker: MockServiceCallTracker,
        mockResponseFactory: MockResponseFactory
    ) : HttpServerDispatcher {
        val dispatcher = HttpServerDispatcher(mockServiceCallTracker, mockResponseFactory)
        // ...
        return dispatcher
    }
}
</code></pre>
<p>Key points:</p>
<ul>
<li><code>TestHttpAutoConfiguration</code> is only active in FIT tests (<code>fit4j.testClass.isFunctionalIntegrationTest=true</code>).</li>
<li>It reads <code>fit4j.mockWebServer.host</code> and <code>fit4j.mockWebServer.port</code> from the environment and wraps them in a <code>MockWebServerProperties</code> bean.</li>
<li>If the properties are not present, defaults to <code>localhost:8080</code> (useful for local, non-FIT runs).</li>
</ul>
<hr />
<h2>4. MockWebServer Properties</h2>
<p>When HTTP mocking is enabled and <code>okhttp3.MockWebServer</code> is on the test classpath, FIT4J exposes a running MockWebServer instance and its properties.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> (HTTP features &amp; properties table):</p>
<ul>
<li>FIT4J exposes:</li>
<li>A MockWebServer <strong>Spring bean</strong>.</li>
<li>Environment properties:<ul>
<li><code>fit4j.mockWebServer.host</code> (String, auto-set)</li>
<li><code>fit4j.mockWebServer.port</code> (Integer, auto-set)</li>
</ul>
</li>
</ul>
<p>Usage in your <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>:</p>
<p><a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-rest/src/test/resources/application-test.properties#L1-L2"><code>fit4j-examples/example-rest/src/test/resources/application-test.properties:1-2</code></a></p>
<pre><code class="language-properties">example-service.host=${fit4j.mockWebServer.host}
example-service.port=${fit4j.mockWebServer.port}
</code></pre>
<p>For a REST client you might configure:</p>
<pre><code class="language-properties"># See README.md:~360-370
externalService.hostname=${fit4j.mockWebServer.host}
externalService.port=${fit4j.mockWebServer.port}
</code></pre>
<p>This causes your service under test to call the MockWebServer instead of a real external endpoint, while keeping all URLs and ports <strong>property-driven</strong>.</p>
<p>Internally, <code>TestHttpAutoConfiguration</code> wraps these values into <code>MockWebServerProperties</code> as shown above.</p>
<hr />
<h2>5. Testcontainers and <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a></h2>
<h3>5.1 Declarative container definitions</h3>
<p>FIT4J provides declarative Testcontainers support via a YAML configuration file named <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> in the test resources directory.</p>
<p>Example from <code>README.md:~420-450</code>:</p>
<pre><code class="language-yaml"># See README.md:~420-450
- container: org.testcontainers.containers.MySQLContainer
  name: mySQLContainerDefinition
  image: mysql:5.7.33
  exposedPorts:
    - 3306
  username: root
  password: ********
  databaseName: v1
  initScript: scripts/v1_init.sql
  env:
    - TZ: &quot;America/Los_Angeles&quot;
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
</code></pre>
<p>Fields:</p>
<ul>
<li><code>container</code> – concrete Testcontainers class.</li>
<li><code>name</code> – logical container name; used as <code>&lt;container-name&gt;</code> in <code>fit4j.&lt;container-name&gt;.*</code>.</li>
<li><code>exposedPorts</code> – container ports.</li>
<li>Credentials and other sensitive values should be masked or externalized in real projects; never commit real passwords.</li>
</ul>
<h3>5.2 Auto-exposed properties per container</h3>
<p>From the properties reference section in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ul>
<li><code>fit4j.&lt;container-name&gt;.host</code> (String, auto-set) – host address of the container.</li>
<li><code>fit4j.&lt;container-name&gt;.port</code> (Integer, auto-set) – first mapped port.</li>
<li><code>fit4j.&lt;container-name&gt;.&lt;exposed-property&gt;</code> (Various, auto-set) – any property listed in the container’s <code>exposedProperties</code> section (e.g., <code>jdbcUrl</code>, <code>username</code>, <code>password</code>, etc.).</li>
</ul>
<p>Example usage in a datasource configuration:</p>
<pre><code class="language-properties"># See README.md:~360-370
spring.datasource.url=${fit4j.mySQLContainerDefinition.jdbcUrl}
spring.datasource.username=${fit4j.mySQLContainerDefinition.username}
spring.datasource.password=${fit4j.mySQLContainerDefinition.password}
</code></pre>
<p>The general rule:</p>
<blockquote>
<p>The format to access exposed properties is <code>fit4j.&lt;container-name&gt;.&lt;exposed-property-name&gt;</code>.</p>
</blockquote>
<p>So, for:</p>
<ul>
<li>Container <code>name: redisContainerDefinition</code>  </li>
<li>Exposed property <code>host</code>  </li>
</ul>
<p>You can write in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>:</p>
<pre><code class="language-properties">redis.host=${fit4j.redisContainerDefinition.host}
redis.port=${fit4j.redisContainerDefinition.port}
</code></pre>
<p>(As shown in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/application-test.properties#L1-L4"><code>src/test/resources/application-test.properties:1-4</code></a>.)</p>
<h3>5.3 Reuse of containers</h3>
<p>From <code>README.md:~380-410</code>:</p>
<ul>
<li>Containers are created and optionally <strong>reused</strong> if marked with <code>reuse: true</code> in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>.</li>
<li>To enable reuse locally, you must add:</li>
</ul>
<p><code>$HOME/.testcontainers.properties:1</code></p>
<pre><code class="language-properties">testcontainers.reuse.enable=true
</code></pre>
<p>This is <strong>not</strong> an application property; it is read by Testcontainers directly and affects container lifecycle. It is per‑developer and typically not committed to source control.</p>
<hr />
<h2>6. FIT4J Kafka &amp; Declarative Fixture Properties</h2>
<p>Several FIT4J behavioral knobs are configured via properties that you set in <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> (or <a href="https://github.com/harezmi/fit4j/blob/main/application.properties"><code>application.properties</code></a> for shared defaults).</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> (Kafka and fixture configuration section):</p>
<ul>
<li><code>fit4j.kafka.waitTimeout</code> (Long, default <code>2000</code>)  </li>
<li>Milliseconds to wait for a Kafka operation (e.g. consumption) to complete.</li>
<li><code>fit4j.kafka.waitLoopCount</code> (Integer, default <code>50</code>)  </li>
<li>Number of loops during waiting; effectively controls polling granularity.</li>
<li><code>fit4j.kafka.delayBeforeMessageConsumption</code> (Long, default <code>500</code>)  </li>
<li>Delay before consuming messages to ensure DB transactions are committed.</li>
<li><code>fit4j.kafka.topicCleaner.enabled</code> (Boolean, default <code>false</code>)  </li>
<li>Enables automatic cleanup of Kafka topics after each test method.</li>
</ul>
<p>Declarative fixture behavior:</p>
<ul>
<li><code>fit4j.declarativeTestFixtureDrivenResponseGeneration.enabled</code> (Boolean, default <code>false</code>)  </li>
<li>When <code>true</code>, only declarative fixtures are used to build mock responses (no programmatic builders).</li>
</ul>
<p>Example configuration:</p>
<pre><code class="language-properties"># See README.md:~360-370
fit4j.kafka.waitTimeout=2000
fit4j.kafka.waitLoopCount=50
fit4j.kafka.topicCleaner.enabled=true

fit4j.declarativeTestFixtureDrivenResponseGeneration.enabled=false
</code></pre>
<p>These values adjust <strong>how FIT4J behaves</strong>; they usually don’t appear in your service code, but in test property files.</p>
<hr />
<h2>7. Test Class Metadata Properties</h2>
<p>FIT4J exposes information about the test class as environment properties, which can be used for conditional configuration or logging.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ul>
<li><code>fit4j.testClass.name</code> (String, auto-set)  </li>
<li>Fully qualified test class name.</li>
<li><code>fit4j.testClass.simpleName</code> (String, auto-set)  </li>
<li>Simple test class name.</li>
<li><code>fit4j.testClass.isIntegrationTest</code> (Boolean, default <code>true</code> when using <code>@IT</code>)  </li>
<li>Indicates that the test is an integration test.</li>
<li><code>fit4j.testClass.isFunctionalIntegrationTest</code> (Boolean, default <code>true</code> when using <code>@FIT</code>)  </li>
<li>Indicates a functional integration test; used by <code>@EnableOnFIT</code>.</li>
</ul>
<p>These are <strong>read-only</strong> for test code; you should not override them in properties files. They are intended for internal conditional configuration (like <code>@EnableOnFIT</code>) or advanced use-cases (e.g., routing fixtures based on test class).</p>
<hr />
<h2>8. Putting It All Together: Typical Configuration Flow</h2>
<p>The following sequence diagram shows how test configuration flows from annotations and YAML into runtime properties and beans:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
sequenceDiagram
 participant A as TestClass
 participant B as SpringContext
 participant C as FIT4J
 participant D as ExternalInfra
 A->>B: Start @FIT test
 B->>C: Load FIT4J auto config
 C->>D: Start containers and mocks
 D-->>C: Expose host/port/jdbcUrl
 C-->>B: Set fit4j.* properties
 B-->>A: Inject configured beans
</div></div>
<p>Typical steps in a functional integration test:</p>
<ol>
<li>You annotate a test with <code>@FIT</code>, which:</li>
<li>Activates the <code>test</code> profile.</li>
<li>Marks the class as a functional integration test (sets <code>fit4j.testClass.isFunctionalIntegrationTest=true</code>).</li>
<li>Spring Boot loads <a href="https://github.com/harezmi/fit4j/blob/main/application.properties"><code>application.properties</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a>.</li>
<li>FIT4J auto-configurations guarded by <code>@EnableOnFIT</code> (e.g., <a href="https://github.com/harezmi/fit4j/blob/main/TestHttpAutoConfiguration.kt"><code>TestHttpAutoConfiguration.kt</code></a>) are activated.</li>
<li>FIT4J:</li>
<li>Starts MockWebServer, embedded Kafka, gRPC server, Testcontainers instances based on <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a>.</li>
<li>Exposes environment properties like:<ul>
<li><code>fit4j.mockWebServer.host</code>, <code>fit4j.mockWebServer.port</code></li>
<li><code>fit4j.&lt;container-name&gt;.host</code>, <code>fit4j.&lt;container-name&gt;.port</code>, <code>fit4j.&lt;container-name&gt;.jdbcUrl</code>, etc.</li>
</ul>
</li>
<li>Your app’s <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a> consumes these to configure:</li>
<li>Datasources (<code>spring.datasource.url</code>, etc.)</li>
<li>REST client endpoints (<code>example-service.host</code>, <code>example-service.port</code>, etc.)</li>
<li>Kafka test tuning (<code>fit4j.kafka.waitTimeout</code>, etc.).</li>
<li>Final beans (e.g., <code>MockWebServerProperties</code>, data sources, HTTP clients) are fully wired and ready for each test.</li>
</ol>
<hr />
<h2>9. Guidelines and Best Practices</h2>
<ul>
<li><strong>Do not manually define auto-set <code>fit4j.*</code> properties</strong> in your property files; let FIT4J manage them.</li>
<li><strong>Use <a href="https://github.com/harezmi/fit4j/blob/main/application-test.properties"><code>application-test.properties</code></a></strong> to wire <code>fit4j.*</code> values into your own application properties.</li>
<li><strong>Use <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a></strong> to declaratively specify the containers you need; rely on <code>fit4j.&lt;container-name&gt;.*</code> properties instead of hardcoding host/port/URLs.</li>
<li><strong>Enable Testcontainers reuse</strong> locally via <code>$HOME/.testcontainers.properties</code> if you want faster test runs:</li>
<li><code>testcontainers.reuse.enable=true</code></li>
<li><strong>Use property-based configuration instead of hard-coded values</strong> in your code so tests remain portable across environments.</li>
<li>Keep secrets and sensitive values out of source-controlled property files; use environment variables or secret management where necessary and mask in documentation (e.g., <code>password=********</code>).</li>
</ul>
<p>For definitions of terms like FIT, IT, MockWebServer, or declarative fixtures, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-getting-started-and-local-setup" class="dw-section">
  <div class="dw-section-inner">
    <h1>Getting Started &amp; Local Setup</h1>
<p>This page walks you through setting up FIT4J locally, building the project with Gradle/Maven, running the example tests in <code>fit4j-examples</code>, and writing your first FIT-based test for a simple HTTP or Kafka service. It assumes you are an experienced Java/Kotlin engineer but new to FIT4J.</p>
<hr />
<h2>1. Prerequisites</h2>
<p>Before you start:</p>
<ul>
<li><strong>JDK</strong>: Java 17+ (recommended; match your service baseline).</li>
<li><strong>Build tool</strong>: Gradle (Kotlin or Groovy DSL) or Maven.</li>
<li><strong>Git</strong>: To clone the repository.</li>
<li><strong>Docker</strong>: Required only for Testcontainers-based examples (Kafka, DBs, Redis, etc.).</li>
</ul>
<hr />
<h2>2. Clone the Repository</h2>
<p>Clone the main FIT4J repository:</p>
<pre><code class="language-bash">git clone https://github.com/&lt;your-org-or-user&gt;/fit4j.git
cd fit4j
</code></pre>
<p>The top-level <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> at the repo root explains the library and points to the examples.<br />
See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md"><code>/tmp/repo_fun8n87l/README.md</code></a> for the full text.</p>
<hr />
<h2>3. Building FIT4J</h2>
<h3>3.1 Gradle build (library itself)</h3>
<p>To compile and run tests for the FIT4J library:</p>
<pre><code class="language-bash">./gradlew clean build
</code></pre>
<p>This will:</p>
<ul>
<li>Compile main and test sources.</li>
<li>Run unit and integration tests (including sample <code>@FIT</code> tests under <code>src/test</code>).</li>
</ul>
<p>Relevant sample FIT classes in the library project:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt"><code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt</code></a><br />
  See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L1-L23"><code>/tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/sample/SampleFIT.kt:1-23</code></a>.</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt"><code>src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt</code></a><br />
  See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt#L1-L27"><code>/tmp/repo_fun8n87l/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-27</code></a>.</li>
</ul>
<p>These tests verify embedded Kafka, context handling, and basic wiring.</p>
<h3>3.2 Install to Maven Local (for local development)</h3>
<p>If you want to use your local FIT4J snapshot in another service:</p>
<pre><code class="language-bash">cd /path/to/fit4j
./gradlew publishToMavenLocal
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L20"><code>/tmp/repo_fun8n87l/README.md:1-20</code></a> for the Maven Local instructions.</p>
<p>Once published, you can depend on <code>org.fit4j:fit4j:1.0.0-SNAPSHOT</code> directly from your services without extra repositories.</p>
<hr />
<h2>4. Using FIT4J in Your Service</h2>
<h3>4.1 Add dependency (Gradle / Maven)</h3>
<p>From the root <code>README</code> (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L40"><code>/tmp/repo_fun8n87l/README.md:1-40</code></a>):</p>
<p><strong>Gradle (Kotlin DSL):</strong></p>
<pre><code class="language-kotlin">dependencies {
    testImplementation(&quot;org.fit4j:fit4j:1.0.0-SNAPSHOT&quot;)
}
</code></pre>
<p><strong>Gradle (Groovy DSL):</strong></p>
<pre><code class="language-groovy">dependencies {
    testImplementation &quot;org.fit4j:fit4j:1.0.0-SNAPSHOT&quot;
}
</code></pre>
<p>For snapshot builds, you may need the Sonatype snapshots repository:</p>
<pre><code class="language-kotlin">repositories {
    mavenCentral()
    maven {
        url = uri(&quot;https://s01.oss.sonatype.org/content/repositories/snapshots/&quot;)
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L25"><code>/tmp/repo_fun8n87l/README.md:1-25</code></a>.</p>
<p><strong>Maven repository snippet:</strong></p>
<pre><code class="language-xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;ossrh-snapshots&lt;/id&gt;
        &lt;url&gt;https://s01.oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h3>4.2 Sequential test execution (required)</h3>
<p>FIT4J currently does <strong>not</strong> support parallel execution of <code>@FIT</code> / <code>@IT</code> tests because of shared static state.<br />
See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L1-L30"><code>/tmp/repo_fun8n87l/README.md:1-30</code></a>.</p>
<p><strong>Gradle configuration:</strong></p>
<pre><code class="language-kotlin">tasks.test {
    maxParallelForks = 1
}
</code></pre>
<p><strong>Maven (Surefire / Failsafe):</strong></p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;parallel&gt;none&lt;/parallel&gt;
        &lt;forkCount&gt;1&lt;/forkCount&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>Running tests in parallel may lead to race conditions and flaky outcomes; keep it strictly sequential for FIT tests.</p>
<hr />
<h2>5. Exploring <code>fit4j-examples</code></h2>
<p>The <code>fit4j-examples</code> multi-module project is the best place to learn by concrete tests.</p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/README.md"><code>fit4j-examples/README.md</code></a> at <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/fit4j-examples/README.md#L1-L40"><code>/tmp/repo_fun8n87l/fit4j-examples/README.md:1-40</code></a>.</p>
<h3>5.1 Examples overview</h3>
<p>Key submodules:</p>
<ul>
<li><code>fit4j-examples/example-basic/</code> – Minimal FIT usage, wiring, basic assertions.</li>
<li><code>fit4j-examples/example-rest/</code> – HTTP/REST tests using Spring Boot + FIT4J.</li>
<li><code>fit4j-examples/example-kafka/</code> – Kafka tests using embedded Kafka + FIT4J.</li>
<li>Other modules (Elasticsearch, Redis, MySQL, H2, DynamoDB, S3 with Localstack, etc.) demonstrate Testcontainers usage.</li>
</ul>
<p>Each example:</p>
<ul>
<li>Is <strong>self-contained</strong> and runnable independently.</li>
<li>Has its own <a href="https://github.com/harezmi/fit4j/blob/main/build.gradle.kts"><code>build.gradle.kts</code></a> with minimal dependencies.</li>
<li>Shows one specific integration pattern (REST mock server, embedded Kafka, Testcontainers, etc.).</li>
</ul>
<h3>5.2 Running an example</h3>
<p>From the repository root:</p>
<pre><code class="language-bash">cd fit4j-examples/example-basic
./gradlew clean test
</code></pre>
<p>Or for Kafka:</p>
<pre><code class="language-bash">cd fit4j-examples/example-kafka
./gradlew clean test
</code></pre>
<p>The examples use standard Gradle test tasks; no custom runner is required.</p>
<hr />
<h2>6. Your First FIT: Minimal Example</h2>
<h3>6.1 Basic FIT test class</h3>
<p>The most minimal FIT test marks the class with <code>@FIT</code>.<br />
See <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt#L1-L23"><code>fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt:1-23</code></a>.</p>
<pre><code class="language-kotlin">// Source: fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt:1-23
package org.fit4j.examples.basic

import org.fit4j.annotation.FIT
import org.fit4j.helper.JsonHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired

@FIT
class SampleFIT {

    @Autowired
    private lateinit var helper: JsonHelper

    @Test
    fun `example test`() {
        Assertions.assertNotNull(helper)
    }

    @Test
    fun `another example test`() {
        Assertions.assertNotNull(helper)
    }
}
</code></pre>
<p>What this shows:</p>
<ul>
<li><code>@FIT</code> turns the JUnit 5 class into a functional integration test with a managed Spring context.</li>
<li><code>JsonHelper</code> is auto-configured as a test-scoped bean by FIT4J; the tests only verify that the context is built and the bean is available.</li>
</ul>
<p>This is a good pattern for verifying that your FIT plumbing and context customizations are working before writing more complex checks.</p>
<h3>6.2 FIT with fixtures (method-level configuration)</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> (<a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L60-L95"><code>/tmp/repo_fun8n87l/README.md:60-95</code></a>):</p>
<pre><code class="language-kotlin">// Source: README.md (example snippet)
import org.fit4j.annotation.FIT
import org.fit4j.annotation.FixtureForFIT
import org.junit.jupiter.api.Test

@FIT
class SampleFIT {

    @Test
    fun `test something`() {
        // basic FIT test
    }
}

// Example with method-level fixtures
@FIT(fixtureFilePath = &quot;classpath:custom-fixtures.yml&quot;)
class SampleFITWithMethodLevelFixtures {

    @Test
    @FixtureForFIT(&quot;fixture-group-1&quot;)
    fun `test with custom fixtures`() {
        // This test uses fixtures from the &quot;fixture-group-1&quot; section in custom-fixtures.yml
    }
}
</code></pre>
<p>Use this pattern when your service needs different test data / environment per method.<br />
The <code>fixtureFilePath</code> ties the class to a YAML file (placed under <code>src/test/resources</code>), and <code>@FixtureForFIT</code> picks the logical group.</p>
<hr />
<h2>7. First HTTP/REST FIT Test</h2>
<p>The REST examples live under <code>fit4j-examples/example-rest/</code>. The README snippet in the main project shows an inline example:<br />
See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L120-L155"><code>/tmp/repo_fun8n87l/README.md:120-155</code></a>.</p>
<pre><code class="language-kotlin">// Source: README.md (REST example snippet)
@FIT(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleFIT {
    @Autowired
    private lateinit var restTemplate: TestRestTemplate

    @Test
    fun `test rest endpoint`() {
        val response = restTemplate.getForObject(&quot;/sayHello&quot;, String::class.java)
        Assertions.assertEquals(&quot;Hello World!&quot;, response)
    }
}

@RestController
class TestRestController {
    @GetMapping(&quot;/sayHello&quot;)
    fun sayHello(): String {
        return &quot;Hello World!&quot;
    }
}
</code></pre>
<p>How this works:</p>
<ul>
<li><code>@FIT(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code><br />
  Boots a Spring Boot test application with an actual HTTP server on a random port.</li>
<li><code>TestRestTemplate</code> is injected; it resolves the random port automatically.</li>
<li>The test performs a real HTTP GET against your local controller and asserts the response.</li>
</ul>
<p>To adapt to your own service:</p>
<ol>
<li>Add <code>@FIT(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code> to your test class.</li>
<li>Autowire <code>TestRestTemplate</code> or WebTestClient.</li>
<li>Call your actual endpoints (<code>/api/v1/…</code>) and assert on body/status.</li>
</ol>
<hr />
<h2>8. First Kafka FIT Test</h2>
<p>FIT4J provides two ways to work with Kafka in tests:</p>
<ul>
<li><strong>Embedded Kafka</strong> (Spring Kafka Test).</li>
<li><strong>Testcontainers-based Kafka</strong> (for more realistic environment).</li>
</ul>
<h3>8.1 Embedded Kafka via Spring</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L1-L23"><code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt:1-23</code></a>:</p>
<pre><code class="language-kotlin">// Source: src/test/kotlin/org/fit4j/sample/SampleFIT.kt:1-23
package org.fit4j.sample

import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Value
import org.springframework.kafka.test.context.EmbeddedKafka
import org.springframework.test.annotation.DirtiesContext

@FIT
@EmbeddedKafka
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class SampleFIT {

    @Value(&quot;\${spring.kafka.bootstrap-servers}&quot;)
    private lateinit var kafkaBrokers: String

    @Test
    fun `it should work`() {
        Assertions.assertNotNull(kafkaBrokers)
    }
}
</code></pre>
<p>This example demonstrates:</p>
<ul>
<li><code>@EmbeddedKafka</code> spins up an in-memory Kafka broker for the test class.</li>
<li>The broker address is injected from <code>spring.kafka.bootstrap-servers</code>.</li>
<li><code>@DirtiesContext(AFTER_CLASS)</code> ensures the Spring context is closed after the class finishes, preventing race conditions on JVM shutdown when using embedded Kafka.</li>
</ul>
<p>A richer example with <code>KafkaMessageTracker</code> from the main README (see <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L160-L210"><code>/tmp/repo_fun8n87l/README.md:160-210</code></a>):</p>
<pre><code class="language-kotlin">// Source: README.md (Kafka + tracker example snippet)
import org.fit4j.kafka.EnableEmbeddedKafka
import org.fit4j.annotation.FIT
import org.fit4j.kafka.KafkaMessageTracker
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.kafka.core.KafkaTemplate

@EnableEmbeddedKafka
@FIT
class SampleFIT {

  @Autowired
  private lateinit var fooRepository: FooRepository

  @Autowired
  private lateinit var kafkaTemplate: KafkaTemplate&lt;String, Any&gt;

  @Autowired
  private lateinit var kafkaMessageTracker: KafkaMessageTracker

  @Test
  fun testFoo() {
      // Publish a message
      val message = Foo.newBuilder().setId(123).setName(&quot;Foo&quot;).build()
      kafkaTemplate.send(&quot;foo-create-topic&quot;, message).get()

      // Wait for the service to process the message
      val processedMessage = kafkaMessageTracker.waitForProcessing(message)
      // Assert on processedMessage and fooRepository state
  }
}
</code></pre>
<p>To adapt in your service:</p>
<ol>
<li>Annotate your test with <code>@EnableEmbeddedKafka</code> (from FIT4J) or <code>@EmbeddedKafka</code> (from Spring Kafka Test).</li>
<li>Inject <code>KafkaTemplate</code> and <code>KafkaMessageTracker</code>.</li>
<li>Send messages into your input topics and wait for them to be processed.</li>
<li>Assert on downstream states (DB, other topics, HTTP side effects, etc.).</li>
</ol>
<h3>8.2 Kafka Testcontainers (advanced)</h3>
<p>The <code>fit4j-examples/example-kafka-testcontainers/</code> module demonstrates using a real Kafka broker via Testcontainers. The high-level pattern:</p>
<pre><code class="language-kotlin">// Source: README.md (Testcontainers + FIT snippet)
import org.testcontainers.junit.jupiter.Testcontainers
import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Test

@Testcontainers
@FIT
class SampleFIT {

  @Test
  fun `test something`() {
      // your FIT using real containers
  }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L210-L260"><code>/tmp/repo_fun8n87l/README.md:210-260</code></a>.</p>
<p>You then define containers in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-test-containers.yml"><code>fit4j-test-containers.yml</code></a> under <code>src/test/resources</code>. Example excerpt:</p>
<pre><code class="language-yaml"># Source: README.md (Testcontainers YAML example snippet)
- container: org.testcontainers.containers.MySQLContainer
  name: mySQLContainerDefinition
  image: mysql:5.7.33
  exposedPorts:
    - 3306
  username: root
  password: ********
  databaseName: v1
  initScript: scripts/v1_init.sql
  env:
    - TZ: &quot;America/Los_Angeles&quot;
  urlParam:
    - serverTimezone: &quot;America/Los_Angeles&quot;
</code></pre>
<p>All credentials are masked; never commit real passwords or secrets.</p>
<hr />
<h2>9. Running Sample Tests from <code>fit4j-examples</code></h2>
<h3>9.1 Basic example (<code>SampleFIT</code>)</h3>
<p>To run the minimal FIT:</p>
<pre><code class="language-bash">cd fit4j-examples/example-basic
./gradlew test
</code></pre>
<p>This executes <code>SampleFIT</code> from<br />
<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt#L1-L23"><code>fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt:1-23</code></a>.</p>
<h3>9.2 REST example (<code>RestExampleFIT</code>-style tests)</h3>
<p>In <code>fit4j-examples/example-rest</code>, run:</p>
<pre><code class="language-bash">cd fit4j-examples/example-rest
./gradlew test
</code></pre>
<p>Typical steps in those tests:</p>
<ul>
<li>Spring Boot context is started with an HTTP server.</li>
<li>Test uses <code>TestRestTemplate</code> or WebTestClient to hit REST endpoints.</li>
<li>Assertions verify HTTP responses and possibly DB/Kafka side effects.</li>
</ul>
<h3>9.3 Kafka example (<code>KafkaExampleFIT</code>)</h3>
<p>In <code>fit4j-examples/example-kafka</code>, run:</p>
<pre><code class="language-bash">cd fit4j-examples/example-kafka
./gradlew test
</code></pre>
<p>Core test class: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-kafka/src/test/kotlin/org/fit4j/examples/kafka/KafkaExampleFIT.kt#L1-L40"><code>fit4j-examples/example-kafka/src/test/kotlin/org/fit4j/examples/kafka/KafkaExampleFIT.kt:1-40</code></a>:</p>
<pre><code class="language-kotlin">// Source: fit4j-examples/example-kafka/src/test/kotlin/org/fit4j/examples/kafka/KafkaExampleFIT.kt:1-40
package org.fit4j.examples.kafka

import com.example.fit4j.grpc.FooGrpcService
import com.google.protobuf.Message
import org.apache.kafka.common.serialization.Deserializer
import org.apache.kafka.common.serialization.Serializer
import org.fit4j.annotation.FIT
import org.fit4j.kafka.KafkaMessageTracker
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.test.context.EmbeddedKafka

@FIT
@EmbeddedKafka
class KafkaExampleFIT {

    @Autowired
    private lateinit var kafkaTemplate: KafkaTemplate&lt;String, Message&gt;

    @Autowired
    private lateinit var kafkaMessageTracker: KafkaMessageTracker

    @Test
    fun `test something with kafka`() {
        // Publish, wait and assert...
    }
}
</code></pre>
<p>You can use this as a template for your own Kafka FIT tests.</p>
<hr />
<h2>10. Configuration &amp; Properties</h2>
<p>FIT4J uses your service’s usual config files (<a href="https://github.com/harezmi/fit4j/blob/main/application.yml"><code>application.yml</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/application.properties"><code>application.properties</code></a>, etc.). Additionally:</p>
<ul>
<li>Kafka-timeout related properties (from README, <a href="https://github.com/harezmi/fit4j/blob/main//tmp/repo_fun8n87l/README.md#L260-L290"><code>/tmp/repo_fun8n87l/README.md:260-290</code></a>):</li>
</ul>
<pre><code class="language-properties"># Configuring Kafka timeouts
fit4j.kafka.waitTimeout=2000
fit4j.kafka.waitLoopCount=50

# Enabling topic cleanup
fit4j.kafka.topicCleaner.enabled=true
</code></pre>
<p><strong>Effect:</strong></p>
<ul>
<li><code>fit4j.kafka.waitTimeout</code>: how long (in ms) the tracker waits for a message to appear before giving up.</li>
<li><code>fit4j.kafka.waitLoopCount</code>: how many polling loops to perform when waiting.</li>
<li><code>fit4j.kafka.topicCleaner.enabled</code>: if <code>true</code>, FIT4J cleans up Kafka topics between tests to avoid cross-test pollution.</li>
</ul>
<p>Ensure any sensitive values (DB passwords, tokens) are masked in committed configs:</p>
<pre><code class="language-properties">spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=test_user
spring.datasource.password=********
</code></pre>
<hr />
<h2>11. Quick Local Flow Recap</h2>
<p>Use this sequence when adding FIT4J to a new service:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Add FIT4J dependency"] --> step2["Configure sequential tests"]
 step2 --> step3["Write first @FIT test"]
 step3 --> step4["Run Gradle or Maven tests"]
 step4 --> step5["Inspect context and side effects"]
</div></div>
<ol>
<li>Add <code>org.fit4j:fit4j:1.0.0-SNAPSHOT</code> to your <code>testImplementation</code> / <code>test</code> scope.</li>
<li>Disable test parallelism in Gradle/Maven for FIT tests.</li>
<li>Start with a minimal <code>@FIT</code> class (e.g., REST or Kafka sample).</li>
<li>Run <code>./gradlew test</code> or <code>mvn test</code> and verify context and basic assertions.</li>
<li>Gradually evolve tests to cover realistic HTTP/Kafka/DB flows, referencing the <code>fit4j-examples</code> modules as patterns.</li>
</ol>
<hr />
<p>You now have the essential steps to get FIT4J running locally, explore the examples, and author your first FIT-based tests for HTTP and Kafka flows. For deeper details on specific integrations (gRPC, databases, Redis, S3, etc.), see the corresponding example modules under <code>fit4j-examples</code>.</p>
  </div>
</section>


<section id="section-coding-standards-and-conventions" class="dw-section">
  <div class="dw-section-inner">
    <h1>Coding Standards &amp; Contribution Conventions</h1>
<p>This page summarizes how to write, test, and contribute code to the FIT4J repository. It consolidates expectations from <a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> and adds practical guidance so that new contributors can align quickly with existing patterns.</p>
<p>The focus is on code style (Kotlin/Java), test organization, documentation updates, branching and commit message conventions, and pull request (PR) expectations.</p>
<hr />
<h2>Overview of Contribution Workflow</h2>
<p>The basic contributor workflow is:</p>
<ol>
<li>Fork the repository and clone your fork.</li>
<li>Create a feature branch from <code>main</code>.</li>
<li>Implement changes following the code style &amp; testing rules.</li>
<li>Run tests locally and ensure they pass.</li>
<li>Commit with a clear, descriptive message.</li>
<li>Push your branch and open a Pull Request against <code>main</code>.</li>
</ol>
<p>Key references:</p>
<ul>
<li>Contribution guide: <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a></li>
<li>Project overview and quick contributor steps: <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a></li>
</ul>
<hr />
<h2>Development Setup &amp; Build Commands</h2>
<p>Although this section is not a full setup guide, there are a few commands and tools you are expected to use as part of contributing.</p>
<h3>Prerequisites</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a>:</p>
<ul>
<li>Java 17 or higher</li>
<li>Gradle 7.x or higher</li>
<li>Git</li>
</ul>
<p>For additional environment details and library usage, see <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>.</p>
<h3>Build &amp; Test Commands</h3>
<p>Run full build:</p>
<pre><code class="language-bash">./gradlew build
</code></pre>
<p>Run entire test suite:</p>
<pre><code class="language-bash">./gradlew test
</code></pre>
<p>Run specific tests (e.g., FIT4J tests):</p>
<pre><code class="language-bash">./gradlew test --tests &quot;org.fit4j.*&quot;
</code></pre>
<p>Source: <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a></p>
<p>These commands must succeed locally before you push and open a PR.</p>
<hr />
<h2>Code Style Guidelines</h2>
<p>The project is primarily focused on Kotlin and Java, but the documented conventions are Kotlin-oriented. When in doubt, follow existing patterns in the codebase.</p>
<h3>General Style Principles</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a>:</p>
<ul>
<li>Follow Kotlin coding conventions.</li>
<li>Use 4 spaces for indentation (no tabs).</li>
<li>Follow existing code style patterns in the repository.</li>
<li>Use meaningful variable and function names.</li>
<li>Add KDoc/Javadoc comments for public APIs.</li>
</ul>
<h4>Kotlin-Specific Conventions</h4>
<p>Likely expectations, based on standard Kotlin style and existing guidance:</p>
<ul>
<li>Prefer <code>val</code> over <code>var</code> when values are immutable.</li>
<li>Use expressive function names that describe intent rather than implementation.</li>
<li>Organize imports and avoid wildcard imports unless explicitly required.</li>
<li>Group related top-level declarations logically, typically one public type per file.</li>
</ul>
<p>Example (illustrative):</p>
<pre><code class="language-kotlin">/**
 * Executes a functional integration test scenario.
 */
fun runScenario(scenarioName: String) {
    // ...
}
</code></pre>
<p>You would typically find such functions in packages like <code>org.fit4j.*</code> (see <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a> examples for references).</p>
<h4>Java Code</h4>
<p>If you add or modify Java code:</p>
<ul>
<li>Follow standard Java conventions (e.g., Google/IntelliJ style).</li>
<li>Align with existing Java classes in the repository (naming, packaging).</li>
<li>Use Javadoc for public methods and classes.</li>
</ul>
<hr />
<h2>Testing Guidelines</h2>
<p>FIT4J is itself a testing library; therefore, tests are first-class citizens. From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>:</p>
<h3>Core Rules</h3>
<ul>
<li>All new features must include tests.</li>
<li>Tests should be clear and focused, each verifying a single behavior or scenario.</li>
<li>Use descriptive test names; Kotlin backtick notation for expressive names is welcome.</li>
<li>Ensure tests are independent and can run in any order.</li>
<li>Tests must run sequentially (parallel execution is currently not supported).</li>
</ul>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a> (FAQ and limitations):</p>
<ul>
<li>Parallel test execution is not supported; running tests in parallel leads to race conditions due to shared static state managing test context.</li>
<li>Make sure your build configuration disables parallel execution, for example:</li>
</ul>
<p><code>kotlin
  // build.gradle.kts (example, do not copy credentials here)
  tasks.test {
      useJUnitPlatform()
      maxParallelForks = 1
  }</code></p>
<blockquote>
<p>For more details on functional integration tests and how FIT4J is used in tests, see the main documentation in <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>.</p>
</blockquote>
<h3>Test Naming</h3>
<p>For Kotlin tests, this is encouraged:</p>
<pre><code class="language-kotlin">@Test
fun `should execute scenario when request is valid`() {
    // ...
}
</code></pre>
<p>This style makes tests self-documenting.</p>
<h3>Test Scope &amp; Coverage</h3>
<p>When implementing a new feature:</p>
<ul>
<li>Add at least one positive-path test.</li>
<li>Add negative-path or edge-case tests where applicable (e.g., invalid input, missing configuration).</li>
<li>If behavior can be configured via properties, add tests for default and non-default configurations.</li>
</ul>
<hr />
<h2>Documentation Expectations</h2>
<p>Documentation updates are part of the definition of done for a change.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>:</p>
<ul>
<li>Update <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> if you add new features or change existing behavior.</li>
<li>Add Javadoc/KDoc for any new public APIs (classes, methods, top-level functions).</li>
<li>Update examples in the examples project if behavior changes.</li>
<li>Keep documentation clear and concise.</li>
</ul>
<p>Typical locations:</p>
<ul>
<li>Library overview and usage examples: <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a></li>
<li>Contribution process: <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a></li>
<li>License details: <code>/LICENSE</code>, <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a></li>
<li>Publishing guidance: <a href="https://github.com/harezmi/fit4j/blob/main//PUBLISHING.md"><code>/PUBLISHING.md</code></a></li>
</ul>
<p>When adding a new public API, consider:</p>
<ol>
<li>Adding KDoc/Javadoc to the API itself.</li>
<li>Adding an example snippet to the examples project (if applicable).</li>
<li>Updating <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> with a brief description and usage.</li>
</ol>
<hr />
<h2>Branching Strategy</h2>
<p>Branches are used to isolate work and simplify review.</p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>:</p>
<ul>
<li>Always create feature branches from <code>main</code>.</li>
<li>Use descriptive branch names, following the pattern:</li>
</ul>
<p><code>bash
  git checkout -b feature/your-feature-name</code></p>
<p>Examples:</p>
<ul>
<li><code>feature/add-http-fixture-support</code></li>
<li><code>bugfix/fix-grpc-timeout</code></li>
<li><code>chore/update-dependencies</code></li>
</ul>
<p>Guidelines:</p>
<ul>
<li>Use lowercase, hyphen-separated words.</li>
<li>Prefix with <code>feature/</code>, <code>bugfix/</code>, <code>chore/</code>, or another suitable prefix aligned with the repository’s conventions.</li>
<li>Keep branch names short but descriptive.</li>
</ul>
<hr />
<h2>Commit Message Conventions</h2>
<p>Commit messages should clearly describe the change. From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>:</p>
<ul>
<li>Use clear, descriptive commit messages.</li>
<li>Recommended pattern:</li>
</ul>
<p><code>bash
  git commit -m "Add: description of your changes"</code></p>
<p>Examples:</p>
<ul>
<li><code>Add: gRPC example for FIT4J</code></li>
<li><code>Fix: race condition in context initialization</code></li>
<li><code>Refactor: simplify test fixture setup</code></li>
</ul>
<p>Guidelines:</p>
<ul>
<li>Use a short verb phrase in present tense (<code>Add</code>, <code>Fix</code>, <code>Refactor</code>, <code>Update</code>, etc.).</li>
<li>Optionally prefix with a keyword and colon (<code>Add:</code>, <code>Fix:</code>, <code>Refactor:</code>) as shown above.</li>
<li>The subject line should be self-explanatory; if needed, add a longer body (using <code>git commit</code> without <code>-m</code> and writing a multi-line message).</li>
</ul>
<hr />
<h2>Pull Request Requirements</h2>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a>:</p>
<h3>Before Opening a PR</h3>
<ol>
<li><strong>Code style</strong>: Ensure your code follows existing patterns and style rules.</li>
<li><strong>Tests</strong>:</li>
<li>All existing tests must pass.</li>
<li>New tests added for all relevant functionality.</li>
<li>No parallel test execution in your build settings.</li>
<li><strong>Documentation</strong>:</li>
<li>Update <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> and other relevant docs if behavior or APIs changed.</li>
<li><strong>Local checks</strong>:</li>
<li><code>./gradlew test</code> and, if applicable, <code>./gradlew build</code> should succeed.</li>
</ol>
<h3>Opening a PR</h3>
<p>Typical process (as described in <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a>):</p>
<ol>
<li>Push your branch:</li>
</ol>
<p><code>bash
   git push origin feature/your-feature-name</code></p>
<ol>
<li>Open a Pull Request against the <code>main</code> branch in GitHub.</li>
<li>In the PR description:</li>
<li>Provide a clear summary of the changes and motivation.</li>
<li>Reference related issues (e.g., <code>Closes #123</code>).</li>
<li>Mention any breaking changes or migration impact.</li>
<li>Ensure CI checks (GitHub Actions/other pipelines) pass.</li>
</ol>
<p>Tips:</p>
<ul>
<li>Keep PRs focused; smaller, self-contained changes are easier to review.</li>
<li>If your PR touches multiple areas (e.g., new feature + refactor), clearly separate those in the description.</li>
</ul>
<hr />
<h2>Issue Reporting &amp; Enhancement Suggestions</h2>
<p>While not strictly “coding standards”, the way you report issues affects how maintainers can respond and how future contributions are shaped. From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a>:</p>
<h3>Reporting Bugs</h3>
<p>Include:</p>
<ul>
<li>Clear, descriptive title.</li>
<li>Steps to reproduce.</li>
<li>Expected vs actual behavior.</li>
<li>Environment details:</li>
<li>Java version</li>
<li>Kotlin version</li>
<li>Spring Boot version (if applicable)</li>
<li>Any relevant library versions</li>
<li>Logs or stack traces (remove/mask credentials and sensitive data).</li>
</ul>
<h3>Suggesting Enhancements</h3>
<p>Include:</p>
<ul>
<li>Clear description of the enhancement.</li>
<li>Use cases or concrete examples.</li>
<li>Potential implementation approach (if you have one).</li>
</ul>
<hr />
<h2>Licensing Considerations for Contributions</h2>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//CONTRIBUTING.md"><code>/CONTRIBUTING.md</code></a>, <code>/LICENSE</code>, <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a>, and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a>:</p>
<ul>
<li>By contributing to FIT4J, you agree that your contributions will be licensed under the Apache License 2.0, the same license as the project.</li>
<li>Ensure any dependencies you introduce are compatible with Apache 2.0.</li>
<li>If you add new dependencies, they should be documented in:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a></li>
<li>And reflected in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a> if necessary.</li>
</ul>
<p>Do not include any credentials or secrets in the code or documentation. If you need to demonstrate configuration, always mask sensitive fields:</p>
<pre><code class="language-properties">spring.datasource.url=jdbc:postgresql://localhost:5432/fit4j
spring.datasource.username=fit4j_user
spring.datasource.password=********
</code></pre>
<hr />
<h2>Quick Checklist for Contributors</h2>
<p>Before you push:</p>
<ul>
<li>[ ] Code follows Kotlin/Java conventions and existing repository style.</li>
<li>[ ] New features are covered by clear, focused tests.</li>
<li>[ ] Tests pass locally with sequential execution.</li>
<li>[ ] Public APIs have KDoc/Javadoc.</li>
<li>[ ] <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> and other docs updated as needed.</li>
<li>[ ] Commit messages are descriptive and follow the <code>Add:</code> / <code>Fix:</code> style.</li>
<li>[ ] Branch name is descriptive (<code>feature/...</code>, <code>bugfix/...</code>, etc.).</li>
<li>[ ] No secrets or credentials committed.</li>
</ul>
<p>For additional context on architecture, domains, or APIs, refer to the relevant wiki sections such as <strong>Architecture Overview</strong>, <strong>Execution Flow</strong>, or <strong>API Reference</strong> (when available).</p>
  </div>
</section>


<section id="section-api-reference-and-annotations" class="dw-section">
  <div class="dw-section-inner">
    <h1>Public API Reference &amp; Core Annotations</h1>
<p>This page documents the public annotation-based API that FIT4J exposes to consumers. It explains how to use <code>@FIT</code>, <code>@IT</code>, <code>@FixtureForFIT</code>, <code>@EnableEmbeddedKafka</code>, and the test scoping annotations in your own test code, and how they compose with Spring Boot test infrastructure and configuration properties.</p>
<p>The focus here is on how to write tests that leverage FIT4J’s features; internal implementation details and domain terminology are covered elsewhere (see [Glossary] and architecture sections).</p>
<hr />
<h2>Overview of the Annotation Model</h2>
<p>At a high level:</p>
<ul>
<li><code>@IT</code> is the <strong>base integration test annotation</strong>.</li>
<li><code>@FIT</code> builds on <code>@IT</code> and provides <strong>full functional‑integration‑test capabilities</strong> (fixtures, call/message tracking, etc.).</li>
<li><code>@FixtureForFIT</code> configures <strong>method‑level fixtures</strong> for <code>@FIT</code> tests.</li>
<li><code>@EnableEmbeddedKafka</code> enables FIT4J’s <strong>embedded Kafka support</strong> using Testcontainers / Spring Kafka test facilities.</li>
<li>Test scoping annotations like <code>@TestScoped</code> (and related <code>TestScope</code>) control <strong>lifecycle/visibility of beans within tests</strong> (likely implemented as a custom Spring scope).</li>
</ul>
<p>Use these annotations on JUnit 5 test classes and methods to declaratively enable the corresponding test infrastructure.</p>
<hr />
<h2><code>@FIT</code> – Functional Integration Test Annotation</h2>
<h3>Definition and Composition</h3>
<p><code>@FIT</code> is defined in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/FIT.kt#L1-L20"><code>src/main/kotlin/org/fit4j/annotation/FIT.kt:1-20</code></a></li>
</ul>
<pre><code class="language-kotlin">package org.fit4j.annotation

import org.fit4j.context.Fit4JTestExtension
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource
import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target


@IT
@TestPropertySource(properties = [&quot;fit4j.testClass.isFunctionalIntegrationTest=true&quot;])
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(Fit4JTestExtension::class)
annotation class FIT(
    val fixtureFilePath: String = &quot;&quot;,
    val webEnvironment: SpringBootTest.WebEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><strong>Builds on <code>@IT</code></strong>: <code>@FIT</code> is meta‑annotated with <code>@IT</code>, so everything <code>@IT</code> provides is automatically available.</li>
<li><strong>Sets a test-class flag</strong>: <code>@TestPropertySource(properties = ["fit4j.testClass.isFunctionalIntegrationTest=true"])</code> marks the test as a functional integration test. Internal code uses this flag to enable FIT‑specific features (fixtures, tracking, etc.).</li>
<li><strong>Registers JUnit 5 extension</strong>: <code>@ExtendWith(Fit4JTestExtension::class)</code> plugs in FIT4J’s test extension to manage fixtures, tracking, and other lifecycle hooks.</li>
<li><strong>Spring Boot integration</strong>: It behaves as a specialized <code>@SpringBootTest</code> (the exact meta‑annotations are in <code>@IT</code>), with configurable <code>webEnvironment</code>.</li>
</ul>
<h3>Parameters</h3>
<p><code>@FIT</code> exposes two optional parameters (see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/FIT.kt#L15-L19"><code>src/main/kotlin/org/fit4j/annotation/FIT.kt:15-19</code></a> and README examples):</p>
<ul>
<li><code>fixtureFilePath: String = ""</code></li>
<li>Path to the YAML fixture file.</li>
<li><strong>Default</strong>: uses <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> from the classpath.</li>
<li>Can be:<ul>
<li><code>classpath:custom-fixtures.yml</code></li>
<li><code>file:./test-fixtures/my-fixtures.yml</code></li>
</ul>
</li>
<li>
<p>Used by the FIT4J extension to load declarative fixtures once per application context and serve them to all test methods/classes.</p>
</li>
<li>
<p><code>webEnvironment: SpringBootTest.WebEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT</code></p>
</li>
<li>Propagates to underlying <code>@SpringBootTest</code>.</li>
<li>Typical values:<ul>
<li><code>RANDOM_PORT</code>: start an embedded web server on a random port (default).</li>
<li><code>DEFINED_PORT</code>: use the port defined in config.</li>
<li><code>MOCK</code>: no real server; use MockMvc / WebTestClient.</li>
</ul>
</li>
<li>Choose based on whether you test over HTTP, gRPC, or internal calls.</li>
</ul>
<h3>Behavior and Features Enabled</h3>
<p>From the README (<code>README.md:…</code> excerpts):</p>
<ul>
<li>FIT tests are “basically <code>@SpringBootTest</code> classes with some additional capability”.</li>
<li>Activates the <code>test</code> profile and <strong>enables bean overriding</strong> in the Spring container.</li>
<li>Enables <strong>programmatic and declarative request‑response trainings</strong>, sync call and async message tracking, etc.</li>
<li>Uses fixtures defined in YAML to seed DB state, external system mocks, or other environment data.</li>
</ul>
<p>Internally, <code>Fit4JTestExtension</code> (<code>org.fit4j.context.Fit4JTestExtension</code>, see source for details) is responsible for:</p>
<ul>
<li>Reading fixtures from <code>fixtureFilePath</code> or the default <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>.</li>
<li>Applying fixtures in appropriate lifecycle phases (before/after each test).</li>
<li>Wiring helper beans such as <code>VerificationHelper</code>, <code>MockServiceCallTracker</code>, Kafka trackers, etc., when available.</li>
</ul>
<h3>When to Use <code>@FIT</code></h3>
<p>Use <code>@FIT</code> when:</p>
<ul>
<li>You want <strong>end‑to‑end style</strong> tests that:</li>
<li>Hit the service via HTTP / gRPC / messaging.</li>
<li>Validate DB state, cache entries, side‑effectful operations.</li>
<li>Verify outbound calls and messages.</li>
<li>You need <strong>fixtures</strong> to declaratively set up input and expected output.</li>
<li>You require <strong>tracking</strong> (calls/messages) and ready‑to‑use helper beans provided by FIT4J.</li>
</ul>
<p>Example from README (<code>README.md:…</code>):</p>
<pre><code class="language-kotlin">// See README.md: &quot;Create a Test Class&quot; section
import org.fit4j.annotation.FIT
import org.fit4j.annotation.FixtureForFIT
import org.junit.jupiter.api.Test

@FIT
class SampleFIT {

    @Test
    fun `test something`() {
        // test logic
    }
}

// Example with method-level fixtures
@FIT(fixtureFilePath = &quot;classpath:custom-fixtures.yml&quot;)
class SampleFITWithMethodLevelFixtures {

    @Test
    @FixtureForFIT(&quot;fixture-group-1&quot;)
    fun `test with custom fixtures`() {
        // This test uses fixtures from the &quot;fixture-group-1&quot; section in custom-fixtures.yml
    }
}
</code></pre>
<p>See also:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L1-L18"><code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt:1-18</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt#L1-L21"><code>src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-21</code></a></li>
<li>Various Kafka FIT tests under <code>src/test/kotlin/org/fit4j/kafka/*FIT.kt</code>.</li>
</ul>
<hr />
<h2><code>@IT</code> – Base Integration Test Annotation</h2>
<h3>Purpose</h3>
<p>From the README (<code>README.md:…</code>):</p>
<blockquote>
<p><code>@IT</code> annotation just enables several configuration properties and infrastructural beans that are useful or necessary for ordinary integration tests which try to verify interactions among several components…</p>
</blockquote>
<p>and:</p>
<blockquote>
<p><code>@IT</code> annotation serves as a base annotation which enables some basic configuration and beans which are necessary for any kind of integration tests you already write in your services, such as configuring gRPC server as in process mode, enabling declarative testcontainer support etc. Our <code>@FIT</code> annotation already inherits from <code>@IT</code> annotation as well.</p>
</blockquote>
<p><strong>Conceptually:</strong></p>
<ul>
<li><code>@IT</code> is the “<strong>plain integration test</strong>” baseline.</li>
<li>It sets up:</li>
<li>gRPC in‑process server configuration (where applicable).</li>
<li>Testcontainers support (e.g., DB, Kafka, etc.) with declarative config.</li>
<li>Core beans needed to write typical Spring Boot integration tests without verbose configuration.</li>
</ul>
<h3>Relationship to <code>@FIT</code></h3>
<ul>
<li><code>@FIT</code> is annotated with <code>@IT</code>, so <strong>every <code>@FIT</code> test is also an <code>@IT</code> test</strong>.</li>
<li><code>@IT</code> alone does <strong>not</strong> provide:</li>
<li>FIT fixtures mechanism.</li>
<li>FIT request/response training features.</li>
<li>FIT call/message tracking helpers.</li>
<li>Use <code>@IT</code> directly if you:</li>
<li>Already have existing integration tests and just want the baseline infrastructure from FIT4J.</li>
<li>Do <strong>not</strong> need FIT fixtures or advanced FIT‑specific helpers.</li>
</ul>
<p>Implementation of <code>@IT</code> is not shown in the snippets here, but you can find it under:</p>
<ul>
<li>Likely <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/IT.kt"><code>src/main/kotlin/org/fit4j/annotation/IT.kt</code></a> (consult repo).</li>
</ul>
<p>For implementation specifics (e.g., which Spring Boot annotations and properties it sets), see that file.</p>
<hr />
<h2><code>@FixtureForFIT</code> – Method-Level Fixture Selection</h2>
<p><code>@FixtureForFIT</code> is used in combination with <code>@FIT</code> to specify which fixtures to apply for a particular test method.</p>
<p>Usage example (from <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> and <code>SampleFITWithMethodLevelFixtures</code>):</p>
<pre><code class="language-kotlin">// See README.md: &quot;Create a Test Class&quot; section
@FIT(fixtureFilePath = &quot;classpath:custom-fixtures.yml&quot;)
class SampleFITWithMethodLevelFixtures {

    @Test
    @FixtureForFIT(&quot;fixture-group-1&quot;)
    fun `test with custom fixtures`() {
        // This test uses fixtures from the &quot;fixture-group-1&quot; section in custom-fixtures.yml
    }
}
</code></pre>
<p><strong>Semantics:</strong></p>
<ul>
<li>The annotation argument (e.g. <code>"fixture-group-1"</code>) identifies a <strong>fixture group</strong> inside the YAML file pointed to by the <code>fixtureFilePath</code> of the enclosing <code>@FIT</code> class.</li>
<li>Fixtures are <strong>loaded once per Spring context</strong> and reused across test classes, as described in <code>README.md:…</code>:</li>
<li>“they are read only once by the test infrastructure and served to all test classes… ApplicationContext is not recreated for each test class”.</li>
</ul>
<p><strong>Typical YAML structure (conceptual):</strong></p>
<pre><code class="language-yaml"># fit4j-fixtures.yml or custom-fixtures.yml
fixture-group-1:
  # test data for group 1
fixture-group-2:
  # test data for group 2
</code></pre>
<p>Internal behavior (via <code>Fit4JTestExtension</code>):</p>
<ul>
<li>Before each test method with <code>@FixtureForFIT</code>, the extension:</li>
<li>Resolves the fixture group.</li>
<li>Applies DB state, stub configurations, or mocked responses based on the group definition.</li>
<li>After the test it may clean up/rollback depending on configuration.</li>
</ul>
<p>Use <code>@FixtureForFIT</code> when you:</p>
<ul>
<li>Want different sets of fixtures per test method in the same class.</li>
<li>Share fixtures across classes without copying setup code.</li>
</ul>
<hr />
<h2><code>@EnableEmbeddedKafka</code> – Kafka Support for Tests</h2>
<p><code>@EnableEmbeddedKafka</code> is FIT4J’s wrapper around the embedded Kafka integration. It simplifies Kafka usage in tests while handling context lifecycle and configuration.</p>
<h3>Usage Patterns</h3>
<p><strong>Example 1 – Minimal use with FIT:</strong></p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt:1-20
import org.fit4j.kafka.EnableEmbeddedKafka
import org.fit4j.annotation.FIT
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.ApplicationContext

@FIT
@EnableEmbeddedKafka
class KafkaAutoConfigurationEnabledFIT {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `kafka configuration should be enabled`() {
        val property = applicationContext.environment.getProperty(&quot;spring.kafka.bootstrap-servers&quot;)
        val beansMap = applicationContext.getBeansOfType(TestMessageListener::class.java)
        Assertions.assertNotNull(property)
        Assertions.assertTrue(beansMap.isNotEmpty())
    }
}
</code></pre>
<p><strong>Example 2 – Using tracker and template:</strong></p>
<pre><code class="language-kotlin">// See README.md: Kafka usage example
import org.fit4j.kafka.EnableEmbeddedKafka
import org.fit4j.annotation.FIT
import org.fit4j.kafka.KafkaMessageTracker
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.kafka.core.KafkaTemplate

@EnableEmbeddedKafka
@FIT
class SampleFIT {

  @Autowired
  private lateinit var fooRepository: FooRepository

  @Autowired
  private lateinit var kafkaTemplate: KafkaTemplate&lt;String, Any&gt;

  @Autowired
  private lateinit var kafkaMessageTracker: KafkaMessageTracker

  @Test
  fun testFoo() {
      val message = Foo.newBuilder().setId(123).setName(&quot;Foo&quot;).build()
      kafkaTemplate.send(&quot;foo-create-topic&quot;, message).get()
      val processedMessage = kafkaMessageTracker.waitForProcessing(message)
      // assertions...
  }
}
</code></pre>
<p><strong>Example 3 – Combined with Spring’s <code>@EmbeddedKafka</code> directly:</strong></p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-21
import org.springframework.kafka.test.context.EmbeddedKafka
import org.springframework.test.annotation.DirtiesContext

@FIT
@EmbeddedKafka(partitions = 1)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class YetAnotherSampleFIT {
    // ...
}
</code></pre>
<h3>Behavior and Differences vs Spring <code>@EmbeddedKafka</code></h3>
<p>From README (<code>README.md:…</code>):</p>
<ul>
<li>Spring Kafka’s <code>@EmbeddedKafka</code> usually requires <code>@DirtiesContext</code> to ensure:</li>
<li>The context is closed after the test class.</li>
<li>Embedded Kafka broker resources are released.</li>
<li>Race conditions on JVM shutdown are avoided.</li>
</ul>
<blockquote>
<p>However, this is not necessary when using <code>@EnableEmbeddedKafka</code>.</p>
</blockquote>
<p><strong>Implications:</strong></p>
<ul>
<li><code>@EnableEmbeddedKafka</code>:</li>
<li>Manages cleanup automatically so you <strong>do not need <code>@DirtiesContext</code></strong> in typical setups.</li>
<li>Integrates with FIT4J’s lifecycle to clean Kafka topics and resources safely.</li>
</ul>
<h3>Configuration Properties</h3>
<p>Tests often use <code>@TestPropertySource</code> to configure Kafka specifics, for example:</p>
<pre><code class="language-kotlin">// See src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt:1-30
@EmbeddedKafka
@FIT
@TestPropertySource(properties = [
    &quot;fit4j.kafka.consumers.file=classpath:consumers/KafkaMessageWithHeadersFIT-consumers.yml&quot;,
    &quot;spring.kafka.consumer.auto-offset-reset=earliest&quot;
])
class KafkaMessageWithHeadersFIT {
    // ...
}
</code></pre>
<p>Key properties used in samples:</p>
<ul>
<li><code>fit4j.kafka.consumers.file</code></li>
<li>Path to a YAML file describing <strong>consumer configurations</strong> (topics, listener groups, etc.).</li>
<li>
<p>Used by FIT4J to auto‑configure Kafka listener containers for tests.</p>
</li>
<li>
<p><code>fit4j.kafka.topicCleaner.enabled</code></p>
</li>
<li>Enables/disables a KafkaTopicCleaner bean (see <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt#L1-L35"><code>src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt:1-35</code></a>).</li>
<li>
<p>When <code>true</code>, topics can be cleaned between runs to keep tests isolated.</p>
</li>
<li>
<p><code>spring.kafka.consumer.auto-offset-reset</code></p>
</li>
<li>Standard Spring Kafka property; common values are <code>earliest</code>/<code>latest</code>.</li>
<li>When set to <code>earliest</code> in tests, consumers read from the beginning of the topic.</li>
</ul>
<p>All credentials or broker URLs that may be present in properties must be masked in documentation, e.g.:</p>
<pre><code class="language-properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username=&quot;user&quot; password=&quot;********&quot;;
</code></pre>
<hr />
<h2>Test Scoping Annotations: <code>@TestScoped</code> / <code>TestScope</code></h2>
<p>While the code snippets do not show the implementation, the presence of keywords <code>TestScoped</code> and <code>TestScope</code> in the section definition indicates a <strong>custom Spring bean scope</strong> designed for test usage.</p>
<h3>Likely Semantics</h3>
<p>Typically:</p>
<ul>
<li><code>@TestScoped</code> (annotation on bean definitions) marks beans whose <strong>lifecycle is bound to a single test method or class</strong>.</li>
<li><code>TestScope</code> (the actual scope implementation) integrates with Spring’s <code>ConfigurableBeanFactory</code> and JUnit 5 extension to:</li>
<li>Create beans lazily when a test starts.</li>
<li>Dispose of beans automatically at the end of the test.</li>
<li>Isolate mutable state between test methods to avoid cross‑test interference.</li>
</ul>
<p>You can expect definitions under something like:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/scope/TestScoped.kt"><code>src/main/kotlin/org/fit4j/scope/TestScoped.kt</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/scope/TestScope.kt"><code>src/main/kotlin/org/fit4j/scope/TestScope.kt</code></a></li>
</ul>
<p>(Consult the repository for exact file names.)</p>
<h3>When to Use</h3>
<p>Use these test scoping annotations when:</p>
<ul>
<li>A bean maintains <strong>per‑test state</strong> (e.g., tracking interactions only for the current test).</li>
<li>You want to avoid <strong>global singletons</strong> that leak state between tests.</li>
</ul>
<p>Example (illustrative):</p>
<pre><code class="language-kotlin">// Example location: src/test/kotlin/com/example/MyFitTest.kt:1-25
@TestConfiguration
class TestConfig {

    @Bean
    @TestScoped
    fun perTestTracker(): RequestTracker = RequestTracker()
}
</code></pre>
<p>In most setups:</p>
<ul>
<li>The FIT4J JUnit extension (<code>Fit4JTestExtension</code>) coordinates with <code>TestScope</code> so that:</li>
<li>A fresh <code>RequestTracker</code> is injected for each test method.</li>
<li>After the method completes, the tracker is cleared and removed from the scope.</li>
</ul>
<hr />
<h2>Putting It Together: Typical <code>@FIT</code> Test Structure</h2>
<p>The interaction between these annotations can be summarized as follows:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test class with @FIT"] --> step2["Fit4JTestExtension runs"]
 step2 --> step3["Load fixtures and config"]
 step3 --> step4["Start Spring Boot context"]
 step4 --> step5["Enable Kafka and trackers"]
 step5 --> step6["Execute test methods"]
</div></div>
<p><strong>Flow explanation:</strong></p>
<ol>
<li><strong>Test class with <code>@FIT</code></strong>:</li>
<li>JUnit 5 discovers a class annotated with <code>@FIT</code>.</li>
<li><strong><code>Fit4JTestExtension</code> runs</strong>:</li>
<li>Registered via <code>@ExtendWith(Fit4JTestExtension::class)</code> in <a href="https://github.com/harezmi/fit4j/blob/main/FIT.kt"><code>FIT.kt</code></a>.</li>
<li><strong>Load fixtures and config</strong>:</li>
<li>Reads <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> or the <code>fixtureFilePath</code> you set.</li>
<li>Applies <code>@TestPropertySource</code> from <code>@FIT</code> and any class/method‑level overrides.</li>
<li><strong>Start Spring Boot context</strong>:</li>
<li>Using configuration implied by <code>@IT</code> and <code>webEnvironment</code>.</li>
<li>Activates <code>test</code> profile and bean overriding.</li>
<li><strong>Enable Kafka and trackers</strong>:</li>
<li>If <code>@EnableEmbeddedKafka</code> is present, configures embedded Kafka.</li>
<li>Wires up beans like <code>KafkaMessageTracker</code>, <code>MockServiceCallTracker</code>, <code>VerificationHelper</code>.</li>
<li><strong>Execute test methods</strong>:</li>
<li>For each method:<ul>
<li>Apply <code>@FixtureForFIT</code> group(s).</li>
<li>Use test‑scoped beans for per‑test tracking.</li>
<li>Run your assertions against DB, HTTP endpoints, gRPC services, and Kafka messages.</li>
</ul>
</li>
</ol>
<hr />
<h2>Best Practices for Library Consumers</h2>
<h3>Choosing Between <code>@IT</code> and <code>@FIT</code></h3>
<ul>
<li>Use <code>@IT</code> when:</li>
<li>You have <strong>classic integration tests</strong> and just want FIT4J’s infra (gRPC in‑process, Testcontainers, etc.).</li>
<li>
<p>You do <strong>not</strong> need fixtures or FIT training/tracking helpers.</p>
</li>
<li>
<p>Use <code>@FIT</code> when:</p>
</li>
<li>You want <strong>full functional integration</strong> coverage (arrange via fixtures, act via HTTP/gRPC/message, assert on state and side effects).</li>
<li>You want to <strong>reuse fixtures across many tests</strong> efficiently.</li>
<li>You want built‑in <strong>call/message tracking</strong>.</li>
</ul>
<h3>Kafka and Embedded Brokers</h3>
<ul>
<li>Prefer <code>@EnableEmbeddedKafka</code> over raw <code>@EmbeddedKafka</code> where possible to:</li>
<li>Avoid manual <code>@DirtiesContext</code> usage.</li>
<li>
<p>Take advantage of FIT4J’s topic cleaner and consumer configuration via YAML.</p>
</li>
<li>
<p>Configure consumer behavior and cleaner using properties:</p>
</li>
<li><code>fit4j.kafka.consumers.file=classpath:consumers/my-test-consumers.yml</code></li>
<li><code>fit4j.kafka.topicCleaner.enabled=true</code></li>
<li><code>spring.kafka.consumer.auto-offset-reset=earliest</code></li>
</ul>
<h3>Fixtures</h3>
<ul>
<li>Keep <strong>fixture groups small and focused</strong>:</li>
<li>E.g., one group per business scenario (<code>order-created</code>, <code>order-cancelled</code>).</li>
<li>Use <code>@FixtureForFIT</code> to choose fixture groups per test method rather than creating many tiny classes.</li>
<li>Ensure fixture YAML is in your <strong>test classpath</strong>, and that <code>fixtureFilePath</code> is correct if customized.</li>
</ul>
<h3>Test Scope</h3>
<ul>
<li>When defining beans that should be isolated per test (e.g. in <code>@TestConfiguration</code> classes), annotate them with <code>@TestScoped</code> (or equivalent) instead of leaving them as singletons.</li>
<li>Avoid keeping per‑test state in static fields; use scoped beans or constructor injection into tests.</li>
</ul>
<hr />
<h2>References and Where to Look in the Code</h2>
<ul>
<li><code>@FIT</code> definition:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/FIT.kt#L1-L20"><code>src/main/kotlin/org/fit4j/annotation/FIT.kt:1-20</code></a></li>
<li>Sample <code>@FIT</code> tests:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/SampleFIT.kt#L1-L18"><code>src/test/kotlin/org/fit4j/sample/SampleFIT.kt:1-18</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt#L1-L21"><code>src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-21</code></a></li>
<li>Kafka‑related FIT tests:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt#L1-L20"><code>src/test/kotlin/org/fit4j/kafka/KafkaAutoConfigurationEnabledFIT.kt:1-20</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt#L1-L35"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageWithHeadersFIT.kt:1-35</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspect2FIT.kt#L1-L35"><code>src/test/kotlin/org/fit4j/kafka/KafkaMessageTrackerAspect2FIT.kt:1-35</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt#L1-L35"><code>src/test/kotlin/org/fit4j/kafka/KafkaTopicCleanerTestSuite.kt:1-35</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/kafka/KafkaConsumersYamlFileLoadFIT.kt#L1-L25"><code>src/test/kotlin/org/fit4j/kafka/KafkaConsumersYamlFileLoadFIT.kt:1-25</code></a></li>
<li>JUnit extension:</li>
<li><code>org.fit4j.context.Fit4JTestExtension</code> (source under <code>src/main/kotlin</code>).</li>
<li>Base annotation:</li>
<li><code>@IT</code> implementation (see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/annotation/IT.kt"><code>src/main/kotlin/org/fit4j/annotation/IT.kt</code></a> or similar).</li>
</ul>
<p>For term definitions such as “fixture”, “training”, “tracker”, “topic cleaner” and others, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-mocking-and-fixture-definition" class="dw-section">
  <div class="dw-section-inner">
    <h1>Mocking &amp; Declarative Fixture Definition</h1>
<p>This section explains how FIT4J’s declarative mocking works: how to define test fixtures in YAML, how those fixtures are turned into protocol‑specific mock responses, and how the generic <code>MockResponseProvider</code> abstraction fits into the flow. It is aimed at engineers who want to write tests that drive mocks purely from data (YAML/JSON) instead of imperative stubbing.</p>
<hr />
<h2>Overview</h2>
<p>Declarative fixtures let you describe mock behavior in external files (typically YAML) instead of embedding it in test code. The core pieces are:</p>
<ul>
<li><strong>Fixture definitions</strong>: YAML (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>, method‑level YAML) that describe requests, predicates, and responses.</li>
<li><strong>Declarative fixture provider</strong>: Loads fixtures for the “current test” and returns a <code>TestFixturesGroup</code>.</li>
<li><strong>Fixture builders</strong>: Convert raw YAML maps into protocol‑specific <code>TestFixture</code> objects (HTTP, gRPC, …).</li>
<li><strong>Expression and predicate evaluation</strong>: SpEL‑style expressions and predicates based on the current request and Spring beans.</li>
<li><strong>Json→response converters</strong>: Convert a raw JSON response template into a concrete protocol‑specific response.</li>
<li><strong>Fixture‑driven response provider</strong>: Bridges declarative fixtures into the generic <code>MockResponseFactory</code>.</li>
</ul>
<p>The overall flow is:</p>
<ol>
<li>A test is annotated with <code>@FIT</code> and optionally <code>@FixtureForFIT</code>.</li>
<li><code>DeclarativeTestFixtureProvider</code> loads the appropriate fixtures and builds a <code>TestFixturesGroup</code>.</li>
<li>When a mock response is requested, <code>DeclarativeTestFixtureDrivenServiceResponseProvider</code> asks the <code>TestFixturesGroup</code> to build a raw JSON response for the current request.</li>
<li>A <code>JsonToMockResponseConverter</code> converts that JSON into the concrete response type (HTTP, gRPC, …).</li>
<li>The result is returned as the mock response.</li>
</ol>
<hr />
<h2>Core Abstractions</h2>
<h3>DeclarativeTestFixtureProvider</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureProvider.kt"><code>src/main/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureProvider.kt</code></a></p>
<p><code>DeclarativeTestFixtureProvider</code> is responsible for loading and resolving fixtures for the currently executing test method.</p>
<p>Key responsibilities (see <a href="https://github.com/harezmi/fit4j/blob/main/DeclarativeTestFixtureProvider.kt"><code>DeclarativeTestFixtureProvider.kt</code></a> around class definition, e.g. <code>:15-40</code>):</p>
<ul>
<li>Reads fixture YAML (default resource: <code>classpath:fit4j-fixtures.yml</code>, passed via constructor).</li>
<li>Uses <code>ApplicationContext</code> to:</li>
<li>Discover all <code>DeclarativeTestFixtureBuilder</code> beans.</li>
<li>Resolve Spring beans referenced in expressions.</li>
<li>Uses <code>Fit4JTestContextManager</code> plus test annotations:</li>
<li><code>@FIT</code> on test classes to locate fixture files / namespaces.</li>
<li><code>@FixtureForFIT</code> on test methods to select a fixture group by name.</li>
<li>Builds and caches a <code>MutableMap&lt;String, TestFixturesGroup&gt;</code> of default fixtures, keyed by group name.</li>
<li>Exposes:</li>
</ul>
<p><code>kotlin
  fun getTestFixturesForCurrentTest(): TestFixturesGroup?</code></p>
<p>which returns the group applicable to the currently running test.</p>
<p>Usage examples:</p>
<ul>
<li>Class‑level setup from default file:</li>
</ul>
<p>```kotlin
  @FIT
  class DeclarativeTestFixtureDataProviderFIT {
      @Autowired
      lateinit var declarativeTestFixtureProvider: DeclarativeTestFixtureProvider</p>
<pre><code>  // ...
</code></pre>
<p>}
  ```</p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt#L1-L20"><code>src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDataProviderFIT.kt:1-20</code></a>.</p>
<ul>
<li>Method‑level fixture file and group:</li>
</ul>
<p>```kotlin
  @FIT("classpath:method-level-fixtures.yml")
  class MethodLevelDeclarativeTestFixtureProviderIntegrationTest {</p>
<pre><code>  @Test
  @FixtureForFIT("test-fixture-1")
  fun `should return a list of test fixtures`() {
      val group = declarativeTestFixtureProvider.getTestFixturesForCurrentTest()
      // ...
  }
</code></pre>
<p>}
  ```</p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt#L1-L24"><code>src/test/kotlin/org/fit4j/mock/declarative/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt:1-24</code></a>.</p>
<p>If a <code>@FixtureForFIT</code> name cannot be found in the configured YAML, <code>DeclarativeTestFixtureProvider</code> fails fast with <code>IllegalStateException</code> (see test <code>should throw IllegalStateException when fixture not found in yml</code> in <a href="https://github.com/harezmi/fit4j/blob/main/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt#L29-L37"><code>MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt:29-37</code></a>).</p>
<p>The provider also ensures fixture state isolation between tests. <code>TestFixtureGroupStateCleanupFIT</code> repeats tests to assert that group state is cleaned between test invocations (<a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt#L1-L25"><code>src/test/kotlin/org/fit4j/mock/declarative/TestFixtureGroupStateCleanupFIT.kt:1-25</code></a>).</p>
<hr />
<h3>DeclarativeTestFixtureBuilder</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureBuilder.kt#L1-L6"><code>src/main/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureBuilder.kt:1-6</code></a></p>
<pre><code class="language-kotlin">interface DeclarativeTestFixtureBuilder {
    fun protocol(): String
    fun build(requestMap: Map&lt;String, Any&gt;): TestFixture
}
</code></pre>
<p>A <code>DeclarativeTestFixtureBuilder</code>:</p>
<ul>
<li>Declares which protocol it supports via <code>protocol()</code> (for example <code>"http"</code>, <code>"grpc"</code>).</li>
<li>Converts a raw YAML map describing a fixture into a protocol‑specific <code>TestFixture</code> instance.</li>
</ul>
<p>Builders are discovered and injected into <code>DeclarativeTestFixtureProvider</code> via Spring configuration (see <code>TestHttpAutoConfiguration</code> and <code>TestGrpcAutoConfiguration</code> below). They centralize parsing of protocol‑specific fields such as:</p>
<ul>
<li>HTTP:</li>
<li><code>path</code></li>
<li><code>method</code></li>
<li>headers</li>
<li>gRPC:</li>
<li><code>type</code> (fully‑qualified message or service method)</li>
<li>protocol <code>grpc</code></li>
</ul>
<p>Example bean definition for HTTP (simplified):</p>
<pre><code class="language-kotlin">@Bean
fun httpTestFixtureBuilder(
    objectMapper: ObjectMapper,
    predicateEvaluator: PredicateEvaluator,
    expressionResolver: ExpressionResolver
): HttpTestFixtureBuilder {
    // ...
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt#L27-L40"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:27-40</code></a>.</p>
<hr />
<h3>TestFixture and TestFixturesGroup</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/TestFixturesGroup.kt#L1-L25"><code>src/main/kotlin/org/fit4j/mock/declarative/TestFixturesGroup.kt:1-25</code></a></p>
<p><code>TestFixturesGroup</code> is the runtime representation of fixtures applicable to one logical test group (typically one test method or class).</p>
<pre><code class="language-kotlin">data class TestFixturesGroup(
    val name: String,
    val primaryTestFixtures: List&lt;TestFixture&gt;
) {
    var globalTestFixtures: TestFixturesGroup? = null

    fun build(request: Any?): String? {
        return if (request is Message) this.build(request)
        else if (request is HttpRequest) this.build(request)
        else throw IllegalArgumentException(&quot;Unknown request type :$request&quot;)
    }

    // private fun build(request: Message): String? { ... }
    // private fun build(request: HttpRequest): String? { ... }
}
</code></pre>
<p>Responsibilities:</p>
<ul>
<li>Holds a list of protocol‑specific <code>TestFixture</code> instances (<code>primaryTestFixtures</code>).</li>
<li>Optionally links to another <code>TestFixturesGroup</code> containing “global” fixtures that are shared across tests (<code>globalTestFixtures</code>).</li>
<li>Given a runtime request (<code>Message</code> for gRPC or <code>HttpRequest</code> for HTTP), selects the first applicable fixture and builds its response as <strong>raw JSON string</strong>.</li>
</ul>
<p><code>build(request: Any?)</code> dispatches based on the concrete request type and defers to protocol‑specific <code>build</code> implementations:</p>
<ul>
<li>Proto messages: <code>private fun build(request: Message): String?</code></li>
<li>HTTP requests: <code>private fun build(request: HttpRequest): String?</code></li>
</ul>
<p>A <code>TestFixture</code> (HTTP or gRPC) encapsulates:</p>
<ul>
<li>Request matching logic (request path, method, and predicate).</li>
<li>A list or sequence of <code>Response</code> templates (often <code>*TestFixtureResponse</code>) that produce JSON bodies, headers, statuses, etc.</li>
</ul>
<p>Example usage in tests:</p>
<pre><code class="language-kotlin">MatcherAssert.assertThat(
    testFixturesGroup!!.primaryTestFixtures,
    Matchers.contains(
        HttpTestFixture(
            requestPath = &quot;/test-1&quot;,
            expressionResolver = expressionResolver,
            responses = listOf(HttpTestFixtureResponse(headers = &quot;{\n}&quot;))
        ),
        HttpTestFixture(
            requestPath = &quot;/test-2&quot;,
            expressionResolver = expressionResolver,
            responses = listOf(HttpTestFixtureResponse(headers = &quot;{\n}&quot;))
        )
    )
)
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt#L37-L54"><code>src/test/kotlin/org/fit4j/mock/declarative/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt:37-54</code></a>.</p>
<hr />
<h3>DeclarativeTestFixtureDrivenServiceResponseProvider</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDrivenServiceResponseProvider.kt#L1-L16"><code>src/main/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDrivenServiceResponseProvider.kt:1-16</code></a></p>
<p>This class is the bridge between <code>MockResponseFactory</code> and declarative fixtures:</p>
<pre><code class="language-kotlin">class DeclarativeTestFixtureDrivenServiceResponseProvider(
    private val jsonToMockResponseConverterList: List&lt;JsonToMockResponseConverter&gt;,
    private val declarativeTestFixtureProvider: DeclarativeTestFixtureProvider
) {

    fun getResponseFor(request: Any?): Any? {
        val testFixturesGroup = declarativeTestFixtureProvider.getTestFixturesForCurrentTest()
        if (testFixturesGroup != null) {
            val rawJsonContent = testFixturesGroup.build(request)
            if (rawJsonContent != null) {
                return jsonToMockResponseConverterList.first {
                    it.isApplicableFor(request)
                }.convert(rawJsonContent, request!!)
            }
        }
        return null
    }
}
</code></pre>
<p>Flow:</p>
<ol>
<li>Resolves the <code>TestFixturesGroup</code> for the current test.</li>
<li>Asks it to <code>build(request)</code>, resulting in <code>rawJsonContent</code> (JSON string) or null if no fixture matches.</li>
<li>Selects the first <code>JsonToMockResponseConverter</code> whose <code>isApplicableFor(request)</code> returns true for the current request type.</li>
<li>Calls <code>convert(rawJsonContent, request)</code> to produce the concrete response object (HTTP response, gRPC message, etc.).</li>
<li>Returns the response or <code>null</code> if no fixture/converter applies.</li>
</ol>
<p>This class is injected into <code>MockResponseFactory</code>:</p>
<pre><code class="language-kotlin">class MockResponseFactory(
    private val mockResponseProviderList: List&lt;MockResponseProvider&gt;,
    private val configurableEnvironment: ConfigurableEnvironment,
    private val declarativeTestFixtureDrivenServiceResponseProvider: DeclarativeTestFixtureDrivenServiceResponseProvider
) {
    // ...
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/MockResponseFactory.kt#L1-L12"><code>src/main/kotlin/org/fit4j/mock/MockResponseFactory.kt:1-12</code></a>.</p>
<p><code>MockResponseFactory</code> can decide, based on configuration, whether to delegate to declarative fixtures or to the legacy <code>MockResponseProvider</code> implementations. The method <code>isFixtureDrivenResponseGenerationEnabled()</code> (see same file around <code>:14-35</code>) typically reads environment properties to enable/disable fixture‑driven behavior.</p>
<hr />
<h3>JsonToMockResponseConverter and Protocol‑Specific Converters</h3>
<p><code>JsonToMockResponseConverter</code> is an abstraction for converters that transform a JSON template string into a protocol‑specific response. It is used by <code>DeclarativeTestFixtureDrivenServiceResponseProvider</code>.</p>
<p>There are protocol‑specific implementations:</p>
<ul>
<li><strong>HTTP</strong>: <code>JsonToHttpResponseConverter</code></li>
<li>Defined in <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/http/JsonToHttpResponseConverter.kt"><code>src/main/kotlin/org/fit4j/http/JsonToHttpResponseConverter.kt</code></a> (not shown in snippet).</li>
<li>
<p>Bean configuration:</p>
<p><code>kotlin
@Bean
fun rawJsonContentToHttpResponseConverter(
    jsonContentExpressionResolver: JsonContentExpressionResolver,
    objectMapper: ObjectMapper
): JsonToHttpResponseConverter {
    return JsonToHttpResponseConverter(jsonContentExpressionResolver, objectMapper)
}</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt#L16-L24"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:16-24</code></a>.</p>
</li>
<li>
<p><strong>gRPC</strong>: <code>JsonToGrpcResponseConverter</code></p>
</li>
<li>
<p>Configured similarly:</p>
<p><code>kotlin
@Bean
fun rawJsonContentToGrpcResponseConverter(
    jsonContentExpressionResolver: JsonContentExpressionResolver,
    grpcResponseBuilderRegistry: GrpcResponseBuilderRegistry,
    objectMapper: ObjectMapper
): JsonToGrpcResponseConverter {
    // ...
}</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L19-L28"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:19-28</code></a>.</p>
</li>
</ul>
<p>These converters:</p>
<ul>
<li>Understand how to build protocol objects (HTTP status + headers + body, or protobuf messages).</li>
<li>Use <code>JsonContentExpressionResolver</code> to evaluate embedded expressions inside the JSON body.</li>
<li>Use Jackson <code>ObjectMapper</code> for JSON parsing.</li>
</ul>
<p>The common interface provides methods such as:</p>
<ul>
<li><code>fun isApplicableFor(request: Any?): Boolean</code></li>
<li><code>fun convert(rawJson: String, request: Any): Any</code></li>
</ul>
<p>The <code>isApplicableFor</code> implementation typically checks the request type (<code>HttpRequest</code>, protobuf <code>Message</code>, etc.).</p>
<hr />
<h3>MockResponseProvider</h3>
<p><strong>Concept:</strong> <code>MockResponseProvider</code> is a simple interface for components that can provide a mock response for a given request type. It predates declarative fixtures and is still used for imperative mocking.</p>
<p>Typical shape (see <a href="https://github.com/harezmi/fit4j/blob/main/GrpcMockServiceResponseFactoryFIT.kt#L22-L43"><code>GrpcMockServiceResponseFactoryFIT.kt:22-43</code></a>):</p>
<pre><code class="language-kotlin">@Bean
fun stringValueResponseProvider1(): MockResponseProvider {
    return object : MockResponseProvider {
        override fun isApplicableFor(request: Any?): Boolean {
            return request is StringValue
        }

        override fun getResponseFor(request: Any?): Any? {
            return null
        }
    }
}
</code></pre>
<p><code>MockResponseFactory</code> orchestrates multiple <code>MockResponseProvider</code> instances along with <code>DeclarativeTestFixtureDrivenServiceResponseProvider</code>. A typical decision strategy is:</p>
<ol>
<li>If fixture‑driven generation is enabled and a declarative response is available, use it.</li>
<li>Otherwise, iterate through <code>mockResponseProviderList</code> and let the first applicable provider return a response.</li>
</ol>
<p>This means declarative fixtures can progressively replace ad‑hoc <code>MockResponseProvider</code> implementations without breaking existing tests.</p>
<hr />
<h2>Declarative Fixture File Structure</h2>
<h3>Global YAML Fixtures (<a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>)</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml"><code>src/test/resources/fit4j-fixtures.yml</code></a></p>
<p>The default fixture file (<code>classpath:fit4j-fixtures.yml</code>) defines groups keyed by <code>name</code>, each with a list of <code>fixtures</code>. Each fixture describes:</p>
<ul>
<li><code>request</code>:</li>
<li><code>protocol</code>: <code>"http"</code> or <code>"grpc"</code>.</li>
<li>Protocol‑specific fields like <code>path</code>, <code>method</code>, <code>type</code>, etc.</li>
<li>Optional <code>predicate</code> expression.</li>
<li><code>response</code>:</li>
<li>For HTTP: <code>status</code>, <code>headers</code>, <code>body</code>.</li>
<li>For gRPC: <code>body</code> or nested fields for builder.</li>
</ul>
<p>Example gRPC and HTTP entries (shortened):</p>
<pre><code class="language-yaml">- name: GrpcMockServiceResponseFactoryFIT
  fixtures:
    - request:
        protocol: grpc
        type: com.example.fit4j.grpc.TestGrpc$GetAgeRequest
        predicate: &quot;#request.name == 'Foo' &amp;&amp; #request.surname == 'Bar'&quot;
      response:
        body:
          age: 10

    - request:
        protocol: grpc
        type: com.example.fit4j.grpc.TestGrpc$GetFooByIdRequest
      response:
        body:
          foo:
            id: &quot;#{@testFixtureData.variables.fooId}&quot;

- name: HttpMockServiceResponseFactoryFIT
  fixtures:
    - request:
        protocol: http
        path: &quot;/test/foo/&quot;
      response:
        status: 401
        headers:
          Content-Type: &quot;application/json&quot;

    - request:
        protocol: http
        path: &quot;/foo/#{@testFixtureData.variables.fooId}&quot;
      response:
        status: 200

    - request:
        protocol: http
        path: &quot;/bar&quot;
        method: POST
        predicate: &quot;#request.body == 'withBody'&quot;
      response:
        status: 200
        body: ...
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L1-L40"><code>src/test/resources/fit4j-fixtures.yml:1-40</code></a> and <code>:40-85</code>.</p>
<p>Key points:</p>
<ul>
<li><code>name</code> must match the logical test context:</li>
<li>If a test class is named <code>GrpcMockServiceResponseFactoryFIT</code>, the group <code>name: GrpcMockServiceResponseFactoryFIT</code> will be used for tests in that class (unless overridden by method‑level fixtures).</li>
<li><code>protocol</code> triggers the appropriate <code>DeclarativeTestFixtureBuilder</code>.</li>
<li><code>type</code> is used by gRPC fixtures to bind to specific request message types.</li>
<li><code>path</code>, <code>method</code>, query parameters, etc., are used by HTTP fixtures for matching.</li>
<li><code>predicate</code> is a SpEL expression evaluated using <code>PredicateEvaluator</code> (see below).</li>
<li><code>response.body</code> can contain nested objects and SpEL expressions.</li>
</ul>
<h3>Method‑Level Fixtures</h3>
<p>Specific test classes can override or extend fixtures by specifying a different YAML file:</p>
<pre><code class="language-kotlin">@FIT(&quot;classpath:method-level-fixtures.yml&quot;)
class MethodLevelDeclarativeTestFixtureProviderIntegrationTest {
    @Test
    @FixtureForFIT(&quot;test-fixture-1&quot;)
    fun `should return a list of test fixtures`() { ... }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt#L1-L18"><code>src/test/kotlin/org/fit4j/mock/declarative/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt:1-18</code></a>.</p>
<p>In <a href="https://github.com/harezmi/fit4j/blob/main/method-level-fixtures.yml"><code>method-level-fixtures.yml</code></a>, each <code>name</code> corresponds directly to the <code>@FixtureForFIT</code> value (e.g. <code>test-fixture-1</code>). <code>DeclarativeTestFixtureProvider</code> loads from the file referenced by <code>@FIT</code> on the class rather than the default <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>.</p>
<p>If a <code>@FixtureForFIT</code> group name is missing, <code>DeclarativeTestFixtureProvider</code> throws <code>IllegalStateException</code>, enforced by test <code>should throw IllegalStateException when fixture not found in yml</code> (<a href="https://github.com/harezmi/fit4j/blob/main/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt#L29-L37"><code>MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt:29-37</code></a>).</p>
<hr />
<h2>Expression Resolution &amp; Predicate Evaluation</h2>
<h3>ExpressionResolver and JsonContentExpressionResolver</h3>
<p><strong>Files:</strong></p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/ExpressionResolver.kt"><code>src/main/kotlin/org/fit4j/mock/declarative/ExpressionResolver.kt</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/JsonContentExpressionResolver.kt"><code>src/main/kotlin/org/fit4j/mock/declarative/JsonContentExpressionResolver.kt</code></a></li>
<li>Autoconfiguration usage:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt#L1-L25"><code>src/main/kotlin/org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt:1-25</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt#L31-L40"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:31-40</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L19-L30"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:19-30</code></a></li>
</ul>
<p>Expressions are used in fixture definitions in two main places:</p>
<ol>
<li><strong>Predicates</strong> (boolean conditions for request matching).</li>
<li><strong>Response bodies</strong> (dynamic values from Spring beans or the request).</li>
</ol>
<p>Examples from <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a>:</p>
<ul>
<li>Predicate based on request body (<code>HttpMockServiceResponseFactoryFIT</code>):</li>
</ul>
<p><code>yaml
  predicate: "#request.body == 'withBody'"</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L70-L73"><code>src/test/resources/fit4j-fixtures.yml:70-73</code></a>.</p>
<ul>
<li>Response body referencing a bean (<code>GrpcMockServiceResponseFactoryFIT</code>):</li>
</ul>
<p><code>yaml
  foo:
    id: "#{@testFixtureData.variables.fooId}"</code></p>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L24-L27"><code>src/test/resources/fit4j-fixtures.yml:24-27</code></a>.</p>
<p><code>ExpressionResolver</code> wraps the evaluation of such SpEL expressions. It typically exposes methods for:</p>
<ul>
<li>Evaluating expressions in the context of:</li>
<li>The current <code>request</code> (bound as <code>#request</code>).</li>
<li>Spring beans (via <code>@beanName</code>).</li>
<li>Resolving expressions inside strings, for example <code>"/foo/#{@testFixtureData.variables.fooId}"</code>.</li>
</ul>
<p><code>JsonContentExpressionResolver</code> specializes in walking a JSON structure and resolving any embedded expressions inside values, returning a pure JSON template ready for parsing.</p>
<h3>PredicateEvaluator</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/declarative/PredicateEvaluator.kt"><code>src/main/kotlin/org/fit4j/mock/declarative/PredicateEvaluator.kt</code></a> (not shown in snippet)<br />
Usage in configuration: <a href="https://github.com/harezmi/fit4j/blob/main/TestHttpAutoConfiguration.kt#L31-L38"><code>TestHttpAutoConfiguration.kt:31-38</code></a>.</p>
<p><code>PredicateEvaluator</code> is used by <code>DeclarativeTestFixtureBuilder</code> implementations to decide if a fixture matches a given request:</p>
<ul>
<li>Reads the <code>predicate</code> string from YAML (e.g. <code>"#request.name == 'Foo'"</code>).</li>
<li>Evaluates it using the same expression infrastructure as <code>ExpressionResolver</code>.</li>
<li>Returns a <code>Boolean</code> result.</li>
</ul>
<p>Fixture matching generally works as:</p>
<ol>
<li>The builder creates a <code>TestFixture</code> with:</li>
<li>Static fields used for coarse matching (e.g., path, method, type).</li>
<li>An optional <code>predicate</code> function compiled from the YAML predicate string.</li>
<li>At runtime <code>TestFixture.isApplicableFor(request)</code>:</li>
<li>Checks static fields.</li>
<li>If matching, evaluates the predicate (if any) via <code>PredicateEvaluator</code>.</li>
</ol>
<hr />
<h2>How Autoconfiguration Wires Everything</h2>
<h3>TestFixtureAutoConfiguration</h3>
<p><strong>File:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt#L1-L35"><code>src/main/kotlin/org/fit4j/autoconfigure/TestFixtureAutoConfiguration.kt:1-35</code></a></p>
<p>This auto‑configuration enables declarative fixture support when running FIT4J tests (annotated with <code>@EnableOnFIT</code>):</p>
<pre><code class="language-kotlin">@AutoConfiguration
@EnableOnFIT
class TestFixtureAutoConfiguration {

    @Bean
    fun declarativeTestFixtureServiceResponseProvider(
        declarativeTestFixtureProvider: DeclarativeTestFixtureProvider,
        jsonToMockResponseConverterList: List&lt;JsonToMockResponseConverter&gt;
    ): DeclarativeTestFixtureDrivenServiceResponseProvider {
        return DeclarativeTestFixtureDrivenServiceResponseProvider(
            jsonToMockResponseConverterList,
            declarativeTestFixtureProvider
        )
    }

    @Bean
    fun declarativeTestFixtureProvider(
        applicationContext: ApplicationContext,
        declarativeTestFixtureBuilders: List&lt;DeclarativeTestFixtureBuilder&gt;
    ): DeclarativeTestFixtureProvider {
        return DeclarativeTestFixtureProvider(applicationContext, declarativeTestFixtureBuilders)
    }

    // Beans for ExpressionResolver, JsonContentExpressionResolver, PredicateEvaluator, etc.
}
</code></pre>
<p>Key points:</p>
<ul>
<li>The provider and response provider are registered only in FIT tests (controlled by <code>@EnableOnFIT</code>).</li>
<li>The constructor for <code>DeclarativeTestFixtureProvider</code> may accept a different <code>resourcePath</code> when needed (e.g., method‑level file via <code>@FIT("classpath:...")</code>).</li>
</ul>
<h3>HTTP and gRPC AutoConfiguration</h3>
<p><strong>HTTP:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt#L1-L45"><code>src/main/kotlin/org/fit4j/autoconfigure/TestHttpAutoConfiguration.kt:1-45</code></a></p>
<p>Relevant beans:</p>
<ul>
<li><code>DefaultHttpMockResponseProvider</code> wired with:</li>
<li><code>DeclarativeTestFixtureProvider</code></li>
<li><code>JsonToHttpResponseConverter</code></li>
<li>
<p><code>HttpTestFixtureBuilder</code> implementations</p>
</li>
<li>
<p><code>JsonToHttpResponseConverter</code> bean:</p>
</li>
</ul>
<p><code>kotlin
  @Bean
  fun rawJsonContentToHttpResponseConverter(
      jsonContentExpressionResolver: JsonContentExpressionResolver,
      objectMapper: ObjectMapper
  ): JsonToHttpResponseConverter {
      return JsonToHttpResponseConverter(jsonContentExpressionResolver, objectMapper)
  }</code></p>
<ul>
<li><code>HttpTestFixtureBuilder</code> bean:</li>
</ul>
<p><code>kotlin
  @Bean
  fun httpTestFixtureBuilder(
      objectMapper: ObjectMapper,
      predicateEvaluator: PredicateEvaluator,
      expressionResolver: ExpressionResolver
  ): HttpTestFixtureBuilder { ... }</code></p>
<p><strong>gRPC:</strong> <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L1-L40"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:1-40</code></a></p>
<p>Relevant beans:</p>
<ul>
<li><code>DefaultGrpcMockResponseProvider</code> using:</li>
<li><code>DeclarativeTestFixtureProvider</code></li>
<li><code>JsonToGrpcResponseConverter</code></li>
<li>
<p><code>GrpcResponseJsonBuilder</code> list</p>
</li>
<li>
<p><code>GrpcResponseBuilderRegistry</code>:</p>
</li>
</ul>
<p><code>kotlin
  @Bean
  fun grpcResponseBuilderRegistry(
      testGrpcServiceDefinitionProvider: TestGrpcServiceDefinitionProvider
  ): GrpcResponseBuilderRegistry {
      return GrpcResponseBuilderRegistry(testGrpcServiceDefinitionProvider)
  }</code></p>
<ul>
<li><code>JsonToGrpcResponseConverter</code> bean using <code>JsonContentExpressionResolver</code> and <code>GrpcResponseBuilderRegistry</code>.</li>
</ul>
<hr />
<h2>End‑to‑End Runtime Flow (Fixture‑Driven)</h2>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Test invokes client"] --> step2["MockResponseFactory invoked"]
 step2 --> step3["FixtureDrivenResponseProvider"]
 step3 --> step4["TestFixturesGroup.build"]
 step4 --> step5["JsonToMockResponseConverter"]
 step5 --> step6["Return protocol response"]
</div></div>
<p>Detailed steps:</p>
<ol>
<li>A test invokes an HTTP or gRPC client (e.g. <code>TestRestTemplate</code> or gRPC stub).</li>
<li>FIT4J’s mock server or gRPC interceptor delegates to <code>MockResponseFactory.getResponseFor(request)</code> (implementation not shown, see <a href="https://github.com/harezmi/fit4j/blob/main/MockResponseFactory.kt#L1-L40"><code>MockResponseFactory.kt:1-40</code></a>).</li>
<li><code>MockResponseFactory</code> checks if fixture‑driven generation is enabled (via environment configuration) and calls:</li>
</ol>
<p><code>kotlin
   declarativeTestFixtureDrivenServiceResponseProvider.getResponseFor(request)</code></p>
<ol>
<li><code>DeclarativeTestFixtureDrivenServiceResponseProvider</code>:</li>
<li>Calls <code>declarativeTestFixtureProvider.getTestFixturesForCurrentTest()</code>.</li>
<li>Calls <code>TestFixturesGroup.build(request)</code> to get a raw JSON response string.</li>
<li>A suitable <code>JsonToMockResponseConverter</code> is found and used to convert JSON into the protocol‑specific response object.</li>
<li>The final response is returned to the client and observed by the test.</li>
</ol>
<hr />
<h2>Practical Usage Patterns</h2>
<h3>1. Injecting Test Fixture Data into Responses</h3>
<p>You can define Spring beans that hold test‑specific variables and reference them from fixtures.</p>
<p>Example from <code>GrpcMockServiceResponseFactoryFIT</code>:</p>
<pre><code class="language-kotlin">@FIT
class GrpcMockServiceResponseFactoryFIT {

    @Autowired
    private lateinit var mockResponseFactory: MockResponseFactory

    data class TestFixtureData(val variables: Variables)
    data class Variables(val fooId: Int)

    @TestConfiguration
    class TestConfig {
        @Bean
        fun testFixtureData(): TestFixtureData {
            return TestFixtureData(Variables(123))
        }
    }
}
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/grpc/GrpcMockServiceResponseFactoryFIT.kt#L1-L32"><code>src/test/kotlin/org/fit4j/grpc/GrpcMockServiceResponseFactoryFIT.kt:1-32</code></a>.</p>
<p>Corresponding fixture:</p>
<pre><code class="language-yaml">- name: GrpcMockServiceResponseFactoryFIT
  fixtures:
    - request:
        protocol: grpc
        type: com.example.fit4j.grpc.TestGrpc$GetFooByIdRequest
      response:
        body:
          foo:
            id: &quot;#{@testFixtureData.variables.fooId}&quot;
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L18-L27"><code>src/test/resources/fit4j-fixtures.yml:18-27</code></a>.</p>
<p>At runtime:</p>
<ul>
<li><code>ExpressionResolver</code> resolves <code>@testFixtureData</code> from <code>ApplicationContext</code>.</li>
<li><code>JsonContentExpressionResolver</code> replaces <code>#{@testFixtureData.variables.fooId}</code> with <code>123</code> in the JSON.</li>
<li><code>JsonToGrpcResponseConverter</code> builds a protobuf response message with <code>foo.id = 123</code>.</li>
</ul>
<h3>2. Matching on Request Content</h3>
<p>You can use predicates that inspect request fields or body.</p>
<p>gRPC predicate:</p>
<pre><code class="language-yaml">predicate: &quot;#request.name == 'Foo' &amp;&amp; #request.surname == 'Bar'&quot;
</code></pre>
<p>HTTP predicate based on body:</p>
<pre><code class="language-yaml">- request:
    protocol: http
    path: &quot;/bar&quot;
    method: POST
    predicate: &quot;#request.body == 'withBody'&quot;
  response:
    status: 200
    body: ...
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/src/test/resources/fit4j-fixtures.yml#L60-L73"><code>src/test/resources/fit4j-fixtures.yml:60-73</code></a>.</p>
<p>Depending on the protocol:</p>
<ul>
<li>For gRPC, <code>#request</code> is the protobuf message.</li>
<li>For HTTP, <code>#request</code> is a wrapper such as <code>org.fit4j.http.HttpRequest</code>, with properties like <code>path</code>, <code>method</code>, <code>body</code>, and <code>headers</code>.</li>
</ul>
<hr />
<h2>Configuration Notes</h2>
<h3>Enabling Fixture‑Driven Responses</h3>
<p><code>MockResponseFactory.isFixtureDrivenResponseGenerationEnabled()</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/MockResponseFactory.kt#L14-L35"><code>src/main/kotlin/org/fit4j/mock/MockResponseFactory.kt:14-35</code></a>) likely checks a Spring environment property, for example:</p>
<pre><code class="language-properties">fit4j.fixture-driven.enabled=true
</code></pre>
<p>When disabled:</p>
<ul>
<li><code>MockResponseFactory</code> will skip <code>DeclarativeTestFixtureDrivenServiceResponseProvider</code> and rely solely on <code>MockResponseProvider</code> instances.</li>
</ul>
<p>When enabled:</p>
<ul>
<li>Declarative fixtures override or complement imperative mocks depending on the factory’s strategy.</li>
</ul>
<h3>Test Annotations</h3>
<ul>
<li><code>@FIT</code> on a test class:</li>
<li>Without argument: uses default fixture file <code>classpath:fit4j-fixtures.yml</code>.</li>
<li>With argument: overrides fixture file, e.g. <code>@FIT("classpath:declarative-response-generation-fixture.yml")</code>.</li>
</ul>
<p>Example: <code>DeclarativeTestFixtureDrivenResponseGenerationFIT</code> in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDrivenResponseGenerationFIT.kt#L1-L20"><code>src/test/kotlin/org/fit4j/mock/declarative/DeclarativeTestFixtureDrivenResponseGenerationFIT.kt:1-20</code></a>.</p>
<ul>
<li><code>@FixtureForFIT("group-name")</code> on a test method:</li>
<li>Selects a particular <code>TestFixturesGroup</code> within the configured fixture file.</li>
</ul>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt#L12-L18"><code>MethodLevelDeclarativeTestFixtureProviderIntegrationTest.kt:12-18</code></a>.</p>
<hr />
<h2>When to Use Declarative Fixtures vs MockResponseProvider</h2>
<p>Use <strong>declarative fixtures</strong> when:</p>
<ul>
<li>You want to describe many scenarios as data rather than code.</li>
<li>Response structures are complex or repetitive.</li>
<li>Test dependencies (like IDs, correlation keys) can be expressed via expressions.</li>
</ul>
<p>Use <strong>MockResponseProvider</strong> when:</p>
<ul>
<li>You need logic that cannot be expressed via a predicate or SpEL.</li>
<li>The response type is highly dynamic or depends on external systems (still mocked).</li>
</ul>
<p>Because <code>MockResponseFactory</code> supports both, you can:</p>
<ul>
<li>Start with existing <code>MockResponseProvider</code>‑based tests.</li>
<li>Gradually add declarative fixtures for new tests.</li>
<li>Move legacy mocks into fixtures as you refactor.</li>
</ul>
<hr />
<p>For definitions of common terms such as <em>TestFixture</em>, <em>MockResponseProvider</em>, and <em>HttpRequest</em>, see the [Glossary] section.</p>
  </div>
</section>


<section id="section-testing-strategy-and-quality" class="dw-section">
  <div class="dw-section-inner">
    <h1>Testing Strategy &amp; Quality Gates</h1>
<p>This page describes how this repository approaches testing: which test types exist, how the custom <code>@FIT</code> / <code>@IT</code> annotations are used, how Spring context caching is verified, how database test support is exercised, and what is expected from contributors in terms of coverage and quality gates. It focuses on the repository’s <em>own</em> tests (both library and examples) rather than how you should test your own services with FIT4J (for that, see the main README).</p>
<hr />
<h2>Test Types in This Repository</h2>
<h3>Unit Tests</h3>
<p>Unit tests are standard JUnit 5 tests that:</p>
<ul>
<li>Do <strong>not</strong> use <code>@FIT</code> or <code>@IT</code>.</li>
<li>Usually avoid starting a full Spring context.</li>
<li>Focus on individual classes, helpers, or pure Kotlin/Java logic.</li>
</ul>
<p>They follow the usual <strong>Arrange–Act–Assert</strong> structure described in <code>README.md:...</code>:</p>
<ul>
<li><strong>Arrange</strong> – set up inputs, mocks, and state.</li>
<li><strong>Act</strong> – call the method under test.</li>
<li><strong>Assert</strong> – verify outputs, state, and interactions.</li>
</ul>
<p>In this repository, these are mainly used for:</p>
<ul>
<li>Helper utilities (e.g., JSON helpers, small internal utilities).</li>
<li>Pure logic in the core library where Spring is not needed.</li>
</ul>
<p>When adding new code to the library that is not Spring-based, prefer <strong>unit tests</strong> as the first line of defense, and only fall back to FIT/IT when Spring integration is essential.</p>
<blockquote>
<p>See <code>README.md:...</code> for the general explanation of the Arrange–Act–Assert pattern used across all tests.</p>
</blockquote>
<hr />
<h3>Integration Tests (<code>@IT</code>)</h3>
<p>FIT4J defines an <code>@IT</code> annotation (documented in <code>README.md:...</code>) used as an enhanced integration-test stereotype:</p>
<ul>
<li>It effectively behaves like <code>@SpringBootTest</code> with additional infrastructure.</li>
<li>It activates the <code>test</code> profile and allows bean overriding.</li>
<li>It is intended for “ordinary” integration tests that verify interactions between components (e.g., controller–service, service–repository).</li>
</ul>
<p>From <code>README.md:...</code>:</p>
<pre><code class="language-kotlin">import org.fit4j.IntegrationTest
import org.junit.jupiter.api.Test

@IT
class SampleIntegrationTest {
    @Test
    fun `it should work`() {
        // ...
    }
}
</code></pre>
<p>Key points:</p>
<ul>
<li>Compared to <code>@FIT</code>, <code>@IT</code> is <strong>lighter</strong>: it does not bring the full FIT features like fixture management, request/response training, or message tracking.</li>
<li>It is appropriate when you just need Spring wiring and environment but not FIT’s extended testing DSL.</li>
</ul>
<p><strong>When to use in this repository</strong></p>
<ul>
<li>For tests inside this repo that need the Spring container but do not require FIT’s fixture / tracking features.</li>
<li>For verifying the underlying infrastructure that <code>@FIT</code> builds upon.</li>
</ul>
<p>For a feature level comparison between <code>@IT</code> and <code>@FIT</code>, see the table in <code>README.md:...</code>.</p>
<hr />
<h3>FIT Tests (<code>@FIT</code>)</h3>
<p><code>@FIT</code> is the core test stereotype for this library and for the examples. It builds on top of Spring Boot’s test facilities and adds FIT4J’s own capabilities. As stated in <code>README.md:...</code>:</p>
<ul>
<li><code>@FIT</code> test classes are essentially <code>@SpringBootTest</code> classes.</li>
<li>They automatically activate the <code>test</code> profile and enable bean definition override.</li>
<li>They additionally support FIT-specific features (fixtures, request-response training, async tracking, etc.).</li>
</ul>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt#L1-L18"><code>fit4j-examples/example-basic/src/test/kotlin/org/fit4j/examples/basic/SampleFIT.kt:1-18</code></a>:</p>
<pre><code class="language-kotlin">@FIT
class SampleFIT {

    @Autowired
    private lateinit var helper: JsonHelper

    @Test
    fun `example test`() {
        Assertions.assertNotNull(helper)
    }

    @Test
    fun `another example test`() {
        Assertions.assertNotNull(helper)
    }
}
</code></pre>
<p>More advanced usage with additional Spring test annotations appears in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt#L1-L22"><code>src/test/kotlin/org/fit4j/sample/YetAnotherSampleFIT.kt:1-22</code></a>:</p>
<pre><code class="language-kotlin">@FIT
@EmbeddedKafka(partitions = 1)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class YetAnotherSampleFIT {

    @Autowired
    private lateinit var  mockServiceCallTracker: MockServiceCallTracker

    @Test
    fun `test something`() {
        // Given
        // When
        // Then
        Assertions.assertNotNull(mockServiceCallTracker)
    }
}
</code></pre>
<p>And an example with H2 database usage appears in <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-examples/example-h2/src/test/kotlin/org/fit4j/examples/h2/H2ExampleFIT.kt#L1-L23"><code>fit4j-examples/example-h2/src/test/kotlin/org/fit4j/examples/h2/H2ExampleFIT.kt:1-23</code></a>.</p>
<h4>Optional Parameters of <code>@FIT</code></h4>
<p>As documented in <code>README.md:...</code>, <code>@FIT</code> accepts two optional parameters:</p>
<ul>
<li><code>fixtureFilePath</code>: path to a custom YAML fixture file (default: <a href="https://github.com/harezmi/fit4j/blob/main/fit4j-fixtures.yml"><code>fit4j-fixtures.yml</code></a> from classpath).</li>
<li><code>webEnvironment</code>: Spring Boot web environment (default: <code>SpringBootTest.WebEnvironment.RANDOM_PORT</code>).</li>
</ul>
<p>These parameters control:</p>
<ul>
<li>Which fixture YAML file will be loaded and <em>cached</em> across FIT tests.</li>
<li>Whether the test starts a web server (and how).</li>
</ul>
<blockquote>
<p>Consequence for testing strategy: when you rely heavily on declarative fixtures, your tests depend on the correct caching behavior and fixture loading logic, which this repository validates explicitly (see next sections).</p>
</blockquote>
<hr />
<h2>Context Caching Strategy &amp; Tests</h2>
<h3>Why Context Caching Matters</h3>
<p>Spring’s <code>ApplicationContext</code> caching is a key performance and correctness feature:</p>
<ul>
<li>Creating the context is expensive; caching reduces total test time.</li>
<li>For FIT4J, the cached context is also where fixtures and other shared test infrastructure live.</li>
<li>Incorrect caching (too many contexts) slows tests; incorrect reuse (using a dirty context) can lead to flaky tests.</li>
</ul>
<p>The repository includes dedicated test suites to <strong>verify</strong> that context caching behaves as intended for both FIT and non-FIT tests.</p>
<h3>Context Caching for FIT Tests</h3>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt#L1-L55"><code>src/test/kotlin/org/fit4j/context/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt:1-55</code></a> shows how we assert that all nested <code>@FIT</code> inner classes share the same <code>ApplicationContext</code> instance:</p>
<pre><code class="language-kotlin">@TestClassOrder(ClassOrderer.OrderAnnotation::class)
class ContextCachingForFitTestsShouldBeWorkingTestSuite {
    @Nested
    @Order(1)
    @FIT
    inner class FirstFIT {
        @Autowired
        private lateinit var applicationContext: ApplicationContext

        @Test
        fun `initialize static application context`() {
            Assertions.assertNull(applicationContextStatic)
            applicationContextStatic = applicationContext
        }
    }

    @Nested
    @Order(2)
    @FIT
    inner class SecondFIT {
        @Autowired
        private lateinit var applicationContext: ApplicationContext

        @Test
        fun `check if application contexts are the same`() {
            Assertions.assertNotNull(applicationContextStatic)
            Assertions.assertSame(applicationContextStatic, applicationContext)
        }
    }

    @Nested
    @Order(3)
    @FIT
    // ...
}
</code></pre>
<p>Key strategy:</p>
<ul>
<li>Tests use a static <code>applicationContextStatic</code> variable (declared elsewhere in the file) to store the first context.</li>
<li>Subsequent nested classes verify that the same instance is reused (<code>assertSame</code>).</li>
<li><code>@TestClassOrder(ClassOrderer.OrderAnnotation::class)</code> and <code>@Order</code> ensure deterministic ordering of nested FIT tests.</li>
</ul>
<p>This suite acts as <strong>executable documentation</strong> of the expectation that <strong>FIT tests share the same cached context</strong> within the scope of compatible configuration.</p>
<h3>Context Caching for Non-FIT Tests</h3>
<p>The equivalent verification for non-FIT (plain <code>@SpringBootTest</code>) suites is in <a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/context/ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt#L1-L46"><code>src/test/kotlin/org/fit4j/context/ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt:1-46</code></a>:</p>
<pre><code class="language-kotlin">@TestClassOrder(ClassOrderer.OrderAnnotation::class)
class ContextCachingForNonFitTestsShouldBeWorkingTestSuite {
    @Nested
    @Order(1)
    @SpringBootTest
    @ActiveProfiles(&quot;test&quot;)
    inner class FirstFIT {
        @Autowired
        private lateinit var applicationContext: ApplicationContext

        @Test
        fun `initialize static application context`() {
            Assertions.assertNull(applicationContextStatic)
            applicationContextStatic = applicationContext
        }
    }

    @Nested
    @Order(2)
    @SpringBootTest
    @ActiveProfiles(&quot;test&quot;)
    inner class SecondFIT {

        @Autowired
        private lateinit var applicationContext: ApplicationContext

        @AfterEach
        fun `reset static context`() {
            applicationContextStatic = null
        }

        @Test
        fun `check something`() {
            // ...
        }
    }
}
</code></pre>
<p>Here we assert that:</p>
<ul>
<li>Multiple <code>@SpringBootTest</code>-annotated inner classes with the same configuration share the same context.</li>
<li>The <code>test</code> profile is consistently active.</li>
<li>Static context is managed explicitly to avoid cross-test pollution.</li>
</ul>
<p><strong>Takeaway for contributors</strong></p>
<ul>
<li>When adding new suites aimed at testing FIT4J’s interaction with Spring, follow this pattern to assert or rely on context caching.</li>
<li>Use <code>@TestClassOrder</code> and <code>@Order</code> when verifying cross-class behaviors.</li>
</ul>
<hr />
<h2>Database Test Support &amp; Quality Gates</h2>
<h3>DatabaseTestSupport Checking Suites</h3>
<p>FIT4J ships with <code>DatabaseTestSupport</code> implementations (e.g., for H2, MySQL, PostgreSQL) that ensure database state is handled correctly across FIT/IT tests. This repository includes dedicated suites that <em>verify</em> these components with real databases (often via Testcontainers).</p>
<h4>Generic Database Support Suite</h4>
<p><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportCheckingTestSuite.kt#L1-L60"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportCheckingTestSuite.kt:1-60</code></a> demonstrates a FIT-based verification of database support:</p>
<pre><code class="language-kotlin">@TestClassOrder(ClassOrderer.OrderAnnotation::class)
class DatabaseTestSupportCheckingTestSuite {
    @Nested
    @Order(1)
    @FIT
    inner class FirstFIT {

        @Autowired
        private lateinit var jdbcTemplate: JdbcTemplate

        @Test
        fun `populate db`() {
            // table with PK:id as identity
            jdbcTemplate.execute(&quot;&quot;&quot;
                CREATE TABLE my_foo (
                    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                    name VARCHAR(255)
                );
            &quot;&quot;&quot;.trimIndent())
            jdbcTemplate.update(&quot;insert into my_foo(name) values ('Foo')&quot;)
            jdbcTemplate.update(&quot;insert into my_foo(name) values ('Bar')&quot;)
        }
    }
}
</code></pre>
<p>This suite:</p>
<ul>
<li>Starts a FIT context, including the database and database cleanup support.</li>
<li>Creates a demo table and populates it.</li>
<li>Is typically followed (in the same file) by additional nested tests that verify cleanup behavior, fixture-based population, etc.</li>
</ul>
<h4>MySQL- and PostgreSQL-Specific Suites</h4>
<p>Similarly, there are suites to verify concrete implementations:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt#L1-L40"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForMySQLCheckingTestSuite.kt:1-40</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt#L1-L40"><code>src/test/kotlin/org/fit4j/helper/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt:1-40</code></a></li>
</ul>
<p>Both bring in:</p>
<ul>
<li><code>DatabaseTestSupportForMysql</code> or <code>DatabaseTestSupportForPostgreSQL</code>.</li>
<li><code>Testcontainers</code> from <code>org.fit4j.testcontainers.Testcontainers</code>.</li>
</ul>
<p>These suites ensure:</p>
<ul>
<li>The right Testcontainers images are spun up and integrated.</li>
<li><code>DatabaseTestSupport</code> correctly cleans and resets the database between tests.</li>
<li>FIT features work consistently across DB engines.</li>
</ul>
<p><strong>Expectation / Quality Gate</strong></p>
<ul>
<li>Changes to <code>DatabaseTestSupport</code> implementations or its configuration should <strong>not</strong> break these suites.</li>
<li>If you introduce new DB-specific features, extend these suites with explicit test cases rather than silently relying on existing behavior.</li>
</ul>
<blockquote>
<p>For underlying DB support implementation details, see the dedicated architecture / data sections of the documentation.</p>
</blockquote>
<hr />
<h2>FIT &amp; IT Features as Executable Documentation</h2>
<p>The tests in this repository are intentionally written to <strong>double as documentation</strong> of expected behavior:</p>
<ul>
<li><code>SampleFIT</code> and <code>YetAnotherSampleFIT</code> show the minimal and advanced patterns of using <code>@FIT</code>.</li>
<li>H2, MySQL, and PostgreSQL example FIT tests demonstrate DB integration and how fixtures / SQL are expected to behave.</li>
<li>Context caching suites demonstrate how Spring contexts are reused for FIT and IT tests.</li>
<li>Tests using features like <code>@EmbeddedKafka</code> and <code>MockServiceCallTracker</code> document the availability of message tracking and embedded broker support for FIT tests.</li>
</ul>
<p>When contributing:</p>
<ul>
<li>Treat tests as <strong>executable examples</strong>.</li>
<li>Prefer clear test names (<code>it should ...</code>) and keep them aligned with the feature description in README.</li>
<li>For new features, add <em>at least one</em> FIT or IT test in <code>src/test/kotlin</code> or in <code>fit4j-examples/**</code> that illustrates the feature in isolation.</li>
</ul>
<hr />
<h2>Parallelism &amp; Test Execution Constraints</h2>
<p>The repository explicitly documents a critical limitation in <code>README.md:...</code>:</p>
<blockquote>
<p><strong>Parallel Test Execution Not Supported:</strong><br />
Currently, FIT4J does not support parallel test execution. All tests annotated with <code>@FIT</code> or <code>@IT</code> must be executed sequentially. This limitation is due to the use of shared static state for managing test context.</p>
</blockquote>
<p><strong>Build configuration requirement (quality gate):</strong></p>
<ul>
<li><strong>Gradle</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/build.gradle.kts"><code>build.gradle.kts</code></a>):</li>
</ul>
<p><code>kotlin
  tasks.test {
      maxParallelForks = 1
  }</code></p>
<ul>
<li><strong>Maven</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/pom.xml"><code>pom.xml</code></a>):</li>
</ul>
<p><code>xml
  &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
      &lt;configuration&gt;
          &lt;forkCount&gt;1&lt;/forkCount&gt;
          &lt;reuseForks&gt;true&lt;/reuseForks&gt;
      &lt;/configuration&gt;
  &lt;/plugin&gt;</code></p>
<p>(Exact config may vary; ensure parallel forks are effectively <code>1</code> for the FIT/IT test phase.)</p>
<p><strong>Implications for your tests:</strong></p>
<ul>
<li>Do not rely on tests being isolated at the JVM/process level; instead, use FIT4J’s database support and fixture mechanisms to ensure deterministic state.</li>
<li>Avoid introducing static mutable state in tests unless it is explicitly part of a test verifying context caching (as in the caching suites).</li>
</ul>
<hr />
<h2>Using Test Configuration as Part of Arrange Phase</h2>
<p>A frequent pattern encouraged in the README (<code>README.md:...</code>) is to use an inner <code>@TestConfiguration</code> class inside a <code>@FIT</code> test, treating it as part of the <em>Arrange</em> phase:</p>
<pre><code class="language-kotlin">@FIT
class SampleFIT {

    @TestConfiguration
    class TestConfig {
        // additional beans / mocks for tests
    }

    @Test
    fun `test something`() {
        // Arrange/Act/Assert...
    }
}
</code></pre>
<p>This mechanism:</p>
<ul>
<li>Allows you to override or add beans specifically for a test suite.</li>
<li>Works well with context caching, because Spring merges this configuration into the cached context.</li>
</ul>
<p><strong>Quality expectation:</strong></p>
<ul>
<li>When test-specific beans or mocks are required, prefer <code>@TestConfiguration</code> in FIT/IT tests rather than ad-hoc static singletons or custom wiring.</li>
<li>Keep test configuration <em>minimal</em> so that shared context caching remains effective and side effects are clear.</li>
</ul>
<hr />
<h2>Coverage Expectations &amp; Quality Gates</h2>
<p>While no explicit numeric threshold is visible in the snippets, the structure of this repository suggests the following expectations:</p>
<ol>
<li><strong>All public, user-facing features of FIT4J must have at least one FIT or IT test.</strong></li>
<li>
<p>New annotations, configuration knobs, or helper types should be covered by targeted tests under <code>src/test/kotlin/org/fit4j/**</code> or under <code>fit4j-examples/**</code>.</p>
</li>
<li>
<p><strong>Critical infrastructure features must be verified end-to-end:</strong></p>
</li>
<li>Context caching (<a href="https://github.com/harezmi/fit4j/blob/main/ContextCachingForFitTestsShouldBeWorkingTestSuite.kt"><code>ContextCachingForFitTestsShouldBeWorkingTestSuite.kt</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt"><code>ContextCachingForNonFitTestsShouldBeWorkingTestSuite.kt</code></a>).</li>
<li>Database support (<a href="https://github.com/harezmi/fit4j/blob/main/DatabaseTestSupportCheckingTestSuite.kt"><code>DatabaseTestSupportCheckingTestSuite.kt</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/DatabaseTestSupportForMySQLCheckingTestSuite.kt"><code>DatabaseTestSupportForMySQLCheckingTestSuite.kt</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt"><code>DatabaseTestSupportForPostgreSQLCheckingTestSuite.kt</code></a>).</li>
<li>
<p>Messaging / async tracking (e.g., <a href="https://github.com/harezmi/fit4j/blob/main/YetAnotherSampleFIT.kt"><code>YetAnotherSampleFIT.kt</code></a> with <code>EmbeddedKafka</code> and <code>MockServiceCallTracker</code>).</p>
</li>
<li>
<p><strong>Regression tests for bug fixes:</strong></p>
</li>
<li>
<p>When you fix a bug, add a test that would fail without the fix and clearly describes the case in its name.</p>
</li>
<li>
<p><strong>Maintainability of examples:</strong></p>
</li>
<li><code>fit4j-examples/**</code> is treated as an important part of the test surface. Changes in core should not silently break examples.</li>
<li>Add new example modules or tests when describing non-trivial features in README.</li>
</ol>
<p>Most CI setups for this repository will likely:</p>
<ul>
<li>Run <code>./gradlew test</code> (or <code>mvn test</code>) with parallelism disabled for FIT/IT suites.</li>
<li>Fail the build if any of the described suites fail, effectively acting as quality gates for FIT4J’s promises.</li>
</ul>
<hr />
<h2>Recommended Flow for New Features</h2>
<p>When implementing a new feature in this repository, follow this test strategy:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Add unit tests"] --> step2["Add FIT or IT tests"]
 step2 --> step3["Add example tests"]
 step3 --> step4["Ensure sequential config"]
</div></div>
<ol>
<li>
<p><strong>Add unit tests</strong><br />
   Test pure logic first with fast tests that do not involve Spring.</p>
</li>
<li>
<p><strong>Add FIT or IT tests</strong>  </p>
</li>
<li>Use <code>@IT</code> for infrastructure wiring features.  </li>
<li>
<p>Use <code>@FIT</code> for end-to-end behavior involving fixtures, request/response training, tracking, etc.</p>
</li>
<li>
<p><strong>Add example tests</strong><br />
   Extend <code>fit4j-examples/**</code> with a focused example that demonstrates how end users should employ the new feature.</p>
</li>
<li>
<p><strong>Ensure sequential config</strong><br />
   Confirm that your build configuration enforces single-fork or non-parallel execution for FIT/IT tests and that your tests do not introduce unsafe static state.</p>
</li>
</ol>
<hr />
<h2>Summary</h2>
<ul>
<li>This repository uses a combination of <strong>unit tests</strong>, <strong><code>@IT</code> integration tests</strong>, and <strong><code>@FIT</code> feature tests</strong>.</li>
<li>Several suites are dedicated to verifying <strong>context caching</strong> and <strong>database support</strong>, which are critical to FIT4J’s correctness and performance.</li>
<li>Example FIT tests double as <strong>executable documentation</strong> and are part of the quality gate.</li>
<li>Parallel execution is <strong>not supported</strong> for FIT/IT tests; build configs must enforce sequential execution.</li>
<li>Contributors are expected to cover new features thoroughly and align new tests with the existing patterns described here.</li>
</ul>
  </div>
</section>


<section id="section-build-release-and-publishing" class="dw-section">
  <div class="dw-section-inner">
    <h1>Build, Release &amp; Publishing</h1>
<p>This page describes how FIT4J is built, versioned, and published to Maven Central. It consolidates the quick checklist in <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md"><code>MAVEN_CENTRAL_SETUP.md</code></a> and the Gradle configuration details in <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md"><code>PUBLISHING.md</code></a>, and explains how local builds relate to the CI/CD pipeline and GitHub Releases.</p>
<hr />
<h2>Overview</h2>
<p>FIT4J uses:</p>
<ul>
<li><strong>Gradle</strong> as the build tool.</li>
<li><strong>Vanniktech Gradle Maven Publish Plugin</strong> for Maven Central publication (<a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md"><code>PUBLISHING.md</code></a>).</li>
<li><strong>GPG signing</strong> for all artifacts.</li>
<li><strong>Sonatype OSSRH</strong> for snapshot and release repositories.</li>
<li><strong>GitHub Actions</strong> (via repository secrets) to automate releases from tags.</li>
</ul>
<p>Local developers can build and publish snapshots manually, while production releases are expected to be triggered by GitHub Releases and completed through Sonatype’s staging workflow.</p>
<p>For general development/build instructions, see <a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md#L33-L60"><code>CONTRIBUTING.md:33-60</code></a>.</p>
<hr />
<h2>Build &amp; Local Development</h2>
<h3>Local Build</h3>
<p>To build and test locally (no publishing):</p>
<pre><code class="language-bash">./gradlew build
./gradlew test
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md#L33-L60"><code>CONTRIBUTING.md:33-60</code></a> for basic local setup and test commands.</p>
<p>This ensures the project compiles and tests pass before any publishing attempt.</p>
<hr />
<h2>Gradle Publishing Configuration</h2>
<p>All Maven Central–specific configuration lives in <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md"><code>PUBLISHING.md</code></a>. The actual Gradle snippets are intended to be placed in your <a href="https://github.com/harezmi/fit4j/blob/main/build.gradle.kts"><code>build.gradle.kts</code></a>.</p>
<h3>Required Plugins</h3>
<p>FIT4J uses the following plugins for publishing (see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L7-L17"><code>PUBLISHING.md:7-17</code></a>):</p>
<pre><code class="language-kotlin">// build.gradle.kts
plugins {
    id(&quot;signing&quot;)
    id(&quot;com.vanniktech.maven.publish&quot;) version &quot;0.34.0&quot;
}
</code></pre>
<ul>
<li><code>signing</code>: performs GPG signing of publications.</li>
<li><code>com.vanniktech.maven.publish</code>: encapsulates Maven Central conventions and tasks.</li>
</ul>
<h3>Enabling Maven Central and Signing</h3>
<p>Core publishing configuration (see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L19-L28"><code>PUBLISHING.md:19-28</code></a>):</p>
<pre><code class="language-kotlin">// build.gradle.kts
mavenPublishing {
    publishToMavenCentral(true)
    signAllPublications()
}
</code></pre>
<p>This instructs the plugin to:</p>
<ul>
<li>Target Sonatype OSSRH / Maven Central.</li>
<li>Ensure all Maven publications are signed with your GPG key (configured separately).</li>
</ul>
<h3>Coordinates &amp; POM Metadata</h3>
<p>FIT4J sets full Maven coordinates and rich POM metadata (see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L30-L72"><code>PUBLISHING.md:30-72</code></a>):</p>
<pre><code class="language-kotlin">// build.gradle.kts
mavenPublishing {
    coordinates(&quot;${'$'}{project.group}&quot;, &quot;${'$'}{project.name}&quot;, &quot;${'$'}{project.version}&quot;)

    pom {
        name.set(&quot;FIT4J&quot;)
        description.set(&quot;Functional Integration Testing Library for Java and Kotlin microservices&quot;)
        inceptionYear.set(&quot;2025&quot;)
        url.set(&quot;https://github.com/harezmi/fit4j&quot;)
        licenses {
            license {
                name.set(&quot;The Apache License, Version 2.0&quot;)
                url.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
                distribution.set(&quot;http://www.apache.org/licenses/LICENSE-2.0.txt&quot;)
            }
        }
        developers {
            developer {
                id.set(&quot;harezmi&quot;)
                name.set(&quot;Kenan Sevindik&quot;)
                email.set(&quot;ksevindik@gmail.com&quot;)
            }
        }
        scm {
            connection.set(&quot;scm:git:git://github.com/harezmi/fit4j.git&quot;)
            developerConnection.set(&quot;scm:git:ssh://github.com:harezmi/fit4j.git&quot;)
            url.set(&quot;https://github.com/harezmi/fit4j&quot;)
        }
    }
}
</code></pre>
<p>Why this matters:</p>
<ul>
<li><strong>Maven Central compliance</strong>: requires license, SCM, and developer information.</li>
<li><strong>Searchability</strong>: metadata appears in search.maven.org.</li>
<li><strong>License compatibility</strong>: coordinated with <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L1-L80"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:1-80</code></a>.</li>
</ul>
<hr />
<h2>GPG Signing Setup</h2>
<h3>Gradle Signing Configuration</h3>
<p>Signing is configured as (see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L74-L104"><code>PUBLISHING.md:74-104</code></a>):</p>
<pre><code class="language-kotlin">// build.gradle.kts
signing {
    useGpgCmd()
    sign(publishing.publications)
}

val signingTasks: TaskCollection&lt;Sign&gt; = tasks.withType&lt;Sign&gt;()
tasks.withType&lt;PublishToMavenRepository&gt;().configureEach {
    mustRunAfter(signingTasks)
}
</code></pre>
<p>This ensures:</p>
<ul>
<li><code>gpg</code> CLI is used to sign artifacts.</li>
<li>All publishing tasks run only after signing tasks have completed, avoiding unsigned uploads.</li>
</ul>
<p>Additional GPG configuration is set via Gradle properties (see below) or via the <code>signing.gnupg</code> block in the same file (<a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L106-L118"><code>PUBLISHING.md:106-118</code></a>):</p>
<pre><code class="language-kotlin">signing.gnupg.executable = &quot;gpg&quot;
signing.gnupg.keyName = &quot;&lt;key id&gt;&quot;
signing.gnupg.passphrase = &quot;&lt;pgp keystore pass&gt;&quot;
signing.secretKeyRingFile = &quot;/Users/&lt;username&gt;/.gnupg/secring.gpg&quot;
</code></pre>
<blockquote>
<p>Replace placeholders with real values locally, but <strong>never commit secrets</strong>.</p>
</blockquote>
<h3>Generating &amp; Exporting GPG Key</h3>
<p>One-time GPG setup (see <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L40-L75"><code>MAVEN_CENTRAL_SETUP.md:40-75</code></a>):</p>
<pre><code class="language-bash"># Install GPG
brew install gnupg  # macOS
# or
sudo apt-get install gnupg  # Linux

# Generate key (interactive)
gpg --gen-key

# List secret keys and copy the SHORT key id (e.g. ABCD1234)
gpg --list-secret-keys --keyid-format SHORT

# Publish key to public servers
gpg --keyserver keyserver.ubuntu.com --send-keys YOUR_KEY_ID
gpg --keyserver keys.openpgp.org --send-keys YOUR_KEY_ID
gpg --keyserver pgp.mit.edu --send-keys YOUR_KEY_ID

# Export secret key for Gradle
gpg --export-secret-keys &gt; ~/.gnupg/secring.gpg
</code></pre>
<p>Never commit <code>secring.gpg</code> or any key material to the repository.</p>
<hr />
<h2>Sonatype / Maven Central Credentials</h2>
<h3>Local Gradle Properties</h3>
<p>Configure OSSRH credentials and signing properties in <code>~/.gradle/gradle.properties</code> (see <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L77-L98"><code>MAVEN_CENTRAL_SETUP.md:77-98</code></a>):</p>
<pre><code class="language-properties"># Sonatype OSSRH credentials
ossrhUsername=your-sonatype-username
ossrhPassword=********

# GPG signing configuration
signing.keyId=ABCD1234
signing.password=********
signing.secretKeyRingFile=/Users/yourusername/.gnupg/secring.gpg
</code></pre>
<p>These values are used by the Vanniktech plugin and the Gradle <code>signing</code> plugin during publication. They must <strong>not</strong> be checked into version control.</p>
<h3>Token-based Credentials (Plugin Level)</h3>
<p>The plugin also supports token-based credentials (see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L120-L130"><code>PUBLISHING.md:120-130</code></a>):</p>
<pre><code class="language-kotlin">// build.gradle.kts
mavenCentralUsername = &quot;&lt;token username&gt;&quot;
mavenCentralPassword = &quot;********&quot;
</code></pre>
<p>You obtain these from https://central.sonatype.com/usertoken.</p>
<p>For CI use, prefer tokens instead of raw usernames/passwords.</p>
<hr />
<h2>Repository Coordinates &amp; Group IDs</h2>
<p>Sonatype requires ownership of the group ID. The project uses either:</p>
<ul>
<li><code>org.fit4j</code>, tied to a custom domain, or</li>
<li><code>io.github.ksevindik</code> for GitHub-based ownership (recommended if you don’t control <code>fit4j.org</code>).</li>
</ul>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L14-L28"><code>MAVEN_CENTRAL_SETUP.md:14-28</code></a>:</p>
<ul>
<li>Update <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties"><code>gradle.properties</code></a>: <code>group = io.github.ksevindik</code></li>
<li>Users will depend on:<br />
<code>io.github.ksevindik:fit4j:&lt;version&gt;</code></li>
</ul>
<p>Group ID choice affects:</p>
<ul>
<li>The <strong>coordinates</strong> in published POM metadata.</li>
<li>Which OSSRH project you must request in the Sonatype JIRA (<a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L4-L13"><code>MAVEN_CENTRAL_SETUP.md:4-13</code></a>).</li>
</ul>
<hr />
<h2>CI/CD &amp; GitHub Secrets</h2>
<h3>GitHub Repository Secrets</h3>
<p>To allow GitHub Actions to publish artifacts, configure repository secrets (see <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L100-L128"><code>MAVEN_CENTRAL_SETUP.md:100-128</code></a>):</p>
<table>
<thead>
<tr>
<th>Secret Name</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OSSRH_USERNAME</code></td>
<td>Sonatype username</td>
</tr>
<tr>
<td><code>OSSRH_PASSWORD</code></td>
<td>Sonatype password</td>
</tr>
<tr>
<td><code>SIGNING_KEY_ID</code></td>
<td>GPG key ID</td>
</tr>
<tr>
<td><code>SIGNING_PASSWORD</code></td>
<td>GPG passphrase</td>
</tr>
<tr>
<td><code>SIGNING_SECRET_KEY</code></td>
<td>Base64-encoded GPG private key</td>
</tr>
</tbody>
</table>
<p>Export and encode the secret key for CI:</p>
<pre><code class="language-bash">gpg --export-secret-keys YOUR_KEY_ID | base64 &gt; gpg-key.txt
# Copy entire contents of gpg-key.txt into SIGNING_SECRET_KEY (secret)
</code></pre>
<p>These secrets are consumed by GitHub Actions workflows (not shown in the snippets) to:</p>
<ul>
<li>Import the GPG key,</li>
<li>Configure Gradle properties in the CI environment,</li>
<li>Invoke the appropriate <code>./gradlew</code> publish tasks.</li>
</ul>
<hr />
<h2>Publishing Tasks &amp; Commands</h2>
<h3>Standard Publishing Task</h3>
<p>The canonical publish task for Maven Central is (see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L132-L138"><code>PUBLISHING.md:132-138</code></a>):</p>
<pre><code class="language-bash">./gradlew publishToMavenCentral --no-configuration-cache
</code></pre>
<p>This leverages the Vanniktech plugin’s <code>publishToMavenCentral</code> lifecycle shortcut.</p>
<h3>Snapshot Publication (Local or CI)</h3>
<p>For snapshot builds (from <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L130-L139"><code>MAVEN_CENTRAL_SETUP.md:130-139</code></a>):</p>
<pre><code class="language-bash"># Ensure version in gradle.properties ends with -SNAPSHOT
version=1.0.1-SNAPSHOT

./gradlew publish
</code></pre>
<p>Snapshots are pushed to:</p>
<ul>
<li><code>https://s01.oss.sonatype.org/content/repositories/snapshots/</code></li>
</ul>
<p>Consumers must configure the snapshot repository accordingly (see <a href="https://github.com/harezmi/fit4j/blob/main/README.md#L80-L101"><code>README.md:80-101</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L140-L155"><code>PUBLISHING.md:140-155</code></a>).</p>
<h3>Release Publication (Manual + Sonatype Staging)</h3>
<p>There are two paths for a release (from <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L139-L189"><code>MAVEN_CENTRAL_SETUP.md:139-189</code></a>).</p>
<h4>Option A: Via GitHub Release (Recommended)</h4>
<ol>
<li><strong>Create Git tag &amp; GitHub Release</strong>  </li>
<li>Tag format: <code>v1.0.0</code>.</li>
<li><strong>GitHub Actions runs</strong>  </li>
<li>CI uses the tag to:<ul>
<li>Build and sign artifacts.</li>
<li>Upload to Sonatype staging repository.</li>
</ul>
</li>
<li><strong>Finalize in Sonatype Nexus</strong>  </li>
<li>Login: <code>https://s01.oss.sonatype.org/</code></li>
<li>Locate the staging repository.</li>
<li>Click <strong>Close</strong>, wait for validations.</li>
<li>If successful, click <strong>Release</strong>.</li>
</ol>
<p>This option centralizes builds in CI, ensuring reproducibility and traceability.</p>
<h4>Option B: Fully Manual Release</h4>
<p>Performed from a developer machine (see <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L151-L189"><code>MAVEN_CENTRAL_SETUP.md:151-189</code></a>):</p>
<pre><code class="language-bash"># 1. Set a release version (no -SNAPSHOT)
version=1.0.0  # in gradle.properties

# 2. Commit and tag
git commit -am &quot;Release 1.0.0&quot;
git tag v1.0.0
git push origin main --tags

# 3. Publish artifacts
./gradlew publish

# 4. Finalize in Sonatype Nexus
#    https://s01.oss.sonatype.org/
#    Close and then Release the staging repository

# 5. Bump to next snapshot
version=1.0.1-SNAPSHOT  # in gradle.properties
git commit -am &quot;Prepare next iteration&quot;
git push
</code></pre>
<p>This manual process should be used mainly when CI is unavailable. In normal operation, prefer Option A.</p>
<hr />
<h2>Release Flow (High-Level)</h2>
<div class="dw-mermaid-wrapper"><div class="mermaid">
graph TD
 step1["Tag or Snapshot"] --> step2["Gradle publish task"]
 step2 --> step3["Artifacts signed and uploaded"]
 step3 --> step4["Sonatype staging repository"]
 step4 --> step5["Close and Release in Nexus"]
 step5 --> step6["Synced to Maven Central"]
</div></div>
<ul>
<li><strong>Tag or Snapshot</strong>: Either a snapshot publish (<code>-SNAPSHOT</code> version) or a tagged release (<code>vX.Y.Z</code>).</li>
<li><strong>Gradle publish task</strong>: <code>publish</code> or <code>publishToMavenCentral</code>.</li>
<li><strong>Signed upload</strong>: GPG-signed artifacts using local or CI GPG config.</li>
<li><strong>Staging</strong>: Sonatype validates POMs, signatures, and metadata.</li>
<li><strong>Release</strong>: Once validations pass, staging is released and synced to Maven Central (search.maven.org).</li>
</ul>
<hr />
<h2>Using FIT4J from Maven Central or Snapshots</h2>
<h3>Maven Central (Stable Releases)</h3>
<p>Example dependency after a release (from <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L191-L205"><code>MAVEN_CENTRAL_SETUP.md:191-205</code></a>):</p>
<pre><code class="language-kotlin">// build.gradle.kts
dependencies {
    testImplementation(&quot;org.fit4j:fit4j:1.0.0&quot;)
}
</code></pre>
<p>Update <code>group</code> and version to match whichever group ID is used (<code>org.fit4j</code> or <code>io.github.ksevindik</code>).</p>
<h3>Snapshots</h3>
<p>To consume snapshot versions:</p>
<p><strong>Gradle (Kotlin DSL)</strong> (<a href="https://github.com/harezmi/fit4j/blob/main/README.md#L80-L101"><code>README.md:80-101</code></a> + <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L140-L155"><code>PUBLISHING.md:140-155</code></a>):</p>
<pre><code class="language-kotlin">repositories {
    mavenCentral()
    maven {
        url = uri(&quot;https://s01.oss.sonatype.org/content/repositories/snapshots/&quot;)
    }
}

dependencies {
    testImplementation(&quot;org.fit4j:fit4j:1.0.0-SNAPSHOT&quot;)
}
</code></pre>
<p><strong>Note:</strong> For the central-based snapshot repo (as per newer Sonatype docs), you can alternatively use:</p>
<pre><code class="language-kotlin">repositories {
    mavenCentral()
    maven {
        name = &quot;sonatypeSnapshots&quot;
        url = uri(&quot;https://central.sonatype.com/repository/maven-snapshots/&quot;)
        mavenContent { snapshotsOnly() }
    }
}
</code></pre>
<p>(see <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L140-L155"><code>PUBLISHING.md:140-155</code></a>).</p>
<hr />
<h2>Verification After Release</h2>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L191-L205"><code>MAVEN_CENTRAL_SETUP.md:191-205</code></a>:</p>
<ol>
<li><strong>Check search.maven.org</strong>  </li>
<li>Wait up to ~2 hours after release.</li>
<li>
<p>URL example:<br />
<code>https://search.maven.org/search?q=g:org.fit4j</code>.</p>
</li>
<li>
<p><strong>Use in a real project</strong>  </p>
</li>
<li>Add dependency:
     <code>kotlin
     dependencies {
         testImplementation("org.fit4j:fit4j:1.0.0")
     }</code></li>
<li>
<p>Run a build to confirm the coordinates resolve.</p>
</li>
<li>
<p><strong>Check POM license metadata</strong>  </p>
</li>
<li>Should match the Apache 2.0 configuration described in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md#L1-L40"><code>LICENSE-THIRD-PARTY.md:1-40</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md#L81-L120"><code>LICENSE_COMPATIBILITY_ANALYSIS.md:81-120</code></a>.</li>
</ol>
<hr />
<h2>Common Publishing Issues &amp; Troubleshooting</h2>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md#L207-L246"><code>MAVEN_CENTRAL_SETUP.md:207-246</code></a>:</p>
<h3>401 Unauthorized</h3>
<ul>
<li>Ensure <code>ossrhUsername</code> / <code>ossrhPassword</code> in <code>~/.gradle/gradle.properties</code> are correct.</li>
<li>Verify the Sonatype account is active and not locked.</li>
<li>If using tokens, ensure <code>mavenCentralUsername</code> / <code>mavenCentralPassword</code> match the token credentials, not your login password.</li>
</ul>
<h3>Unable to Find Credentials for Signing</h3>
<ul>
<li>Verify GPG key exists locally:</li>
</ul>
<p><code>bash
  gpg --list-keys</code></p>
<ul>
<li>Ensure <code>signing.*</code> properties are correctly set in <code>~/.gradle/gradle.properties</code>.</li>
<li>Re-export the secret key if needed:</li>
</ul>
<p><code>bash
  gpg --export-secret-keys --output ~/.gnupg/secring.gpg --armor YOUR_KEY_ID</code></p>
<h3>Cannot Close Staging Repository</h3>
<ul>
<li>In Sonatype Nexus:</li>
<li>Open the staging repo → <strong>Activity</strong> tab to see validation errors.</li>
<li>Common causes:</li>
<li>Missing POM metadata (already handled by POM config in <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md#L30-L72"><code>PUBLISHING.md:30-72</code></a>).</li>
<li>Missing signatures (handled by signing config).</li>
<li>Wrong group ID or lack of permission for that group ID.</li>
</ul>
<h3>Release Button is Disabled</h3>
<ul>
<li>Wait for the <strong>Close</strong> operation to finish (2–5 minutes).</li>
<li>Refresh the page and check the <strong>Activity</strong> tab for unresolved errors.</li>
</ul>
<hr />
<h2>CI/CD Expectations</h2>
<ul>
<li><strong>Snapshot builds</strong>:</li>
<li>Typically triggered from main branch merges.</li>
<li>Use <code>-SNAPSHOT</code> version in <a href="https://github.com/harezmi/fit4j/blob/main/gradle.properties"><code>gradle.properties</code></a>.</li>
<li>Run <code>./gradlew publish</code> to Sonatype snapshots repository.</li>
<li><strong>Release builds</strong>:</li>
<li>Triggered by pushing a version tag (e.g., <code>v1.0.0</code>).</li>
<li>CI creates a staging repository in Sonatype using <code>publishToMavenCentral</code>.</li>
<li>A human still needs to finalize the release in Sonatype Nexus (Close → Release).</li>
<li><strong>Post-release</strong>:</li>
<li>Bump the version to the next <code>-SNAPSHOT</code>.</li>
<li>Ensure the new version is committed to keep CI and local versions aligned.</li>
</ul>
<p>Workflows and their exact YAML definitions are not included here, but they are expected to:</p>
<ul>
<li>Read credentials from GitHub Actions secrets.</li>
<li>Configure Gradle properties/environment at runtime.</li>
<li>Invoke <code>./gradlew publish</code> or <code>./gradlew publishToMavenCentral</code>.</li>
</ul>
<hr />
<h2>Further References</h2>
<ul>
<li>Detailed Gradle config: <a href="https://github.com/harezmi/fit4j/blob/main/PUBLISHING.md"><code>PUBLISHING.md</code></a></li>
<li>Quick Sonatype checklist &amp; credentials: <a href="https://github.com/harezmi/fit4j/blob/main/MAVEN_CENTRAL_SETUP.md"><code>MAVEN_CENTRAL_SETUP.md</code></a></li>
<li>License and third-party dependencies: <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md"><code>LICENSE_COMPATIBILITY_ANALYSIS.md</code></a></li>
<li>Sonatype official guide: https://central.sonatype.org/publish/publish-guide/</li>
<li>Contribution and general build info: <a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a></li>
</ul>
  </div>
</section>


<section id="section-error-handling-logging-and-observability" class="dw-section">
  <div class="dw-section-inner">
    <h1>Error Handling, Logging &amp; Observability</h1>
<p>This page explains how Fit4J reports and tracks errors for external calls, how call traces are captured (HTTP and gRPC), and how logging is used to support debugging. It focuses on the behavior visible to test authors when something goes wrong (e.g., missing mock responses, gRPC wiring issues) and how to inspect those failures.</p>
<blockquote>
<p>See [Glossary] and [Execution Flow] sections for broader domain and runtime context.</p>
</blockquote>
<hr />
<h2>Overview</h2>
<p>Fit4J’s observability model is centered around:</p>
<ul>
<li><strong>Call tracing</strong> for every external interaction (HTTP and gRPC).</li>
<li><strong>Central tracking</strong> of these traces via <code>MockServiceCallTracker</code>.</li>
<li><strong>Error-aware status and message handling</strong> per trace.</li>
<li><strong>Logging</strong> at key failure points (mock resolution, gRPC server processing).</li>
<li><strong>Domain exceptions</strong> for configuration/usage errors (e.g., gRPC service not created).</li>
</ul>
<p>These mechanisms are primarily exercised during FIT tests (annotated with <code>@FIT</code>) where all external calls should be predictable and verifiable.</p>
<hr />
<h2>Call Traces</h2>
<h3>CallTrace abstraction</h3>
<p>Fit4J represents each external call (HTTP or gRPC) as a <code>CallTrace</code> instance. While the generic interface is not shown directly in the snippets, we can infer the key methods from implementations such as <code>GrpcCallTrace</code>:</p>
<ul>
<li><code>matchesRequestPath(path: String): Boolean</code></li>
<li><code>getRequest(): Any</code></li>
<li><code>getResponse(): Any?</code></li>
<li><code>hasError(): Boolean</code></li>
<li><code>getError(): Throwable?</code></li>
<li><code>getStatus(): Int</code></li>
<li><code>getErrorMessage(): String?</code></li>
</ul>
<p>These are implemented by protocol-specific classes, e.g. <code>GrpcCallTrace</code> in:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/GrpcCallTrace.kt#L5-L43"><code>src/main/kotlin/org/fit4j/grpc/GrpcCallTrace.kt:5-43</code></a></li>
</ul>
<pre><code class="language-kotlin">data class GrpcCallTrace(
    private val request: MessageLite,
    private val response: Any?,
    private val throwable: Throwable?
) : CallTrace&lt;MessageLite,Any&gt; {

    override fun matchesRequestPath(path: String): Boolean {
        return request.javaClass.name.equals(path)
    }

    override fun getRequest(): MessageLite = request

    override fun getResponse(): Any? = response

    override fun hasError(): Boolean {
        return throwable != null || response is Throwable
    }

    override fun getError(): Throwable? {
        return if (throwable != null) {
            throwable
        } else if (response is Throwable) {
            response
        } else null
    }

    override fun getStatus(): Int {
        return if (!hasError()) Status.OK.code.value()
        else (getError() as StatusRuntimeException).status.code.value()
    }

    override fun getErrorMessage(): String? {
        return if (this.hasError()) this.getError()!!.message else null
    }

    override fun toString(): String {
        return &quot;GrpcCallTrace(request=${request.javaClass.name}, &quot; +
               &quot;response=${response?.javaClass?.name}, &quot; +
               &quot;throwable=${throwable?.javaClass})&quot;
    }
}
</code></pre>
<p>Key aspects:</p>
<ul>
<li><strong>Request identification</strong>: <code>matchesRequestPath</code> uses the <strong>fully qualified request class name</strong> to match a trace to a path-type identifier.</li>
<li><strong>Error detection</strong>:</li>
<li>Either a non-null <code>throwable</code>, or</li>
<li>A <code>response</code> that itself is a <code>Throwable</code> (e.g., some APIs treat error responses this way).</li>
<li><strong>Status resolution</strong>:</li>
<li>If no error → <code>Status.OK.code.value()</code>.</li>
<li>If error → cast <code>getError()</code> to <code>StatusRuntimeException</code> and return its status code.</li>
<li><strong>Error message</strong>: Derived directly from the <code>Throwable.message</code>.</li>
</ul>
<blockquote>
<p>For HTTP traces, similar behavior is implemented in <code>HttpCallTrace</code> (see that file for HTTP-specific status handling).</p>
</blockquote>
<h3>GrpcCallTraceFactory</h3>
<p>Fit4J uses factories to create the correct trace type based on the request object. For gRPC:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/GrpcCallTraceFactory.kt#L3-L12"><code>src/main/kotlin/org/fit4j/grpc/GrpcCallTraceFactory.kt:3-12</code></a></li>
</ul>
<pre><code class="language-kotlin">class GrpcCallTraceFactory : CallTraceFactory&lt;MessageLite, Any, GrpcCallTrace&gt; {

    override fun create(
        request: MessageLite,
        response: Any?,
        exception: Throwable?
    ): GrpcCallTrace {
        return GrpcCallTrace(request, response, exception)
    }

    override fun isApplicableFor(req: Any): Boolean {
        return req is MessageLite
    }
}
</code></pre>
<p>This allows the central tracker to stay protocol-agnostic while still recording protocol-specific details and metrics.</p>
<hr />
<h2>Central Call Tracking</h2>
<h3>MockServiceCallTracker</h3>
<p><code>MockServiceCallTracker</code> is the central component that records all external call traces and exposes them to tests.</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/MockServiceCallTracker.kt#L5-L29"><code>src/main/kotlin/org/fit4j/mock/MockServiceCallTracker.kt:5-29</code></a></li>
</ul>
<pre><code class="language-kotlin">class MockServiceCallTracker(
    val callTraceFactoryList: List&lt;CallTraceFactory&lt;*,*, *&gt;&gt;
) {

    private val traces: MutableList&lt;CallTrace&lt;*,*&gt;&gt; = mutableListOf()

    private val logger = LoggerFactory.getLogger(this.javaClass)

    private fun callTrace(
        request: Any,
        response: Any?,
        exception: Throwable? = null
    ): CallTrace&lt;*,*&gt;? {
        var callTrace: CallTrace&lt;*,*&gt;? = null
        for (callTraceFactory in callTraceFactoryList) {
            // Factory selection logic here
        }
        return callTrace
    }

    // public API like track(...) and getTraces() exists here
}
</code></pre>
<p>Although not fully visible, the pattern is:</p>
<ul>
<li>Iterate over <code>callTraceFactoryList</code>.</li>
<li>Select the first factory where <code>isApplicableFor(request)</code> returns <code>true</code>.</li>
<li>Build a <code>CallTrace</code> via <code>create(request, response, exception)</code>.</li>
<li>Append to <code>traces</code>.</li>
</ul>
<p>The tracker is:</p>
<ul>
<li><strong>Injected into test contexts</strong> (see below).</li>
<li><strong>Cleared after each test method</strong> to avoid cross-test contamination.</li>
</ul>
<h3>Lifecycle &amp; Test Isolation</h3>
<p>The test fixture shows how Fit4J ensures that traces do not leak between tests:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt#L15-L37"><code>src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt:15-37</code></a></li>
</ul>
<pre><code class="language-kotlin">@FIT
class MockServiceCallTrackerFIT {

    @Autowired
    private lateinit var mockServiceCallTracker: MockServiceCallTracker

    @TestConfiguration
    class TestConfig {

        @Autowired
        private lateinit var mockServiceCallTracker: MockServiceCallTracker

        @AfterTestMethod
        @Order(Ordered.LOWEST_PRECEDENCE)
        fun verifyTracesAreClearedAfterEachTestMethodExecution() {
            Assertions.assertEquals(0, mockServiceCallTracker.getTraces().size)
        }
    }
}
</code></pre>
<p>Implications:</p>
<ul>
<li>After each test, the tracker’s internal storage <strong>must be empty</strong>.</li>
<li>If any test leaves unverified traces, either:</li>
<li>The cleanup logic explicitly clears them, or</li>
<li>Test failures are raised in other parts of the framework (e.g., “untrained call” checks).</li>
</ul>
<p>This is critical for observability: you can rely on <code>getTraces()</code> to reflect <strong>only what happened in the current test</strong>.</p>
<h3>Accessing Traces in Tests</h3>
<p>The README shows typical usage (excerpt):</p>
<ul>
<li><code>README.md:...</code> (around call tracking section)</li>
</ul>
<pre><code class="language-kotlin">@FIT
class SampleFIT {
    @Autowired
    private lateinit var mockServiceCallTracker: MockServiceCallTracker

    @Test
    fun `verify external calls`() {
        // Your test code that triggers external calls

        // Verify gRPC calls
        val grpcRequests =
            mockServiceCallTracker.getGrpcRequest(GetFooRequest::class.java)

        // Verify HTTP calls, errors, etc.
    }
}
</code></pre>
<p>You can:</p>
<ul>
<li>Inspect specific protocol calls (gRPC / HTTP).</li>
<li>Assert on <code>hasError()</code>, <code>getStatus()</code>, <code>getErrorMessage()</code>.</li>
<li>Use convenience methods like <code>hasAnyError</code>, <code>hasGrpcError</code>, <code>hasHttpError</code> mentioned in <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>.</li>
</ul>
<hr />
<h2>Error Handling in gRPC Flow</h2>
<h3>TestGrpcServiceConfigurer</h3>
<p><code>TestGrpcServiceConfigurer</code> wires the in-process gRPC server for tests and is responsible for:</p>
<ul>
<li>Looking up mock responses using <code>MockResponseFactory</code>.</li>
<li>Tracking each call via <code>MockServiceCallTracker</code>.</li>
<li>Converting internal exceptions into gRPC <code>StatusRuntimeException</code> for the client.</li>
</ul>
<p>Relevant snippet:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt#L33-L48"><code>src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt:33-48</code></a></li>
</ul>
<pre><code class="language-kotlin">try {
    // response resolution logic
    responseObserver.onNext(response)
    responseObserver.onCompleted()
} catch (ex: Exception) {
    exception = ex
    logger.error(
        &quot;Error occurred during mock grpc server response resolution with reason :${ex.message}&quot;,
        ex
    )
    mockServiceCallTracker.track(request, response, exception)
    responseObserver.onError(StatusRuntimeException(Status.UNAVAILABLE))
}
</code></pre>
<p>Behavior:</p>
<ol>
<li><strong>Normal path</strong>:</li>
<li>Response is resolved from mocks (<code>MockResponseFactory</code>).</li>
<li>Response is sent with <code>onNext</code> followed by <code>onCompleted</code>.</li>
<li>
<p><code>MockServiceCallTracker.track(request, response, null)</code> is typically called during this path (not shown but implied by tests).</p>
</li>
<li>
<p><strong>Error path</strong>:</p>
</li>
<li>Any exception in response resolution is caught.</li>
<li>Error is logged (level <strong>ERROR</strong>) with full stack trace.</li>
<li>Call is still tracked with the thrown <code>exception</code>.</li>
<li>A generic <code>Status.UNAVAILABLE</code> error is returned to the gRPC client.</li>
</ol>
<p>This gives you:</p>
<ul>
<li>A <strong>call trace</strong> with the original error.</li>
<li>A <strong>log entry</strong> that can be correlated to the call (message includes reason).</li>
<li>A <strong>standardized gRPC error code</strong> for the client.</li>
</ul>
<h3>GrpcServiceNotCreatedException</h3>
<p>When gRPC test infrastructure cannot correctly bootstrap a service, Fit4J throws <code>GrpcServiceNotCreatedException</code>:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/GrpcServiceNotCreatedException.kt#L3-L6"><code>src/main/kotlin/org/fit4j/grpc/GrpcServiceNotCreatedException.kt:3-6</code></a></li>
</ul>
<pre><code class="language-kotlin">class GrpcServiceNotCreatedException : RuntimeException {
    constructor(message:String, cause: Throwable): super(message, cause)
}
</code></pre>
<p>Typical scenarios where this is raised include:</p>
<ul>
<li>Misconfigured or missing <code>GrpcServiceDefinition</code>s.</li>
<li>Failures in <code>InProcessGrpcServerFactory</code> during service binding.</li>
<li>Inconsistent type descriptors (e.g., mismatch between proto and runtime types).</li>
</ul>
<p><strong>Impact on observability</strong>:</p>
<ul>
<li>This is a <strong>configuration error</strong>, not a per-call error.</li>
<li>You will see it when the test context starts, not as a <code>CallTrace</code>.</li>
<li>Logs should contain the root cause stack trace, while the exception message is propagated to the test framework.</li>
</ul>
<hr />
<h2>HTTP Call Tracing (Summary)</h2>
<p>While the detailed implementation of <code>HttpCallTrace</code> is not included in the snippets, test files reference it:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt#L8-L14"><code>src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt:8-14</code></a></li>
</ul>
<pre><code class="language-kotlin">import org.fit4j.http.HttpCallTrace
import org.fit4j.http.HttpRequest
import org.fit4j.http.HttpResponse
</code></pre>
<p>Observed behaviors from tests:</p>
<ul>
<li>HTTP calls are tracked similarly to gRPC calls.</li>
<li><code>getStatus()</code> returns an HTTP status code (<code>HttpStatus.OK</code>, <code>HttpStatus.INTERNAL_SERVER_ERROR</code>, etc.).</li>
<li><code>hasError()</code> is <code>true</code> when:</li>
<li>There is an exception, or</li>
<li>The HTTP status code indicates an error (e.g., <code>5xx</code>).</li>
</ul>
<p>For details on request/response modeling, see the HTTP-specific code (<code>org.fit4j.http</code> package) and the “External Integrations” section.</p>
<hr />
<h2>Example: gRPC and HTTP Error Tracking in Tests</h2>
<p>The FIT tests show several scenarios demonstrating how errors are captured:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt#L39-L86"><code>src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt:39-86</code></a></li>
</ul>
<pre><code class="language-kotlin">@Test
fun `it should track a gRPC call without any error`() {
    val request = Mockito.mock(MessageLite::class.java)
    val response = null
    val exception = null
    Assertions.assertEquals(0, mockServiceCallTracker.getTraces().size)

    mockServiceCallTracker.track(request, response, exception)

    verifyGrpcCallTrack(request, response, exception, Status.OK, false)
}

@Test
fun `it should track a gRPC call with an error`() {
    val request = Mockito.mock(MessageLite::class.java)
    val response = null
    val exception = StatusRuntimeException(Status.DATA_LOSS)
    Assertions.assertEquals(0, mockServiceCallTracker.getTraces().size)

    mockServiceCallTracker.track(request, response, exception)

    verifyGrpcCallTrack(request, response, exception, Status.DATA_LOSS, true)
}

@Test
fun `it should track a gRPC call with response as an error`() {
    val request = Mockito.mock(MessageLite::class.java)
    val response = StatusRuntimeException(Status.ABORTED)
    val exception = null
    Assertions.assertEquals(0, mockServiceCallTracker.getTraces().size)

    mockServiceCallTracker.track(request, response, exception)

    verifyGrpcCallTrack(request, response, response, Status.ABORTED, true)
}
</code></pre>
<p>Helper method (same file):</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt#L88-L104"><code>src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt:88-104</code></a></li>
</ul>
<pre><code class="language-kotlin">private fun verifyGrpcCallTrack(
    request: MessageLite,
    response: Any?,
    exception: Any?,
    status: Status,
    hasError: Boolean
) {
    val traces = mockServiceCallTracker.getTraces()
    Assertions.assertEquals(1, traces.size)
    val trace = traces.first()
    Assertions.assertSame(request, trace.getRequest())
    Assertions.assertSame(response, trace.getResponse())
    Assertions.assertSame(exception, trace.getError())
    Assertions.assertEquals(status.code.value(), trace.getStatus())
    Assertions.assertEquals(hasError, trace.hasError())
}
</code></pre>
<p>This confirms the intended behavior of <code>GrpcCallTrace</code>:</p>
<ul>
<li><code>getError()</code> returns either the explicit exception or the response when it is an exception.</li>
<li><code>getStatus()</code> maps directly to the <code>Status</code> code of <code>StatusRuntimeException</code>.</li>
<li><code>hasError()</code> reflects the presence of any error, regardless of how it was supplied.</li>
</ul>
<p>The same file also verifies HTTP behavior:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt#L106-L133"><code>src/test/kotlin/org/fit4j/mock/MockServiceCallTrackerFIT.kt:106-133</code></a></li>
</ul>
<pre><code class="language-kotlin">@Test
fun `it should track an HTTP call without any response and any error`() {
    val request = createWebRequest()
    val response = null
    val exception = null
    Assertions.assertEquals(0, mockServiceCallTracker.getTraces().size)

    mockServiceCallTracker.track(request, response, exception)

    verifyWebCallTrack(request, response, exception, HttpStatus.OK, false)
}

@Test
fun `it should track an HTTP call with response as an error`() {
    val request = createWebRequest()
    val response = HttpResponse(HttpStatus.INTERNAL_SERVER_ERROR, null)
    val exception = null
    Assertions.assertEquals(0, mockServiceCallTracker.getTraces().size)

    mockServiceCallTracker.track(request, response, exception)

    verifyWebCallTrack(request, response, exception, HttpStatus.INTERNAL_SERVER_ERROR, true)
}
</code></pre>
<p>The helper <code>verifyWebCallTrack</code> (not fully shown) asserts:</p>
<ul>
<li>Request/response/effective error are tracked.</li>
<li><code>status</code> and <code>hasError</code> match expectations.</li>
</ul>
<hr />
<h2>Logging Strategy</h2>
<h3>gRPC Mock Server Errors</h3>
<p><code>TestGrpcServiceConfigurer</code> logs any exception that occurs while resolving a mock response:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt#L37-L44"><code>src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt:37-44</code></a></li>
</ul>
<pre><code class="language-kotlin">logger.error(
    &quot;Error occurred during mock grpc server response resolution with reason :${ex.message}&quot;,
    ex
)
</code></pre>
<p>Key points:</p>
<ul>
<li><strong>Level</strong>: ERROR.</li>
<li><strong>Message</strong>: Includes a brief reason (<code>ex.message</code>) to quickly identify failure cause.</li>
<li><strong>Throwable</strong>: Passed as <code>ex</code>, so full stack trace is available.</li>
</ul>
<p>This log is emitted <strong>once per failing call</strong> and pairs naturally with the corresponding <code>CallTrace</code> stored by <code>MockServiceCallTracker</code>.</p>
<h3>gRPC Mock Response Provider Initialization</h3>
<p>The default gRPC response provider logs while inspecting response builders:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/DefaultGrpcMockResponseProvider.kt#L9-L24"><code>src/main/kotlin/org/fit4j/grpc/DefaultGrpcMockResponseProvider.kt:9-24</code></a></li>
</ul>
<pre><code class="language-kotlin">class DefaultGrpcMockResponseProvider(
    private val grpcResponseJsonBuilders: List&lt;GrpcResponseJsonBuilder&lt;*&gt;&gt;
) : MockResponseProvider {

    private val grpcResponseJsonBuilderMap =
        mutableMapOf&lt;Class&lt;out Any&gt;, GrpcResponseJsonBuilder&lt;Message&gt;&gt;()

    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)

    @PostConstruct
    fun initialize() {
        buildGrpcResponseJsonBuilderMap()
    }

    private fun buildGrpcResponseJsonBuilderMap() {
        grpcResponseJsonBuilders.forEach {
            val requestType = getGenericRequestType(it)
            grpcResponseJsonBuilderMap.put(requestType, it as GrpcResponseJsonBuilder&lt;Message&gt;)
        }
    }
}
</code></pre>
<p>Although not shown, typical patterns here are:</p>
<ul>
<li>DEBUG-level logs for builder registration.</li>
<li>WARN/ERROR-level logs for misconfigurations (e.g., reflection issues) handled in <code>getGenericRequestType</code>.</li>
</ul>
<p>These logs help diagnose issues in training configuration (e.g., missing or mismatched response builders).</p>
<h3>Tracker Logging</h3>
<p><code>MockServiceCallTracker</code> creates a logger:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/mock/MockServiceCallTracker.kt#L11-L13"><code>src/main/kotlin/org/fit4j/mock/MockServiceCallTracker.kt:11-13</code></a></li>
</ul>
<pre><code class="language-kotlin">private val logger = LoggerFactory.getLogger(this.javaClass)
</code></pre>
<p>Likely usage (pattern):</p>
<ul>
<li>DEBUG: when tracking a call (include request type, status, error flag).</li>
<li>WARN/ERROR: if no suitable <code>CallTraceFactory</code> is found (which may indicate unsupported protocol or configuration errors).</li>
</ul>
<p>When extending or debugging, consider:</p>
<ul>
<li>Using structured logging (e.g., request class, protocol, status).</li>
<li>Ensuring logs do not include sensitive payload data (or mask/redact where necessary).</li>
</ul>
<hr />
<h2>Exception Types and Error Reporting</h2>
<p>The section description mentions additional exceptions that are part of Fit4J’s error model:</p>
<ul>
<li><code>MockResponseNotDefinedException</code></li>
<li><code>MessageNotReceivedException</code></li>
<li><code>GrpcServiceNotCreatedException</code> (actual code shown)</li>
</ul>
<p>Even though only one is in the snippets, their roles can be summarized as:</p>
<ul>
<li><strong>MockResponseNotDefinedException</strong>: Thrown when a call is made for which no mock response (“training”) has been defined.</li>
<li>Typically raised by <code>MockResponseFactory</code> or protocol-specific factories.</li>
<li>This indicates a <strong>test setup error</strong>: your test did not define the expected training for that external interaction.</li>
<li>
<p>Expect the call to also be present as a trace in <code>MockServiceCallTracker</code> for inspection.</p>
</li>
<li>
<p><strong>MessageNotReceivedException</strong>: Thrown when the test expects an external message (e.g., Kafka) that never arrives.</p>
</li>
<li>More aligned with asynchronous observability than call tracing.</li>
<li>
<p>Used to report <strong>missing outbound communication</strong> from your service.</p>
</li>
<li>
<p><strong>GrpcServiceNotCreatedException</strong>: As discussed above, used when the test gRPC service cannot be created.</p>
</li>
</ul>
<h3>How these surface in tests</h3>
<p>In most setups:</p>
<ul>
<li>These exceptions will cause the test to <strong>fail</strong> immediately (either during bootstrap or when the failing call is executed).</li>
<li>You can inspect:</li>
<li>The exception message for a concise explanation.</li>
<li>The call traces in <code>MockServiceCallTracker</code> for detailed context (especially for missing training and unexpected calls).</li>
<li>Logs for stack traces and additional diagnostic information.</li>
</ul>
<hr />
<h2>Observability Flow for a gRPC Call</h2>
<p>The typical lifecycle for a gRPC call in a FIT test looks like this:</p>
<div class="dw-mermaid-wrapper"><div class="mermaid">
sequenceDiagram
 participant A as Test
 participant B as ServiceUnderTest
 participant C as MockGrpcServer
 participant D as Tracker
 A->>B: Trigger business logic
 B->>C: gRPC request
 C->>D: Track request response
 C-->>B: Return gRPC response
 B-->>A: Return test result
</div></div>
<p>Where:</p>
<ul>
<li><strong>MockGrpcServer</strong> is the in-process server configured by <code>TestGrpcAutoConfiguration</code> and <code>TestGrpcServiceConfigurer</code>:</li>
<li>Auto-configuration: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L15-L33"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:15-33</code></a></li>
<li>Service configurer: <a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt#L5-L50"><code>src/main/kotlin/org/fit4j/grpc/TestGrpcServiceConfigurer.kt:5-50</code></a></li>
<li><strong>Tracker</strong> is <code>MockServiceCallTracker</code>, recording each call as a <code>GrpcCallTrace</code>.</li>
</ul>
<p>If an error occurs during mock response resolution:</p>
<ul>
<li>The <code>MockGrpcServer</code> logs an ERROR, tracks the call with an exception, and returns <code>Status.UNAVAILABLE</code> to the client.</li>
<li>The <code>Test</code> can then inspect the tracker and logs to understand the failure.</li>
</ul>
<hr />
<h2>Configuration &amp; Environment</h2>
<h3>gRPC Channel Configuration</h3>
<p>Observability for gRPC depends on test traffic going through the <strong>in-process server</strong> so that Fit4J can intercept and track calls. From <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>:</p>
<ul>
<li><code>README.md:...</code> (gRPC client configuration example)</li>
</ul>
<pre><code class="language-properties">grpc:
  client:
    fooGrpcService:
      address: in-process:${grpc.server.inProcessName}
</code></pre>
<p>Key points:</p>
<ul>
<li>Client stubs (annotated with <code>@GrpcClient</code>) should be configured to use <code>in-process:${grpc.server.inProcessName}</code> in test environments.</li>
<li><code>TestGrpcAutoConfiguration</code> provides a <code>TestGrpcChannelConfigurer</code> bean to help with this wiring:</li>
<li><a href="https://github.com/harezmi/fit4j/blob/main/src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt#L23-L31"><code>src/main/kotlin/org/fit4j/autoconfigure/TestGrpcAutoConfiguration.kt:23-31</code></a></li>
</ul>
<pre><code class="language-kotlin">companion object {
    @Bean
    fun testGrpcChannelNameConfigurer(
        genericApplicationContext: GenericApplicationContext
    ): TestGrpcChannelConfigurer {
        return TestGrpcChannelConfigurer(genericApplicationContext)
    }
}
</code></pre>
<p>If the client does not point to the in-process server:</p>
<ul>
<li>Calls will bypass the mock and will <strong>not be tracked</strong>.</li>
<li>You may see networking errors instead of <code>GrpcServiceNotCreatedException</code> or call traces.</li>
</ul>
<p>Ensure your <a href="https://github.com/harezmi/fit4j/blob/main/application-test.yml"><code>application-test.yml</code></a> overrides production addresses appropriately, masking any credentials if present:</p>
<pre><code class="language-yaml">grpc:
  client:
    fooGrpcService:
      address: in-process:${grpc.server.inProcessName}
      # If authentication is used, mask secrets:
      # authToken: token-****
</code></pre>
<hr />
<h2>Best Practices for Error Handling &amp; Observability</h2>
<ol>
<li><strong>Always inspect <code>MockServiceCallTracker</code> in FIT tests</strong>:</li>
<li>Validate expected outbound calls.</li>
<li>Assert absence of errors (<code>hasAnyError</code>, <code>hasGrpcError</code>, <code>hasHttpError</code>).</li>
<li>
<p>Check statuses and error messages when failures are expected.</p>
</li>
<li>
<p><strong>Define comprehensive trainings</strong>:</p>
</li>
<li>Ensure every external interaction (HTTP/gRPC) has a configured request-response training.</li>
<li>
<p>Use the exceptions (<code>MockResponseNotDefinedException</code>, etc.) as signals of missing training, not runtime bugs.</p>
</li>
<li>
<p><strong>Keep logs clean but informative</strong>:</p>
</li>
<li>Avoid logging full payloads if they contain sensitive data.</li>
<li>
<p>Rely on Fit4J’s own logs for infrastructure-level issues (mock resolution, service creation).</p>
</li>
<li>
<p><strong>Verify per-test isolation</strong>:</p>
</li>
<li>Leverage the built-in <code>@AfterTestMethod</code> assertions as in <code>MockServiceCallTrackerFIT</code>.</li>
<li>
<p>If you write custom test utilities that inspect the tracker, ensure they do not cache old traces.</p>
</li>
<li>
<p><strong>Investigate configuration errors early</strong>:</p>
</li>
<li><code>GrpcServiceNotCreatedException</code> usually indicates misconfiguration; fix these before focusing on business behavior.</li>
<li>Check dependency auto-configuration (<code>TestGrpcAutoConfiguration</code>) and your <a href="https://github.com/harezmi/fit4j/blob/main/application-test.yml"><code>application-test.yml</code></a>.</li>
</ol>
<hr />
<p>By understanding how Fit4J captures call traces, logs errors, and surfaces exceptions, you can quickly diagnose failing FIT tests and maintain high confidence that external interactions are both <strong>fully mocked</strong> and <strong>fully observable</strong>.</p>
  </div>
</section>


<section id="section-licensing-and-third-party-dependencies" class="dw-section">
  <div class="dw-section-inner">
    <h1>Licensing &amp; Third-Party Dependencies</h1>
<p>This page summarizes the licensing model of the FIT4J project, how third‑party dependencies are licensed, and why the current dependency set is compatible with Apache License 2.0. It consolidates the information scattered across <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a>, and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md"><code>LICENSE_COMPATIBILITY_ANALYSIS.md</code></a>.</p>
<p>All concrete dependency and license data below are derived from:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main//README.md"><code>/README.md</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a></li>
<li><a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a></li>
</ul>
<h2>Project License</h2>
<p>FIT4J is licensed under <strong>Apache License 2.0</strong>.</p>
<p>You will find the canonical license text in the root <code>LICENSE</code> file (referenced from <a href="https://github.com/harezmi/fit4j/blob/main//README.md#L1-L20"><code>/README.md:1-20</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L1-L20"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:1-20</code></a>). All source files are expected to include an Apache 2.0 header, as recommended in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L58-L76"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:58-76</code></a>:</p>
<pre><code class="language-kotlin">/*
 * Copyright [YEAR] [Your Name/Organization]
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
</code></pre>
<p>See <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L58-L76"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:58-76</code></a> for the authoritative header template.</p>
<p>Key implications:</p>
<ul>
<li>You may use, modify, and distribute FIT4J, including in commercial settings, under the terms of Apache 2.0.</li>
<li>You must preserve copyright and license notices.</li>
<li>If required by the license of some third‑party dependencies, you may also need to ship additional notices (typically via a <code>NOTICE</code> file).</li>
</ul>
<h2>License Documentation Files</h2>
<h3>README License Section</h3>
<p>The top-level <code>README</code> links to the third‑party license overview and compatibility analysis:</p>
<ul>
<li><a href="https://github.com/harezmi/fit4j/blob/main//README.md#L21-L32"><code>/README.md:21-32</code></a></li>
</ul>
<p>This section:</p>
<ul>
<li>States that FIT4J is under Apache License 2.0.</li>
<li>Points to <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a> for dependency license details.</li>
<li>Points to <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a> for a detailed compatibility analysis.</li>
<li>Notes that all dependencies used are compatible with Apache 2.0.</li>
</ul>
<h3>Third-Party License Inventory</h3>
<p><a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a> contains the authoritative list of dependencies and their licenses. It is the document you should update whenever libraries are added, removed, or upgraded.</p>
<p>Relevant sections:</p>
<ul>
<li>Runtime dependencies and their licenses: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L1-L40"><code>/LICENSE-THIRD-PARTY.md:1-40</code></a>, <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L41-L80"><code>/LICENSE-THIRD-PARTY.md:41-80</code></a></li>
<li>Test-only dependencies: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L81-L96"><code>/LICENSE-THIRD-PARTY.md:81-96</code></a></li>
<li>Build tool dependencies: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L97-L110"><code>/LICENSE-THIRD-PARTY.md:97-110</code></a></li>
</ul>
<h3>License Compatibility Analysis</h3>
<p><a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a> explains <strong>why</strong> the dependency set is compatible with Apache 2.0. It provides:</p>
<ul>
<li>Executive summary and project fit: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L120-L142"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:120-142</code></a></li>
<li>Per-dependency analysis, including special cases:</li>
<li>MySQL Connector/J: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L200-L243"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:200-243</code></a></li>
<li>H2 Database: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L244-L261"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:244-261</code></a></li>
<li>Jakarta Annotation API: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L262-L279"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:262-279</code></a></li>
<li>Protobuf: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L280-L297"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:280-297</code></a></li>
<li>Build tool impact: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L298-L317"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:298-317</code></a></li>
<li>License compatibility matrices: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L318-L343"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:318-343</code></a></li>
<li>Action items and verification checklist: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L344-L381"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:344-381</code></a></li>
<li>References to upstream legal resources: <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L382-L404"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:382-404</code></a></li>
</ul>
<p>When in doubt about whether a new dependency is acceptable, follow the patterns and matrices in this file.</p>
<h2>Third-Party Dependencies Overview</h2>
<h3>Runtime Dependencies and Licenses</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L1-L80"><code>/LICENSE-THIRD-PARTY.md:1-80</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L143-L199"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:143-199</code></a>:</p>
<p><strong>Apache License 2.0</strong></p>
<ul>
<li><code>org.springframework.boot:spring-boot-starter-*</code></li>
<li><code>org.springframework.kafka:spring-kafka</code></li>
<li><code>net.bytebuddy:byte-buddy</code></li>
<li><code>org.yaml:snakeyaml</code></li>
<li><code>org.apache.commons:commons-lang3</code></li>
<li><code>com.fasterxml.jackson.module:jackson-module-kotlin</code></li>
<li><code>org.jetbrains.kotlin:kotlin-stdlib</code></li>
<li><code>org.jetbrains.kotlinx:kotlinx-coroutines-core</code></li>
<li><code>io.grpc:grpc-*</code></li>
<li><code>io.mockk:mockk</code></li>
<li><code>net.devh:grpc-spring-boot-starter</code></li>
<li><code>org.elasticsearch.client:elasticsearch-rest-client</code></li>
<li><code>co.elastic.clients:elasticsearch-java</code></li>
<li><code>com.github.codemonstur:embedded-redis</code></li>
<li><code>io.github.resilience4j:resilience4j-*</code></li>
<li><code>com.amazonaws:DynamoDBLocal</code></li>
</ul>
<p><strong>MIT License</strong></p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L81-L90"><code>/LICENSE-THIRD-PARTY.md:81-90</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L143-L199"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:143-199</code></a>:</p>
<ul>
<li><code>org.testcontainers:testcontainers</code></li>
<li><code>redis.clients:jedis</code></li>
</ul>
<p><strong>BSD-3-Clause</strong></p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L91-L96"><code>/LICENSE-THIRD-PARTY.md:91-96</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L262-L297"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:262-297</code></a>:</p>
<ul>
<li><code>com.google.protobuf:protobuf-java</code></li>
<li><code>com.google.protobuf:protobuf-java-util</code></li>
</ul>
<p><strong>Eclipse Public License 2.0</strong></p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L97-L100"><code>/LICENSE-THIRD-PARTY.md:97-100</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L262-L279"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:262-279</code></a>:</p>
<ul>
<li><code>jakarta.annotation:jakarta.annotation-api</code></li>
</ul>
<p><strong>Dual License MPL 2.0 / EPL 1.0</strong></p>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L101-L104"><code>/LICENSE-THIRD-PARTY.md:101-104</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L244-L261"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:244-261</code></a>:</p>
<ul>
<li><code>com.h2database:h2</code></li>
</ul>
<h3>Test-Only Dependencies</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L105-L116"><code>/LICENSE-THIRD-PARTY.md:105-116</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L200-L243"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:200-243</code></a>:</p>
<p><strong>GPL 2.0 with FOSS (Classpath) Exception</strong></p>
<ul>
<li><code>com.mysql:mysql-connector-j</code> (MySQL Connector/J), used <strong>only in test scope</strong></li>
</ul>
<p>The FOSS/Classpath exception is critical: it allows linking MySQL Connector/J with projects under other licenses (including Apache 2.0) as long as the connector itself remains GPL‑licensed. FIT4J additionally limits this to test scope and does not ship the connector in its runtime artifacts.</p>
<h3>Build Tool Dependencies</h3>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L97-L110"><code>/LICENSE-THIRD-PARTY.md:97-110</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L298-L317"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:298-317</code></a>:</p>
<p><strong>Apache License 2.0</strong></p>
<ul>
<li>Kotlin Gradle Plugin</li>
<li>Google Protobuf Gradle Plugin</li>
<li>Maven Publish Plugin</li>
</ul>
<p>Per <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L298-L317"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:298-317</code></a>, build tools and plugins are considered <strong>non‑runtime</strong> and do not affect the license of the resulting artifacts.</p>
<h2>License Compatibility Analysis</h2>
<h3>License Types and Compatibility Matrix</h3>
<p>FIT4J explicitly documents compatibility with Apache 2.0 in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L318-L343"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:318-343</code></a>:</p>
<table>
<thead>
<tr>
<th>License Type</th>
<th>Apache 2.0 Compatible</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apache 2.0</td>
<td>✅ Yes</td>
<td>Same license</td>
</tr>
<tr>
<td>MIT</td>
<td>✅ Yes</td>
<td>Permissive</td>
</tr>
<tr>
<td>BSD-3-Clause</td>
<td>✅ Yes</td>
<td>Permissive</td>
</tr>
<tr>
<td>EPL 2.0</td>
<td>✅ Yes</td>
<td>Compatible</td>
</tr>
<tr>
<td>EPL 1.0</td>
<td>✅ Yes</td>
<td>Compatible</td>
</tr>
<tr>
<td>MPL 2.0</td>
<td>✅ Yes</td>
<td>Compatible</td>
</tr>
<tr>
<td>GPL 2.0 + FOSS/Classpath Exception</td>
<td>✅ Yes (conditional)</td>
<td>Exception allows linking</td>
</tr>
<tr>
<td>GPL 2.0 (without exception)</td>
<td>❌ No</td>
<td>Incompatible with Apache 2.0</td>
</tr>
</tbody>
</table>
<p>FIT4J uses only the <strong>compatible</strong> license types above, and the only GPL‑based dependency (MySQL Connector/J) is:</p>
<ul>
<li>Under GPL 2.0 <strong>with</strong> Classpath/FOSS exception.</li>
<li>Used <strong>only in test scope</strong>.</li>
<li>Not bundled in any runtime distribution artifact.</li>
</ul>
<h3>Special Cases</h3>
<h4>MySQL Connector/J (test scope, GPL 2.0 with Classpath Exception)</h4>
<p>Analysis summarized from <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L200-L243"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:200-243</code></a>:</p>
<ul>
<li>License: GPL 2.0 with Classpath/FOSS Exception.</li>
<li>Status: ✅ Compatible <strong>under specific conditions</strong>.</li>
<li>Usage: Only as <code>testImplementation</code>; not packaged with FIT4J’s deployable artifacts.</li>
<li>The Classpath Exception allows derivative works to be licensed under other terms while keeping the connector under GPL 2.0.</li>
</ul>
<p>Recommendations (from <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L200-L243"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:200-243</code></a>):</p>
<ul>
<li>No changes required to FIT4J’s license.</li>
<li>Document clearly that:</li>
<li>MySQL Connector/J is test-only in FIT4J.</li>
<li>Users who add it to their own projects are subject to GPL 2.0, modified by the FOSS Exception.</li>
</ul>
<p>This is already reflected in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md#L105-L116"><code>/LICENSE-THIRD-PARTY.md:105-116</code></a>.</p>
<h4>H2 Database (Dual Licensed MPL 2.0 / EPL 1.0)</h4>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L244-L261"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:244-261</code></a>:</p>
<ul>
<li>H2 is dual‑licensed under MPL 2.0 and EPL 1.0.</li>
<li>Both MPL 2.0 and EPL 1.0 are compatible with Apache 2.0 for the usage pattern here.</li>
<li>No additional obligations beyond normal attribution.</li>
</ul>
<h4>Jakarta Annotation API (EPL 2.0)</h4>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L262-L279"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:262-279</code></a>:</p>
<ul>
<li>License: EPL 2.0.</li>
<li>Considered fully compatible with Apache 2.0 for dependency usage.</li>
<li>No special actions required beyond documentation.</li>
</ul>
<h4>Protobuf (BSD-3-Clause)</h4>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L280-L297"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:280-297</code></a>:</p>
<ul>
<li>BSD-3-Clause is a permissive license compatible with Apache 2.0.</li>
<li>No special obligations beyond attribution and license preservation.</li>
</ul>
<h2>Required and Recommended Documentation Artifacts</h2>
<p>From <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L344-L381"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:344-381</code></a>:</p>
<h3>Required</h3>
<p>You should expect these files to exist and keep them updated:</p>
<ol>
<li><code>LICENSE</code>  </li>
<li>Contains Apache License 2.0 text.  </li>
<li>
<p>See official reference: https://www.apache.org/licenses/LICENSE-2.0</p>
</li>
<li>
<p><a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a>  </p>
</li>
<li>Lists all build/runtime/test dependencies and their licenses.  </li>
<li>
<p>Must be updated when dependencies change.</p>
</li>
<li>
<p>Source Code License Headers  </p>
</li>
<li>Apache 2.0 header added to all source files.  </li>
<li>
<p>Template at <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L58-L76"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:58-76</code></a>.</p>
</li>
<li>
<p>README License Section  </p>
</li>
<li>
<p><a href="https://github.com/harezmi/fit4j/blob/main//README.md#L21-L32"><code>/README.md:21-32</code></a> must continue to reference both <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a> and <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE_COMPATIBILITY_ANALYSIS.md"><code>LICENSE_COMPATIBILITY_ANALYSIS.md</code></a>.</p>
</li>
<li>
<p>POM/Gradle Metadata  </p>
</li>
<li>Published artifacts must correctly declare the project license (<code>Apache-2.0</code>) and, when necessary, reference third‑party licenses in generated POMs.  </li>
<li>See <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L298-L317"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:298-317</code></a> for guidance.</li>
</ol>
<h3>Recommended</h3>
<p>Also recommended by <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L344-L381"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:344-381</code></a>:</p>
<ul>
<li><code>NOTICE</code> file  </li>
<li>
<p>Required if you include any third‑party notices that must be surfaced with distributions.</p>
</li>
<li>
<p><a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>  </p>
</li>
<li>Should state that contributions are licensed under Apache 2.0 and that contributors must ensure added dependencies are license compatible.  </li>
<li>
<p><a href="https://github.com/harezmi/fit4j/blob/main//README.md#L33-L60"><code>/README.md:33-60</code></a> already references <a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>.</p>
</li>
<li>
<p>Verification Checklist<br />
  Before publishing to GitHub or distributing artifacts, verify:</p>
</li>
<li>
<p>[ ] <code>LICENSE</code> file present and correct  </p>
</li>
<li>[ ] <code>NOTICE</code> file present (if any dependencies require it)  </li>
<li>[ ] <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a> updated  </li>
<li>[ ] Source headers applied  </li>
<li>[ ] <a href="https://github.com/harezmi/fit4j/blob/main/README.md"><code>README.md</code></a> license section accurate  </li>
<li>[ ] <a href="https://github.com/harezmi/fit4j/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> present and consistent  </li>
<li>[ ] Build output and POMs list correct license metadata  </li>
</ul>
<h2>Practical Guidelines for Adding or Updating Dependencies</h2>
<p>When you modify dependencies, follow these steps (based on <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L120-L199"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:120-199</code></a>, <code>318-343</code>):</p>
<ol>
<li><strong>Identify License Type</strong>  </li>
<li>Check the library’s <code>LICENSE</code> file or Maven Central metadata.</li>
<li>
<p>Map it against the compatibility matrix in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L318-L343"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:318-343</code></a>.</p>
</li>
<li>
<p><strong>Check Scope of Usage</strong>  </p>
</li>
<li>
<p>Runtime vs test vs build tool:</p>
<ul>
<li>Runtime dependencies affect distributed artifacts and must be compatible with Apache 2.0.</li>
<li>Test-only dependencies are more flexible but still must avoid plain GPL without exception.</li>
<li>Build tools rarely affect your license but must still be documented in <a href="https://github.com/harezmi/fit4j/blob/main/LICENSE-THIRD-PARTY.md"><code>LICENSE-THIRD-PARTY.md</code></a>.</li>
</ul>
</li>
<li>
<p><strong>Update Documentation</strong>  </p>
</li>
<li>Add or adjust entries in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE-THIRD-PARTY.md"><code>/LICENSE-THIRD-PARTY.md</code></a>.  </li>
<li>
<p>If you introduce a more complex license (e.g., new copyleft with exception), add a short analysis entry to <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md</code></a>.</p>
</li>
<li>
<p><strong>Avoid Incompatible Licenses</strong>  </p>
</li>
<li>Do <strong>not</strong> add dependencies under GPL 2.0 or GPL 3.0 without a Classpath/FOSS exception, or other strong copyleft licenses incompatible with Apache 2.0, unless there is a clear and legally vetted separation (and update the compatibility analysis accordingly).</li>
</ol>
<h2>How This Affects Consumers of FIT4J</h2>
<p>For users of FIT4J:</p>
<ul>
<li>FIT4J itself is Apache 2.0 licensed; you can integrate it into Apache 2.0, MIT, BSD, proprietary, or similar projects.</li>
<li>Using FIT4J does <strong>not</strong> require your project to adopt the GPL or any copyleft license.</li>
<li>If your project <strong>independently</strong> adds dependencies like MySQL Connector/J, you must observe that dependency’s license:</li>
<li>For MySQL Connector/J, that is GPL 2.0 with Classpath/FOSS exception; see the upstream MySQL documentation referenced in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L382-L404"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:382-404</code></a>.</li>
</ul>
<h2>References</h2>
<p>Primary references documented in <a href="https://github.com/harezmi/fit4j/blob/main//LICENSE_COMPATIBILITY_ANALYSIS.md#L382-L404"><code>/LICENSE_COMPATIBILITY_ANALYSIS.md:382-404</code></a>:</p>
<ul>
<li><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></li>
<li><a href="https://www.apache.org/legal/resolved.html">Apache License Compatibility</a></li>
<li><a href="https://dev.mysql.com/downloads/connector/j/">MySQL Connector/J FOSS Exception</a></li>
<li><a href="https://www.gnu.org/software/classpath/license.html">GPL Classpath Exception</a></li>
</ul>
<p>For domain terminology (e.g., what FIT4J does functionally), see the dedicated <strong>Glossary</strong> or <strong>Project Overview</strong> sections of this wiki.</p>
  </div>
</section>

    </main>
  </div>
</div>

<script>
function showSection(id) {
  // Section görünürlüğü
  var sections = document.querySelectorAll('.dw-section');
  sections.forEach(function(sec) {
    if (sec.id === id) {
      sec.classList.add('dw-section-active');
    } else {
      sec.classList.remove('dw-section-active');
    }
  });

  // Sidebar aktif state
  var items = document.querySelectorAll('.dw-nav-item');
  items.forEach(function(item) {
    if (item.getAttribute('data-target') === id) {
      item.classList.add('dw-nav-item-active');
    } else {
      item.classList.remove('dw-nav-item-active');
    }
  });
}

document.addEventListener('DOMContentLoaded', function() {
  var firstSection = document.querySelector('.dw-section');
  if (firstSection) {
    showSection(firstSection.id);
  }
  
  // Mermaid initialization with error handling
  if (window.mermaid) {
    mermaid.initialize({
      startOnLoad: false,
      theme: "dark",
      securityLevel: "loose",
      flowchart: {
        useMaxWidth: true,
        htmlLabels: false,
        curve: "basis"
      },
      sequence: {
        useMaxWidth: true,
        wrap: true
      }
    });
    
    // Render each mermaid diagram with error handling
    document.querySelectorAll('.mermaid').forEach(function(el, idx) {
      var content = el.textContent.trim();
      if (!content) {
        el.innerHTML = '<p style="color:#94a3b8;font-style:italic;">No diagram content</p>';
        return;
      }
      try {
        var id = 'mermaid-' + idx;
        mermaid.render(id, content).then(function(result) {
          el.innerHTML = result.svg;
        }).catch(function(err) {
          console.error('Mermaid render error:', err);
          el.innerHTML = '<p style="color:#f87171;font-size:12px;">Diagram could not be rendered</p><pre style="color:#64748b;font-size:11px;white-space:pre-wrap;">' + content.substring(0, 200) + '...</pre>';
        });
      } catch (err) {
        console.error('Mermaid error:', err);
        el.innerHTML = '<p style="color:#f87171;">Diagram error</p>';
      }
    });
  }
});
</script>
</body>
</html>
