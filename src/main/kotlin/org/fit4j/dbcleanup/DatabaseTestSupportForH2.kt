package org.fit4j.dbcleanup

import com.zaxxer.hikari.pool.HikariProxyConnection
import org.h2.jdbc.JdbcConnection
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.transaction.PlatformTransactionManager
import java.sql.Connection
import javax.sql.DataSource

class DatabaseTestSupportForH2(dataSource: DataSource, transactionManager: PlatformTransactionManager) :
    AbstractDatabaseTestSupport(dataSource, transactionManager) {
    override fun executeResetAllIdentifiers(jdbcTemplate: JdbcTemplate, schemaName: String) {
        val tablesWithPKColumns = jdbcTemplate.queryForList("""
            SELECT 
                t.table_name,
                k.column_name,
                c.is_identity
            FROM information_schema.tables t
            JOIN information_schema.table_constraints tc 
                ON t.table_name = tc.table_name
                AND t.table_schema = tc.table_schema
                AND tc.constraint_type = 'PRIMARY KEY'
            JOIN information_schema.key_column_usage k 
                ON tc.constraint_name = k.constraint_name
                AND tc.table_name = k.table_name
                AND tc.table_schema = k.table_schema
            JOIN information_schema.columns c
                ON c.table_name = k.table_name
                AND c.table_schema = k.table_schema
                AND c.column_name = k.column_name
            WHERE t.table_schema = '$schemaName'
            ORDER BY t.table_name, k.ordinal_position
        """.trimIndent())

        val tablesWithMatchingSequences = jdbcTemplate.queryForList("""
            SELECT
                t.table_name,
                s.sequence_name
            FROM information_schema.tables t
            JOIN information_schema.sequences s
                ON s.sequence_name = CONCAT(t.table_name, '_SEQ')
            WHERE t.table_schema = '$schemaName'
              AND s.sequence_schema = '$schemaName'
            ORDER BY t.table_name
        """.trimIndent())

        tablesWithPKColumns.forEach {
            val is_identity = it["is_identity"]
            val column_name = it["column_name"]
            val table_name = it["table_name"]
            if("YES".equals(is_identity)) {
                jdbcTemplate.execute(
                    "ALTER TABLE IF EXISTS `$table_name` ADD `__$column_name` BIGINT GENERATED BY DEFAULT AS IDENTITY"
                )
                jdbcTemplate.execute("ALTER TABLE IF EXISTS `$table_name` DROP COLUMN $column_name")
                jdbcTemplate.execute(
                    "ALTER TABLE IF EXISTS `$table_name` ALTER COLUMN `__$column_name` RENAME TO $column_name"
                )
            } else {
                val tableWithSeq = tablesWithMatchingSequences.filter { it["table_name"]!!.equals(table_name) }.firstOrNull()
                if(tableWithSeq!=null) {
                    val seq_name = tableWithSeq["sequence_name"]
                    jdbcTemplate.execute("ALTER SEQUENCE $seq_name RESTART WITH 1")
                } else {
                    //do nothing as PK is user managed value ie assigned
                }
            }
        }
    }

    override fun executeClearAllTables(jdbcTemplate: JdbcTemplate, schemaName: String) {
        jdbcTemplate.execute("SET REFERENTIAL_INTEGRITY FALSE")
        val tableNames =
            jdbcTemplate.queryForList(
                "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '$schemaName'",
                String::class.java,
            )
        tableNames.forEach { tableName ->
            jdbcTemplate.execute(
                """
                    TRUNCATE TABLE "$tableName"
                """
                    .trimIndent()
            )
        }
        jdbcTemplate.execute("SET REFERENTIAL_INTEGRITY TRUE")
    }

    override fun schemaName(): String {
        val c = dataSource.connection
        val name = c.schema
        c.close()
        return name
    }

    override fun connection(): Connection {
        val conn = super.connection()
        val unwrappedConn = if(conn is HikariProxyConnection) (conn as HikariProxyConnection).unwrap(JdbcConnection::class.java) else conn
        return unwrappedConn
    }
}
